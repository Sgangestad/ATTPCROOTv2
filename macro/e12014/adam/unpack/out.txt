
Processing unpack_linked.C...
G__Base dictionary payload:4540:32: error: base class has incomplete type
class FairMixedSource : public FairFileSourceBase
                        ~~~~~~~^~~~~~~~~~~~~~~~~~
/home/physics/fair_install/FairRootInstall/include/FairFileSourceBase.h:21:7: note: definition of 'FairFileSourceBase' is not complete until the closing '}'
class FairFileSourceBase : public FairSource
      ^
G__Base dictionary payload:4550:24: error: only virtual member functions can be marked 'override'
    ~FairMixedSource() override;
                       ^~~~~~~~
G__Base dictionary payload:4552:19: error: only virtual member functions can be marked 'override'
    Bool_t Init() override;
                  ^~~~~~~~
G__Base dictionary payload:4553:35: error: only virtual member functions can be marked 'override'
    Int_t ReadEvent(UInt_t i = 0) override;
                                  ^~~~~~~~
G__Base dictionary payload:4554:18: error: only virtual member functions can be marked 'override'
    void Close() override;
                 ^~~~~~~~
G__Base dictionary payload:4557:45: error: only virtual member functions can be marked 'override'
    Int_t CheckMaxEventNo(Int_t EvtEnd = 0) override;
                                            ^~~~~~~~
G__Base dictionary payload:4559:46: error: only virtual member functions can be marked 'override'
    void ReadBranchEvent(const char* BrName) override;
                                             ^~~~~~~~
G__Base dictionary payload:4561:59: error: only virtual member functions can be marked 'override'
    void ReadBranchEvent(const char* BrName, Int_t Entry) override;
                                                          ^~~~~~~~
G__Base dictionary payload:4563:48: error: only virtual member functions can be marked 'override'
    void FillEventHeader(FairEventHeader* feh) override;
                                               ^~~~~~~~
G__Base dictionary payload:4568:62: error: only virtual member functions can be marked 'override'
    Bool_t ActivateObject(TObject** obj, const char* BrName) override;
                                                             ^~~~~~~~
G__Base dictionary payload:4569:74: error: only virtual member functions can be marked 'override'
    Bool_t ActivateObjectAny(void**, const std::type_info&, const char*) override;
                                                                         ^~~~~~~~
G__Base dictionary payload:4732:27: error: only virtual member functions can be marked 'override'
    Bool_t SpecifyRunId() override;
                          ^~~~~~~~
G__Base dictionary payload:4738:5: error: only virtual member functions can be marked 'override'
    ClassDefOverride(FairMixedSource, 0);
    ^
input_line_22:13:28: note: expanded from macro 'ClassDefOverride'
_ClassDefOutline_(name,id,,override)\
                           ^
G__Base dictionary payload:4738:5: error: only virtual member functions can be marked 'override'
input_line_22:13:28: note: expanded from macro 'ClassDefOverride'
_ClassDefOutline_(name,id,,override)\
                           ^
G__Base dictionary payload:4738:5: error: only virtual member functions can be marked 'override'
input_line_22:13:28: note: expanded from macro 'ClassDefOverride'
_ClassDefOutline_(name,id,,override)\
                           ^
G__Base dictionary payload:4738:5: error: only virtual member functions can be marked 'override'
input_line_22:13:28: note: expanded from macro 'ClassDefOverride'
_ClassDefOutline_(name,id,,override)\
                           ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class FairFileSourceBase with content:

#line 1 "G__Base dictionary payload"

#ifndef BUILD_PROOF_SUPPORT
  #define BUILD_PROOF_SUPPORT 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilder header file                -----
// -----                  Created 23/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------

/** FairEventBuilder
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 23/09/2013
 *@version 1.0
 **
 ** FairRoot base task for the event buffers.
 ** The tasks may:
 ** 1. analyze data to reconstruct event times or other characteristics
 **    in the function TClonesArray* FindEvents(), that returns
 **    TClonesArray of FairRecoEvents
 ** 2. identify the data that could belong to event in the
 **    function and insert this identified data to the output TClonesArrays
 **    in the function StoreEventData(event)
 ** The implementations may be using any or both of the above functions.
 **/

#ifndef FAIREVENTBUILDER_H
#define FAIREVENTBUILDER_H 1

#include "FairRecoEventHeader.h"
#include "FairWriteoutBuffer.h"

#include <Rtypes.h>
#include <TStopwatch.h>
#include <TString.h>
#include <utility>   // pair
#include <vector>

class TClonesArray;
// class FairRecoEventHeader;

class FairEventBuilder : public FairWriteoutBuffer
{
  public:
    /** Default constructor **/
    FairEventBuilder();

    /** Constructor with task name **/
    FairEventBuilder(TString branchName, TString className, TString folderName, Bool_t persistance);

    /** Destructor **/
    virtual ~FairEventBuilder();

    virtual void WriteOutAllDeadTimeData();

    virtual std::vector<std::pair<double, FairRecoEventHeader*>> FindEvents() = 0;
    virtual void StoreEventData(FairRecoEventHeader* /*recoEvent*/) = 0;

    void SetIdentifier(Int_t ident) { fIdentifier = ident; }
    Int_t GetIdentifier() { return fIdentifier; }

    virtual Bool_t Init() = 0;

    virtual void Print(Option_t* option = "") const = 0;

    /** Finish at the end of each event **/
    virtual void Finish();

    Double_t AllowedTime() { return fMaxAllowedEventCreationTime; };
    void SetMaxAllowedTime(Double_t td) { fMaxAllowedEventCreationTime = td; };

    void SetBuilderName(const char* name) { fBuilderName = name; }
    TString GetBuilderName() { return fBuilderName; }

  private:
    TString fBuilderName;

    TStopwatch fTimer;
    Double_t fExecTime;

    Int_t fIdentifier;
    Double_t fMaxAllowedEventCreationTime;

    ClassDef(FairEventBuilder, 1);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilderManager header file              -----
// -----                  Created 20/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------

/** FairEventBuilderManager
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 20/09/2013
 *@version 1.0
 **
 ** FairRoot general task for recreating events in Time-Based reconstruction mode.
 ** Various experiments should implement their own version of Event Builder.
 ** The main member of the task is vector of reconstructed events fRecoEvents.
 ** It also contains a vector of implementations of FairEventBuilders, that are
 ** responsible for feeding fRecoEvents vector via FindEvents() function.
 **
 ** The heart of the experiment-specific implemenations is
 ** the AnalyzeAndExtractEvents() function, which should interpret
 ** the experimental data to reconstruct events.
 **/

#ifndef FAIREVENTBUILDERMANAGER_H
#define FAIREVENTBUILDERMANAGER_H 1

#include "FairEventBuilder.h"
#include "FairTask.h"

#include <Rtypes.h>   // ClassDef
#include <vector>

class TClonesArray;

class FairEventBuilderManager : public FairTask
{
  public:
    /** Default constructor **/
    FairEventBuilderManager();

    /** Constructor with task name **/
    FairEventBuilderManager(const char* name, Int_t iVerbose = 1);

    /** Destructor **/
    virtual ~FairEventBuilderManager();

    /** Execution **/
    virtual void Exec(Option_t* opt);

    /** Adding FairEventBuilder **/
    virtual void AddEventBuilder(FairEventBuilder* eventBuilder);

  protected:
    std::vector<FairEventBuilder*> fEventBuilders;
    std::vector<std::vector<std::pair<double, FairRecoEventHeader*>>> fPossibleEvents;

    /** Fill events from various builders **/
    virtual Double_t FillEventVectors();

    /** Analyze and extract events - experiment specific **/
    virtual void AnalyzeAndExtractEvents(Double_t maxEventTimeAllowed) = 0;

    /** Create output tree structure **/
    virtual void CreateAndFillEvent(FairRecoEventHeader* recoEvent);

  private:
    /** Intialisation **/
    virtual InitStatus Init();

    /** Reinitialisation **/
    virtual InitStatus ReInit();

    /** Finish at the end of each event **/
    virtual void Finish();

    ClassDef(FairEventBuilderManager, 1);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2023 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairEventHeader header file                      -----
// -----          Created 08/09/04                 D.Bertini           -----
// -------------------------------------------------------------------------

#ifndef FAIREVENTHEADER_H
#define FAIREVENTHEADER_H

#include <Rtypes.h>   // for Int_t, Double_t, UInt_t, ClassDef, etc
#include <TNamed.h>   // for TNamed

/**
 *  Event Header Class
 **@author D.Bertini <d.bertini@gsi.de>
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairEventHeader : public TNamed
{
  public:
    /** Default constructor */
    FairEventHeader() = default;

    /**
     * Destructor
     */
    ~FairEventHeader() override = default;

    /** Get the run ID for this run*/
    UInt_t GetRunId() const { return fRunId; }

    /** Get the MC time for this event*/
    Double_t GetEventTime() const { return fEventTime; }

    /** Get the MC input file Id for this event*/
    Int_t GetInputFileId() const { return fInputFileId; }

    /**The entry number in the original MC chain */
    Int_t GetMCEntryNumber() const { return fMCEntryNo; }

    /** Set the run ID for this run
     * @param runid : unique run id
     */
    void SetRunId(UInt_t runid) { fRunId = runid; }

    /** Set the MC time for this event
     * @param time : time in ns
     */
    void SetEventTime(Double_t time) { fEventTime = time; }

    /** Set the Signal file Id for this event*/
    void SetInputFileId(Int_t id) { fInputFileId = id; }

    /**The entry number in the original MC chain */
    void SetMCEntryNumber(Int_t id) { fMCEntryNo = id; }

    virtual void Register(Bool_t Persistance = kTRUE);

  protected:
    /** Run Id */
    UInt_t fRunId{0};
    /** Event Time **/
    Double_t fEventTime{-1.};
    /** Input file identifier, the file description is in the File header*/
    Int_t fInputFileId{0};
    /**MC entry number from input chain*/
    Int_t fMCEntryNo{0};

    ClassDefOverride(FairEventHeader, 3);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                         FairFileHeader source file           -----
// -----            Created 20/04/11                 M.Al-Turany        -----
// -------------------------------------------------------------------------

#ifndef FAIRFILEHEADER_H
#define FAIRFILEHEADER_H

#include <Rtypes.h>    // for UInt_t, etc
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString

class FairFileInfo;
class TFile;
class TList;

/**
 *  File Header Class
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairFileHeader : public TNamed
{
  public:
    /** Default constructor */
    FairFileHeader();

    /**Add a class name of a task*/
    void AddTaskClassName(TString taskname);

    /** Set the run ID for this run
     * @param runid : unique run id
     */
    void SetRunId(UInt_t runid) { fRunId = runid; }

    /** Get the run ID for this run*/
    UInt_t GetRunId() { return fRunId; }

    /** Return the list of tasks class names */
    TList* GetListOfTasks() { return fTaskList; }

    void AddInputFile(TFile* f, UInt_t id, UInt_t ChId);

    /**
     * Destructor
     */
    virtual ~FairFileHeader();

    FairFileInfo* GetFileInfo(UInt_t id, UInt_t ChId);

  protected:
    /** Run Id */
    UInt_t fRunId;

    /**list of TObjStrings presenting the class names of tasks used to produce this file */
    TList* fTaskList;

    /**list of TObjStrings presenting the input files used to produce this file*/
    TList* fFileList;

  private:
    FairFileHeader(const FairFileHeader&);
    FairFileHeader& operator=(const FairFileHeader&);

    ClassDef(FairFileHeader, 2);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//  FairFileInfo.h
//  Created by Mohammad Al-Turany on 6/21/11.
//
#ifndef FAIRFILEINFO_H
#define FAIRFILEINFO_H

#include <Rtypes.h>    // for UInt_t, FairFileInfo::Class, etc
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString

class TFile;

class FairFileInfo : public TNamed
{
  public:
    FairFileInfo();
    FairFileInfo(TFile* file, UInt_t id, UInt_t ChId);
    virtual ~FairFileInfo();

    TString GetPath() { return fPath; }
    UInt_t GetSize() { return fSize; }
    UInt_t GetIdentifier() { return fIdentifier; }
    UInt_t GetOrderInChain() { return fInChainId; }

    void Print(Option_t* option = "") const;

    void SetPath(TString path) { fPath = path; }
    void SetSize(UInt_t size) { fSize = size; }
    void SetIdentifier(UInt_t id) { fIdentifier = id; }
    void SetOrderInChain(UInt_t id) { fInChainId = id; }

  protected:
    /** Full path of file*/
    TString fPath;
    /** size of file in bytes*/
    UInt_t fSize;
    /** Signal file identifier used*/
    UInt_t fIdentifier;
    /** file order in the chain*/
    UInt_t fInChainId;

  private:
    FairFileInfo(const FairFileInfo&);
    FairFileInfo& operator=(const FairFileInfo&);

    ClassDef(FairFileInfo, 1);
};

#endif   // FAIRFILEINFO_H
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRHIT_H
#define FAIRHIT_H

#include "FairTimeStamp.h"   // for FairTimeStamp

#include <Rtypes.h>     // for Double_t, Int_t, Double32_t, etc
#include <TVector3.h>   // for TVector3

/**
 * Abstract base class for reconstructed hits in the FAIR detectors.
 **@author V.Friese <v.friese@gsi.de>
 **@author D.Bertini <d.bertini@gsi.de>
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairHit : public FairTimeStamp
{
  public:
    /** Default constructor **/
    FairHit();

    /** Constructor with hit parameters **/
    FairHit(Int_t detID, const TVector3& pos, const TVector3& dpos, Int_t index);

    /** Destructor **/
    virtual ~FairHit();

    /** Accessors **/
    Double_t GetDx() const { return fDx; };
    Double_t GetDy() const { return fDy; };
    Double_t GetDz() const { return fDz; };
    Int_t GetRefIndex() const { return fRefIndex; };
    void PositionError(TVector3& dpos) const;
    Int_t GetDetectorID() const { return fDetectorID; };
    Double_t GetX() const { return fX; };
    Double_t GetY() const { return fY; };
    Double_t GetZ() const { return fZ; };
    void Position(TVector3& pos) const;

    /** Modifiers **/
    void SetDx(Double_t dx) { fDx = dx; }
    void SetDy(Double_t dy) { fDy = dy; }
    void SetDz(Double_t dz) { fDz = dz; }
    void SetDxyz(Double_t dx, Double_t dy, Double_t dz);
    void SetPositionError(const TVector3& dpos);
    void SetRefIndex(Int_t index) { fRefIndex = index; }
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);

    /*** Output to screen */
    virtual void Print(const Option_t*) const { ; }

  protected:
    Double32_t fDx, fDy, fDz;   ///< Errors of position [cm]
    Int_t fRefIndex;            ///< Index of FairMCPoint for this hit
    Int_t fDetectorID;          ///< Detector unique identifier
    Double32_t fX, fY, fZ;      ///< Position of hit [cm]

    ClassDef(FairHit, 3);
};

inline void FairHit::PositionError(TVector3& dpos) const { dpos.SetXYZ(fDx, fDy, fDz); }

inline void FairHit::SetDxyz(Double_t dx, Double_t dy, Double_t dz)
{
    fDx = dx;
    fDy = dy;
    fDz = dz;
}

inline void FairHit::SetPositionError(const TVector3& dpos)
{
    fDx = dpos.X();
    fDy = dpos.Y();
    fDz = dpos.Z();
}

inline void FairHit::Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); }

inline void FairHit::SetXYZ(Double_t x, Double_t y, Double_t z)
{
    fX = x;
    fY = y;
    fZ = z;
}

inline void FairHit::SetPosition(const TVector3& pos)
{
    fX = pos.X();
    fY = pos.Y();
    fZ = pos.Z();
}

#endif   // FAIRHIT_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairLink.h
 *
 *  Created on: Dec 23, 2009
 *      Author: stockman
 *      "Pointer" to any data structure inside a root file with a tree structure
 *      Contains four information:
 *      	File : in which file is the data written (-1 : actual number; 254 : maximum number)
 *      	Entry: entry number in branch of a tree (-1 : actual entry)
 *      	Type : branch inside the tree (-1 : FairLink not set; 65534 : maximum number)
 *      	Index: position inside a container stored in the given branch and entry
 *      	Weight: weighting factor to describe probabilities of a MC truth match
 *
 */

#ifndef FAIRLINK_H_
#define FAIRLINK_H_

#include <Rtypes.h>   // for Int_t, Float_t, etc, ClassDefNV
#include <iostream>   // for ostream, cout

class FairLink
{
  public:
    FairLink();
    FairLink(Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(TString branchName, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, TString branchName, Int_t index, Float_t weight = 1.);
    ~FairLink(){};

    void SetLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.)
    {
        SetFile(file);
        SetEntry(entry);
        SetType(type);
        SetIndex(index);
        SetWeight(weight);
    };
    void SetLink(Int_t type, Int_t index, Float_t weight = 1.)
    {
        SetFile(-1);
        SetEntry(-1);
        SetType(type);
        SetIndex(index);
        SetWeight(weight);
    };
    int GetFile() const;
    int GetEntry() const { return fEntry; }
    int GetType() const;
    int GetIndex() const { return fIndex; }
    float GetWeight() const { return fWeight; }

    void SetFile(int file);
    void SetEntry(int entry) { fEntry = entry; };
    void SetType(int type);
    void SetIndex(int index) { fIndex = index; };

    void SetWeight(Float_t weight) { fWeight = weight; }
    void AddWeight(Float_t weight) { fWeight += weight; }

    void PrintLinkInfo(std::ostream& out = std::cout) const;

    bool operator==(const FairLink& link) const
    {
        return (GetFile() == link.GetFile() || link.GetFile() == -1)
               && (GetEntry() == link.GetEntry() || link.GetEntry() == -1) && GetType() == link.GetType()
               && GetIndex() == link.GetIndex();
    }

    bool operator<(const FairLink& link) const
    {
        if (GetFile() != -1 && link.GetFile() != -1) {
            if (GetFile() < link.GetFile())
                return true;
            else if (link.GetFile() < GetFile())
                return false;
        }
        if (GetEntry() != -1 && link.GetEntry() != -1) {
            if (GetEntry() < link.GetEntry())
                return true;
            else if (link.GetEntry() < GetEntry())
                return false;
        }
        if (GetType() < link.GetType())
            return true;
        else if (link.GetType() < GetType())
            return false;
        if (GetIndex() < link.GetIndex())
            return true;
        else if (link.GetIndex() < GetIndex())
            return false;

        return false;
    }

    friend std::ostream& operator<<(std::ostream& out, const FairLink& link)
    {
        link.PrintLinkInfo(out);
        return out;
    }

    ClassDefNV(FairLink, 5);

    template<class Archive>
    void serialize(Archive& ar, const unsigned int)
    {
        ar& fFile;
        ar& fType;
        ar& fEntry;
        ar& fIndex;
        ar& fWeight;
    }

  private:
    unsigned char fFile;
    unsigned short fType;
    int fEntry;
    int fIndex;
    float fWeight;
};

inline FairLink::FairLink()
    : fFile(0)
    , fType(0)
    , fEntry(-1)
    , fIndex(-1)
    , fWeight(1.0)
{}

inline FairLink::FairLink(Int_t type, Int_t index, Float_t weight)
    : fFile(0)
    , fType(0)
    , fEntry(-1)
    , fIndex(index)
    , fWeight(weight)
{
    SetType(type);
}

inline FairLink::FairLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight)
    : fFile(0)
    , fType(0)
    , fEntry(entry)
    , fIndex(index)
    , fWeight(weight)
{
    SetFile(file);
    SetType(type);
}

inline void FairLink::SetType(int type)
{
    if (type < -1)
        return;
    fType = type + 1;
}

inline int FairLink::GetType() const
{
    int type = fType;
    return type - 1;
}

inline void FairLink::SetFile(int file)
{
    if (file < -1)
        return;
    fFile = file + 1;
}

inline int FairLink::GetFile() const
{
    int file = fFile;
    return file - 1;
}

#endif /* FAIRLINK_H_ */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/** FairMCEventHeader.h
 *@author V.Friese <v.friese@gsi.de>
 ** Data class (level MC) containing information about the input event.
 ** 15.05.2008 change the event time to ns (M. Al-Turany)
 **/

#ifndef FAIRMCEVENTHEADER_H
#define FAIRMCEVENTHEADER_H 1

#include <Rtypes.h>     // for Double_t, UInt_t, etc
#include <TNamed.h>     // for TNamed
#include <TVector3.h>   // for TVector3
#include <limits>       // for std::numeric_limits

class FairMCEventHeader : public TNamed
{
  public:
    /// Alias name for event id type
    using EventID = UInt_t;

    /// Sentinel value for the event id, meaning no event id stored
    static constexpr EventID NoEventID = std::numeric_limits<EventID>::max();

    /** Default constructor **/
    FairMCEventHeader();

    /** Constructor with all members
     **
     *@param iEvent   event identifier
     *@param x,y,z    vertex oordinates [cm]
     *@param t        event time [ns]
     *@param b        impact parameter [fm] (if relevant)
     *@param nPrim    number of input tracks
     **/
    FairMCEventHeader(EventID iEvent, Double_t x, Double_t y, Double_t z, Double_t t, Double_t b, Int_t nPrim);

    /** Standard constructor with run identifier **/
    FairMCEventHeader(UInt_t runId);

    /** Destructor **/
    virtual ~FairMCEventHeader();

    /** Accessors **/
    UInt_t GetRunID() const { return fRunId; }        /// run identifier
    EventID GetEventID() const { return fEventId; }   /// event identifier
    /// check whether an event id is set
    Bool_t HasEventID() const { return fEventId != NoEventID; }
    Double_t GetX() const { return fX; }         /// vertex x [cm]
    Double_t GetY() const { return fY; }         /// vertex y [cm]
    Double_t GetZ() const { return fZ; }         /// vertex z [cm]
    Double_t GetT() const { return fT; }         /// event time [ns]
    Double_t GetB() const { return fB; }         /// impact parameter [fm]
    Int_t GetNPrim() const { return fNPrim; }    /// number of input tracks
    Bool_t IsSet() const { return fIsSet; }      /// Flag
    Double_t GetRotX() const { return fRotX; }   /// rot. around x-axis [rad]
    Double_t GetRotY() const { return fRotY; }   /// rot. around y-axis [rad]
    Double_t GetRotZ() const { return fRotZ; }   /// rot. around z-axis [rad]

    void GetVertex(TVector3& vertex) { vertex.SetXYZ(fX, fY, fZ); }

    /** Modifiers **/
    void SetEventID(EventID eventId) { fEventId = eventId; }
    void SetRunID(UInt_t runId) { fRunId = runId; }
    void SetTime(Double_t t) { fT = t; }
    void SetB(Double_t b) { fB = b; }
    void SetNPrim(Int_t nPrim) { fNPrim = nPrim; }
    void MarkSet(Bool_t isSet) { fIsSet = isSet; }
    void SetVertex(Double_t x, Double_t y, Double_t z);
    void SetVertex(const TVector3& vertex);
    void SetRotX(Double_t rotx) { fRotX = rotx; }
    void SetRotY(Double_t roty) { fRotY = roty; }
    void SetRotZ(Double_t rotz) { fRotZ = rotz; }

    /** Reset all members **/
    void Reset();

    /** Register the class as data branch to the output */
    virtual void Register();

  protected:
    UInt_t fRunId;                 ///  Run identifier
    EventID fEventId{NoEventID};   ///  Event identifier
    Double32_t fX;                 ///  Primary vertex x [cm]
    Double32_t fY;                 ///  Primary vertex y [cm]
    Double32_t fZ;                 ///  Primary vertex z [cm]
    Double32_t fT;                 ///  Event time [s]
    Double32_t fB;                 ///  Impact parameter [fm] (if relevant)
    Int_t fNPrim;                  ///  Number of input tracks
    Bool_t fIsSet;                 ///  Flag whether variables are filled
    Double32_t fRotX;              ///  Rotation around x-axis (beam tilt) [rad]
    Double32_t fRotY;              ///  Rotation around y-axis (beam tilt) [rad]
    Double32_t fRotZ;              ///  Rotation around z-axis (event plane) [rad]

    ClassDef(FairMCEventHeader, 2);
};

inline void FairMCEventHeader::SetVertex(Double_t x, Double_t y, Double_t z)
{
    fX = x;
    fY = y;
    fZ = z;
}

inline void FairMCEventHeader::SetVertex(const TVector3& vertex)
{
    fX = vertex.X();
    fY = vertex.Y();
    fZ = vertex.Z();
}

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**  FairMCPoint.h
 * This is the base class for all MC Points generated by the transport of
 * tracks through active detectors.
 **/

#ifndef FAIRMCPOINT_H
#define FAIRMCPOINT_H

#include "FairMultiLinkedData_Interface.h"   // for FairMultiLinkedData

#include <Rtypes.h>     // for Double_t, Double32_t, Int_t, etc
#include <TVector3.h>   // for TVector3

class FairMCPoint : public FairMultiLinkedData_Interface
{
  public:
    /** Default constructor **/
    FairMCPoint();

    /** Constructor with arguments
     *@param trackID  Index of MCTrack
     *@param detID    Detector ID
     *@param pos      Point coordinates [cm]
     *@param mom      Momentum of track at MCPoint [GeV]
     *@param tof      Time since event start [ns]
     *@param length   Track length since creation [cm]
     *@param eLoss    Energy deposit [GeV]
     *@param EventId  MC event id
     **/
    FairMCPoint(Int_t trackID,
                Int_t detID,
                TVector3 pos,
                TVector3 mom,
                Double_t tof,
                Double_t length,
                Double_t eLoss,
                UInt_t EventId = 0);

    /** Destructor **/
    virtual ~FairMCPoint();

    /** Accessors */
    UInt_t GetEventID() const { return fEventId; }   /// event identifier
    Int_t GetTrackID() const { return fTrackID; }
    Double_t GetPx() const { return fPx; }
    Double_t GetPy() const { return fPy; }
    Double_t GetPz() const { return fPz; }
    Double_t GetTime() const { return fTime; }
    Double_t GetLength() const { return fLength; }
    Double_t GetEnergyLoss() const { return fELoss; }
    void Momentum(TVector3& mom) const { mom.SetXYZ(fPx, fPy, fPz); }
    Int_t GetDetectorID() const { return fDetectorID; };
    Double_t GetX() const { return fX; };
    Double_t GetY() const { return fY; };
    Double_t GetZ() const { return fZ; };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); }

    /** Modifiers **/
    void SetEventID(UInt_t eventId) { fEventId = eventId; }
    virtual void SetTrackID(Int_t id) { fTrackID = id; }
    void SetTime(Double_t time) { fTime = time; }
    void SetLength(Double_t length) { fLength = length; }
    void SetEnergyLoss(Double_t eLoss) { fELoss = eLoss; }
    void SetMomentum(const TVector3& mom);
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);

    /** Output to screen **/
    virtual void Print(const Option_t* opt = 0) const;

  protected:
    Int_t fTrackID;             ///< Track index
    UInt_t fEventId;            ///< MC Event id
    Double32_t fPx, fPy, fPz;   ///< Momentum components [GeV]
    Double32_t fTime;           ///< Time since event start [ns]
    Double32_t fLength;         ///< Track length since creation [cm]
    Double32_t fELoss;          ///< Energy loss at this point [GeV]
    Int_t fDetectorID;          ///< Detector unique identifier
    Double32_t fX, fY, fZ;      ///< Position of hit [cm]

    ClassDef(FairMCPoint, 5);
};

inline void FairMCPoint::SetMomentum(const TVector3& mom)
{
    fPx = mom.Px();
    fPy = mom.Py();
    fPz = mom.Pz();
}

inline void FairMCPoint::SetXYZ(Double_t x, Double_t y, Double_t z)
{
    fX = x;
    fY = y;
    fZ = z;
}

inline void FairMCPoint::SetPosition(const TVector3& pos)
{
    fX = pos.X();
    fY = pos.Y();
    fZ = pos.Z();
}

#endif   // FAIRMCPOINT_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairMesh header file                    -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------

#ifndef FAIRMESH_H
#define FAIRMESH_H

#include <Rtypes.h>    // for Double_t, Int_t, etc
#include <TH2.h>       // for TH2D
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString

/**
 * Abstract base class for Mesh Objects.
 **@author D.Bertini <d.bertini@gsi.de>
 */
class FairMesh : public TObject
{
  public:
    /** Default constructor **/
    FairMesh();
    FairMesh(const char*);

    /** Destructor **/
    virtual ~FairMesh();

    /** Accessors **/
    Double_t GetXmin() const { return fXmin; };
    Double_t GetYmin() const { return fYmin; };
    Double_t GetZmin() const { return fZmin; };

    Double_t GetXmax() const { return fXmax; };
    Double_t GetYmax() const { return fYmax; };
    Double_t GetZmax() const { return fZmax; };

    /** Modifiers **/
    void SetX(Double_t xmin, Double_t xmax, Int_t nbin)
    {
        fXmin = xmin;
        fXmax = xmax;
        NXbin = nbin;
    }
    void SetY(Double_t ymin, Double_t ymax, Int_t nbin)
    {
        fYmin = ymin;
        fYmax = ymax;
        NYbin = nbin;
    }
    void SetZ(Double_t zmin, Double_t zmax, Int_t nbin)
    {
        fZmin = zmin;
        fZmax = zmax;
        NZbin = nbin;
    }

    TH2D* GetMeshTid() { return fMeshTid; }
    TH2D* GetMeshFlu() { return fMeshFlu; }
    TH2D* GetMeshSEU() { return fMeshSEU; }
    /*** Output to screen */
    // virtual void Print(const Option_t* opt = 0) const {;}

    Double_t GetDiag() { return fDiag; }
    Double_t GetBinVolume() { return fBinVolume; }

    void fillTID(Double_t x, Double_t y, Double_t we) { fMeshTid->Fill(x, y, we); }
    void fillFluence(Double_t x, Double_t y, Double_t we) { fMeshFlu->Fill(x, y, we); }
    void fillSEU(Double_t x, Double_t y, Double_t we) { fMeshSEU->Fill(x, y, we); }
    void Scale(Double_t fac)
    {
        fMeshTid->Scale(fac);
        fMeshFlu->Scale(fac);
        fMeshSEU->Scale(fac);
    }

    void calculate();

    void print();

  protected:
    Double_t fXmin, fYmin, fZmin;
    Double_t fXmax, fYmax, fZmax;
    Int_t NXbin, NYbin, NZbin;
    Double_t fBinVolume;
    Double_t fDiag;
    TH2D* fMeshTid;   // !mesh
    TH2D* fMeshFlu;   // !mesh
    TH2D* fMeshSEU;   // !mesh
    TString fhname;   // !mesh

  private:
    FairMesh(const FairMesh&);
    FairMesh& operator=(const FairMesh&);

    ClassDef(FairMesh, 1);
};

#endif
/**
 * FairMultiLinkedData_Interface.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FairMultiLinkedData_Interface_H_
#define FairMultiLinkedData_Interface_H_

#include "FairLink.h"   // for FairLink
#include "FairMultiLinkedData.h"

#include <Rtypes.h>    // for Int_t, Bool_t, kFALSE, etc
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString
#include <iostream>    // for operator<<, ostream, cout
#include <memory>      // for std::unique_ptr
#include <set>         // for set
#include <vector>      // for vector

class FairMultiLinkedData_Interface : public TObject
{
  public:
    FairMultiLinkedData_Interface() = default;   ///< Default constructor
    FairMultiLinkedData_Interface(FairMultiLinkedData& links, Bool_t persistanceCheck = kTRUE);   ///< Constructor
    FairMultiLinkedData_Interface(TString dataType,
                                  std::vector<Int_t> links,
                                  Int_t fileId = -1,
                                  Int_t evtId = -1,
                                  Bool_t persistanceCheck = kTRUE,
                                  Bool_t bypass = kFALSE,
                                  Float_t mult = 1.0);   ///< Constructor
    FairMultiLinkedData_Interface(Int_t dataType,
                                  std::vector<Int_t> links,
                                  Int_t fileId = -1,
                                  Int_t evtId = -1,
                                  Bool_t persistanceCheck = kTRUE,
                                  Bool_t bypass = kFALSE,
                                  Float_t mult = 1.0);   ///< Constructor
    FairMultiLinkedData_Interface(const FairMultiLinkedData_Interface& toCopy);

    ~FairMultiLinkedData_Interface() = default;

    FairMultiLinkedData_Interface& operator=(const FairMultiLinkedData_Interface& rhs);

    std::set<FairLink> GetLinks() const;                      ///< returns stored links as FairLinks
    Int_t GetNLinks() const;                                  ///< returns the number of stored links
    FairLink GetLink(Int_t pos) const;                        ///< returns the FairLink at the given position
    FairMultiLinkedData GetLinksWithType(Int_t type) const;   ///< returns all FairLinks with the corresponding type
    FairLink GetEntryNr() const;
    FairMultiLinkedData* GetPointerToLinks() const { return fLink.get(); }   ///< returns non-owning pointer

    std::vector<FairLink> GetSortedMCTracks();

    void SetLinks(FairMultiLinkedData links);   ///< Sets the links as vector of FairLink
    void SetLink(FairLink link);                ///< Sets the Links with a single FairLink
    void SetInsertHistory(Bool_t val);
    void SetEntryNr(FairLink val);
    ///< @param[in] links transfers ownership
    void SetPointerToLinks(FairMultiLinkedData* links) { fLink.reset(links); }
    void SetPointerToLinks(std::unique_ptr<FairMultiLinkedData> links) { fLink = std::move(links); }

    void AddLinks(FairMultiLinkedData links,
                  Float_t mult = 1.0);   ///< Adds a List of FairLinks (FairMultiLinkedData_Interface) to fLinks
    void AddLink(FairLink link);   ///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link is allowed
                                   ///< more than once otherwise
    void AddInterfaceData(FairMultiLinkedData_Interface* data);

    void ResetLinks();

    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const
    {
        if (GetPointerToLinks() != 0)
            GetPointerToLinks()->PrintLinkInfo(out);
        return out;
    }   ///< Output

    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData_Interface& data)
    {
        data.PrintLinkInfo(out);
        return out;
    }   ///< Output

  protected:
    std::unique_ptr<FairMultiLinkedData> fLink;
    FairMultiLinkedData* CreateFairMultiLinkedData();   ///< returns non-owning pointer

    ClassDef(FairMultiLinkedData_Interface, 6);
};

/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is
 * stored
 */

/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is
 * stored
 */

#endif /* FairMultiLinkedData_Interface_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * FairMultiLinkedData.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FAIRMULTILINKEDDATA_H_
#define FAIRMULTILINKEDDATA_H_

#include "FairLink.h"   // for FairLink

#include <Rtypes.h>    // for Int_t, Bool_t, kFALSE, etc
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString
#include <iosfwd>      // for ostream
#include <iostream>    // for operator<<, ostream, cout
#include <set>         // for set
#include <vector>      // for vector

class FairMultiLinkedData : public TObject
{
  public:
    FairMultiLinkedData();                                                                   ///< Default constructor
    FairMultiLinkedData(const std::set<FairLink>& links, Bool_t persistanceCheck = kTRUE);   ///< Constructor
    FairMultiLinkedData(TString dataType,
                        const std::vector<Int_t>& links,
                        Int_t fileId = -1,
                        Int_t evtId = -1,
                        Bool_t persistanceCheck = kTRUE,
                        Bool_t bypass = kFALSE,
                        Float_t mult = 1.0);   ///< Constructor
    FairMultiLinkedData(Int_t dataType,
                        const std::vector<Int_t>& links,
                        Int_t fileId = -1,
                        Int_t evtId = -1,
                        Bool_t persistanceCheck = kTRUE,
                        Bool_t bypass = kFALSE,
                        Float_t mult = 1.0);   ///< Constructor

    virtual ~FairMultiLinkedData(){};

    virtual std::set<FairLink> GetLinks() const { return fLinks; }   ///< returns stored links as FairLinks
    virtual FairLink GetEntryNr() const { return fEntryNr; }         ///< gives back the entryNr
    virtual Int_t GetNLinks() const { return fLinks.size(); }        ///< returns the number of stored links
    virtual FairLink GetLink(Int_t pos) const;                       ///< returns the FairLink at the given position
    virtual FairMultiLinkedData GetLinksWithType(
        Int_t type) const;   ///< Gives you a list of links which contain the given type
    virtual std::vector<FairLink>
        GetSortedMCTracks();   ///< Gives you a list of all FairLinks pointing to a "MCTrack" sorted by their weight
    TObject* GetData(FairLink& myLink);   ///< Get the TObject the Link is pointing to
    virtual Int_t GetDefaultType() { return fDefaultType; }
    Bool_t GetPersistanceCheck() { return fPersistanceCheck; }   ///< Returns the value of PersistanceCheck
    Int_t GetVerbose() { return fVerbose; }                      ///< Returns the verbosity level
    virtual void SetDefaultType(Int_t type) { fDefaultType = type; }
    virtual void SetPersistanceCheck(Bool_t check)
    {
        fPersistanceCheck = check;
    }   ///< Controls if a persistance check of a link is done or not
    virtual void SetVerbose(Int_t level) { fVerbose = level; }   ///< Sets the verbosity level
    virtual void SetInsertHistory(Bool_t val)
    {
        fInsertHistory = val;
    }   ///< Toggles if history of a link is inserted or not
    Bool_t GetInsertHistory() const { return fInsertHistory; }

    virtual void SetEntryNr(FairLink entry) { fEntryNr = entry; }
    virtual void SetLinks(FairMultiLinkedData links, Float_t mult = 1.0);   ///< Sets the links as vector of FairLink
    virtual void SetLink(FairLink link,
                         Bool_t bypass = kFALSE,
                         Float_t mult = 1.0);   ///< Sets the Links with a single FairLink

    virtual void AddLinks(FairMultiLinkedData links,
                          Float_t mult = 1.0);   ///< Adds a List of FairLinks (FairMultiLinkedData) to fLinks
    virtual void AddLink(FairLink link,
                         Bool_t bypass = kFALSE,
                         Float_t mult = 1.0);   ///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link
                                                ///< is allowed more than once otherwise it is stored only once

    virtual void InsertLink(FairLink link);   ///< Inserts a link into the list of links without persistance checking
    virtual void InsertHistory(
        FairLink link);   ///< Adds the FairLinks of the inserted link to the set of links of this object

    virtual void AddAllWeights(Double_t weight);        ///< Adds weight to all Links
    virtual void SetAllWeights(Double_t weight);        ///< Sets a common weight for Links
    virtual void MultiplyAllWeights(Double_t weight);   ///< Multiplies all Links with weight

    virtual Bool_t IsLinkInList(FairLink link)
    {
        return IsLinkInList(link.GetType(), link.GetIndex());
    }   ///< Test if a given link is in fLinks
    virtual Bool_t IsLinkInList(
        Int_t type,
        Int_t index);   ///< Same as IsLinkInList(FairLink) just with type and index given separately
    virtual Int_t LinkPosInList(FairLink link)
    {
        return LinkPosInList(link.GetType(), link.GetIndex());
    }   ///< returns position of link in fLinks. If it is not in the list -1 is returned
    virtual Int_t LinkPosInList(Int_t type, Int_t index);   ///< Same as LinkPosInList(FairLink)

    virtual void DeleteLink(FairLink link)
    {
        DeleteLink(link.GetType(), link.GetIndex());
    }                                                   ///< Deletes a link ouf of fLinks
    virtual void DeleteLink(Int_t type, Int_t index);   ///< Deletes a link ouf of fLinks

    virtual void Reset() { ResetLinks(); }
    virtual void ResetLinks() { fLinks.clear(); }   ///< Clears fLinks

    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const
    {
        out << GetEntryNr() << " -> [";
        for (Int_t i = 0; i < GetNLinks(); i++) {
            GetLink(i).PrintLinkInfo(out);
            out << " ";
        }
        out << "]";
        return out;
    }   ///< Output

    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData& data)
    {
        data.PrintLinkInfo(out);
        return out;
    }   ///< Output

  protected:
    std::set<FairLink> fLinks;
    FairLink fEntryNr;
    Bool_t fPersistanceCheck;   //!
    Bool_t fInsertHistory;      //!
    Int_t fVerbose;             //!

    virtual void SimpleAddLinks(Int_t fileId,
                                Int_t evtId,
                                Int_t dataType,
                                const std::vector<Int_t>& links,
                                Bool_t,
                                Float_t)
    {
        for (UInt_t i = 0; i < links.size(); i++) {
            fLinks.insert(FairLink(fileId, evtId, dataType, links[i]));
        }
    }
    Int_t fDefaultType;

    ClassDef(FairMultiLinkedData, 4);
};

/**\fn virtual void FairMultiLinkedData::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is
 * stored
 */

/**\fn virtual void FairMultiLinkedData::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is
 * stored
 */

#endif /* FAIRMULTILinkedData_H_ */
// -------------------------------------------------------------------------
// -----                 FairPrintFairLinks header file             -----
// -----                  Created 20/03/07  by R.Kliemt               -----
// -------------------------------------------------------------------------

/** FairPrintFairLinks.h
 *@author T.Stockmanns <t.stockmanns@fz-juelich.de>
 **
 ** Prints all FairLinks of a given branch to the screen
 **/

#ifndef FairPrintFairLinks_H
#define FairPrintFairLinks_H

// framework includes
#include "FairTask.h"
#include "TObjString.h"

#include <map>

class TClonesArray;

class FairPrintFairLinks : public FairTask
{
  public:
    /** Default constructor **/
    FairPrintFairLinks();

    /** Destructor **/
    virtual ~FairPrintFairLinks();

    virtual void AddBranchName(const TString& name) { fSelectedBranches->AddLast(new TObjString(name.Data())); }

    virtual void PrintBranchNameList(TList* branches);

    virtual InitStatus Init();

    /** Virtual method Exec **/
    virtual void Exec(Option_t* opt);

    virtual void Finish();

  protected:
    void InitBranchList(TList* branches);

  private:
    std::map<Int_t, TClonesArray*> fBranches;
    TList* fSelectedBranches;

    void Register();
    void Reset();
    void ProduceHits();

    ClassDef(FairPrintFairLinks, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenPoint header file               -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------

/**  FairRadLenPoint.h
 *@author M. Al-Turany
 *
 */

#ifndef FAIRRADLENPOINT_H
#define FAIRRADLENPOINT_H

#include "FairMCPoint.h"   // for FairMCPoint

#include <Rtypes.h>     // for Double_t, Float_t, etc
#include <TVector3.h>   // for TVector3

class FairRadLenPoint : public FairMCPoint
{
  public:
    /** Default constructor **/
    FairRadLenPoint();

    FairRadLenPoint(Int_t trackID,
                    Int_t detID,
                    TVector3 pos,
                    TVector3 mom,
                    Double_t tof,
                    Double_t length,
                    Double_t eLoss,
                    TVector3 posOut,
                    TVector3 momOut,
                    Float_t fA,
                    Float_t fZ,
                    Float_t fDensity,
                    Float_t fRadLen);

    /** Destructor **/
    virtual ~FairRadLenPoint();

    /** Accessors **/
    Float_t GetA() { return fA; }
    Float_t GetZm() { return fZmat; }
    Float_t GetRadLength() { return fRadLen; }
    Float_t GetDensity() { return fDensity; }

    /** Modifiers **/
    void SetA(Double_t A) { fA = A; }
    void SetZm(Double_t Z) { fZmat = Z; }
    void SetRadLength(Double_t length) { fRadLen = length; }
    void SetDensity(Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Double_t GetXOut() const { return fXOut; };
    Double_t GetYOut() const { return fYOut; };
    Double_t GetZOut() const { return fZOut; };

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ); }
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut); }

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut); };
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut, fPyOut, fPzOut); }

  protected:
    Float_t fA;         // A of material
    Float_t fZmat;      // Z of material
    Float_t fDensity;   // density of material
    Float_t fRadLen;    // radiation length

    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;

    ClassDef(FairRadLenPoint, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairRadMapPoint header file               -----
// -------------------------------------------------------------------------

/**  FairRadMapPoint.h
 *@author O.N. Hartmann
 *
 */

#ifndef FAIRRADMAPPOINT_H
#define FAIRRADMAPPOINT_H

#include "FairMCPoint.h"   // for FairMCPoint

#include <Rtypes.h>     // for Double_t, Float_t, Int_t, etc
#include <TVector3.h>   // for TVector3

class FairRadMapPoint : public FairMCPoint
{
  public:
    /** Default constructor **/
    FairRadMapPoint();

    FairRadMapPoint(Int_t trackID,
                    Int_t detID,
                    TVector3 pos,
                    TVector3 mom,
                    Double_t tof,
                    Double_t length,
                    Double_t eLoss,
                    TVector3 posOut,
                    TVector3 momOut,
                    Float_t fA,
                    Float_t fZ,
                    Float_t fDensity,
                    Double_t fVolMass,
                    Double_t fStep,
                    Double_t fDose,
                    Double_t fDoseSL,
                    Int_t fPdg);

    /** Destructor **/
    virtual ~FairRadMapPoint();

    /** Accessors **/
    Float_t GetA() { return fA; }
    Float_t GetZm() { return fZmat; }
    Float_t GetMass() { return fVolMass; }
    Float_t GetDensity() { return fDensity; }

    /** Modifiers **/
    void SetA(Double_t A) { fA = A; }
    void SetZm(Double_t Z) { fZmat = Z; }
    void SetMass(Double_t vmass) { fVolMass = vmass; }
    void SetDensity(Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Int_t GetPdg() const { return fPdg; };

    Double_t GetXOut() const { return fXOut; }
    Double_t GetYOut() const { return fYOut; }
    Double_t GetZOut() const { return fZOut; }

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    Double_t GetDose() const { return fDose; }
    Double_t GetDoseSL() const { return fDoseSL; }

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ); }
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut); }

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut); };
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut, fPyOut, fPzOut); }

  protected:
    // Int_t detID; // detector ID or volume ID
    Int_t fPdg;          // track PID
    Float_t fA;          // A of material
    Float_t fZmat;       // Z of material
    Float_t fDensity;    // density of material
    Double_t fVolMass;   // radiation length

    Double_t fStep, fDose, fDoseSL;
    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;

    ClassDef(FairRadMapPoint, 3);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----          FairRecoEventHeader header file                      -----
// -----          Created 20/09/13                 R.Karabowicz        -----
// -------------------------------------------------------------------------

#ifndef FAIRRECOEVENTHEADER_H
#define FAIRRECOEVENTHEADER_H

#include <TNamed.h>

/**
 *  Event Header Class
 **@author D.Bertini <d.bertini@gsi.de>
 **@author M.Al-Turany <m.al-turany@gsi.de>
 **@author R.Karabowicz <r.karabowicz@gsi.de>
 */
class FairRecoEventHeader : public TNamed
{
  public:
    /** Default constructor */
    FairRecoEventHeader();

    /** Get the run ID for this run*/
    UInt_t GetRunId() const { return fRunId; }

    /** Get the MC time for this event*/
    Double_t GetEventTime() const { return fEventTime; }

    /** Get the error of MC time for this event*/
    Double_t GetEventTimeError() const { return fEventTimeError; }

    /** Get identifier*/
    Int_t GetIdentifier() const { return fIdentifier; }

    /** Set the run ID for this run
     * @param runid : unique run id
     */
    void SetRunId(UInt_t runid) { fRunId = runid; }

    /** Set the MC time for this event
     * @param time : time in ns
     * @param terr : time error in ns
     */
    void SetEventTime(Double_t time, Double_t terr)
    {
        fEventTime = time;
        fEventTimeError = terr;
    }

    /** Set the run ID for this run
     * @param ident : identifier
     */
    void SetIdentifier(Int_t ident) { fIdentifier = ident; }

    virtual bool operator<(const FairRecoEventHeader& tempObj) const
    {
        if (fEventTime < tempObj.GetEventTime()) {
            return true;
        } else if (fEventTime > tempObj.GetEventTime()) {
            return false;
        }
        return false;
    }

    virtual bool operator>(const FairRecoEventHeader& tempObj) const
    {
        if (fEventTime > tempObj.GetEventTime()) {
            return true;
        } else if (fEventTime < tempObj.GetEventTime()) {
            return false;
        }
        return false;
    }

    virtual bool operator==(const FairRecoEventHeader& tempObj) const { return fEventTime == tempObj.GetEventTime(); }

    /**
     * Destructor
     */
    virtual ~FairRecoEventHeader();

  protected:
    /** Run Id */
    UInt_t fRunId;
    /** Identifier */
    Int_t fIdentifier;
    /** Event Time **/
    Double_t fEventTime;
    /** Event Time Error **/
    Double_t fEventTimeError;

    ClassDef(FairRecoEventHeader, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNINFO_H
#define FAIRRUNINFO_H

#include <Rtypes.h>       // for Double_t, Long_t, etc
#include <TObject.h>      // for TObject
#include <TSystem.h>      // for CpuInfo_t, MemInfo_t, etc
#include <TTimeStamp.h>   // for TTimeStamp
#include <vector>         // for vector

class TList;

class FairRunInfo : public TObject
{
  public:
    FairRunInfo();
    ~FairRunInfo();

    void StoreInfo();
    void WriteInfo();
    void Reset();

  private:
    TTimeStamp fTimeStamp;                 //!
    CpuInfo_t fCpuInfo;                    //!
    MemInfo_t fMemInfo;                    //!
    ProcInfo_t fProcInfo;                  //!
    std::vector<Double_t> fTimeDiff;       //!
    std::vector<Double_t> fTime;           //!
    std::vector<Long_t> fResidentMemory;   //!
    std::vector<Long_t> fVirtualMemory;    //!

    void CalculateTimeDifference();
    void PrintInfo();
    void GetInfo();
    void CreateAndFillHistograms(TList* histoList);
    void WriteHistosToFile(TList* histoList);

    FairRunInfo(const FairRunInfo&);
    FairRunInfo& operator=(const FairRunInfo&);

    ClassDef(FairRunInfo, 2);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRTIMESTAMP_H
#define FAIRTIMESTAMP_H

#include "FairMultiLinkedData_Interface.h"   // for FairMultiLinkedData

#include <Rtypes.h>   // for Double_t, etc
#include <iosfwd>     // for ostream
#include <iostream>   // for ostream, cout

class TObject;

/**
 * Base class for Time stamp information
 ** Aug. 2010
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairTimeStamp : public FairMultiLinkedData_Interface
{
  public:
    /** Default constructor **/
    FairTimeStamp();
    /** Constructor with time **/
    FairTimeStamp(Double_t time);
    /** Constructor with time and time error **/
    FairTimeStamp(Double_t time, Double_t timeerror);

    /** Destructor **/
    virtual ~FairTimeStamp(){};
    /** Accessors **/
    Double_t GetTimeStamp() const { return fTimeStamp; }
    Double_t GetTimeStampError() const { return fTimeStampError; }
    /** Modifiers **/
    void SetTimeStamp(Double_t t) { fTimeStamp = t; }
    void SetTimeStampError(Double_t t) { fTimeStampError = t; }
    virtual Int_t Compare(const TObject* obj) const
    {
        if (this == obj) {
            return 0;
        }
        FairTimeStamp* tsobj = static_cast<FairTimeStamp*>(const_cast<TObject*>(obj));
        Double_t ts = tsobj->GetTimeStamp();
        Double_t tserror = tsobj->GetTimeStampError();
        if (fTimeStamp < ts) {
            return -1;
        } else if (fTimeStamp == ts && fTimeStampError < tserror) {
            return -1;
        } else if (fTimeStamp == ts && fTimeStampError == tserror) {
            return 0;
        } else {
            return 1;
        }
    }

    virtual std::ostream& PrintTimeInfo(std::ostream& out = std::cout) const;
    virtual Bool_t IsSortable() const { return kTRUE; };

    virtual bool equal(FairTimeStamp* data)
    {
        return (fTimeStamp == data->GetTimeStamp() && fTimeStampError == data->GetTimeStampError());
    }

    friend std::ostream& operator<<(std::ostream& out, const FairTimeStamp& link)
    {
        link.PrintTimeInfo(out);
        return out;
    }

    virtual bool operator<(const FairTimeStamp* rValue) const { return GetTimeStamp() < rValue->GetTimeStamp(); }

  protected:
    Double_t fTimeStamp;      /** Time of digit or Hit  [ns] */
    Double_t fTimeStampError; /** Error on time stamp */

    ClassDef(FairTimeStamp, 4);
};

// -----   Default constructor   -------------------------------------------
inline FairTimeStamp::FairTimeStamp()
    : FairMultiLinkedData_Interface()
    , fTimeStamp(-1)
    , fTimeStampError(-1)
{}

// -----   Standard constructor   ------------------------------------------
inline FairTimeStamp::FairTimeStamp(Double_t time)
    : FairMultiLinkedData_Interface()
    , fTimeStamp(time)
    , fTimeStampError(-1)
{}

inline FairTimeStamp::FairTimeStamp(Double_t time, Double_t timeerror)
    : FairMultiLinkedData_Interface()
    , fTimeStamp(time)
    , fTimeStampError(timeerror)
{}

#endif   // FAIRTIMESTAMP_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairTrackParam header file                 -----
// -----                  Created 27/01/05  by V. Friese               -----
// -------------------------------------------------------------------------

/**  FairTrackParam.h
 *@author V.Friese <v.friese@gsi.de>
 **
 ** Parameters (x, y, tx, ty, q/p) of a track
 ** resulting from the track fit. The z coordinate is not a parameter.
 ** The 5x5 covariance matrix can be set and accessed by either an array
 ** of size 15, the TMatrixFSym class or elementwise. Note that TMatrixFSym
 ** should not be used when performance is an issue.
 ** The internal representation of the covariance matrix elements is
 ** an array of double.
 **/

#ifndef FAIRSTSTRACKPARAM
#define FAIRSTSTRACKPARAM 1

#include <Rtypes.h>           // for Double_t, Double32_t, Int_t, etc
#include <TMatrixFSymfwd.h>   // for TMatrixFSym
#include <TObject.h>          // for TObject
#include <TVector3.h>         // for TVector3

class FairTrackParam : public TObject
{
  public:
    /** Constructor **/
    FairTrackParam();

    /** Constructor with all variables **/
    FairTrackParam(Double_t x,
                   Double_t y,
                   Double_t z,
                   Double_t tx,
                   Double_t ty,
                   Double_t qp,
                   const TMatrixFSym& covMat);

    /** Copy constructor **/
    FairTrackParam(const FairTrackParam& param);

    /** Destructor **/
    virtual ~FairTrackParam();

    /** Output to screen **/
    void Print(Option_t* option = "") const;

    /** Accessors **/
    Double_t GetX() const { return fX; };
    Double_t GetY() const { return fY; };
    Double_t GetZ() const { return fZ; };
    Double_t GetTx() const { return fTx; };
    Double_t GetTy() const { return fTy; };
    Double_t GetQp() const { return fQp; };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); };
    void Momentum(TVector3& mom) const;
    void CovMatrix(Double_t cov[]) const;
    void CovMatrix(TMatrixFSym& covMat) const;
    Double_t GetCovariance(Int_t i, Int_t j) const;

    /** Modifiers **/
    void SetX(Double_t x) { fX = x; };
    void SetY(Double_t y) { fY = y; };
    void SetZ(Double_t z) { fZ = z; };
    void SetTx(Double_t tx) { fTx = tx; };
    void SetTy(Double_t ty) { fTy = ty; };
    void SetQp(Double_t qp) { fQp = qp; };
    void SetPosition(const TVector3& pos);
    void SetCovMatrix(Double_t cov[]);
    void SetCovMatrix(const TMatrixFSym& covMat);
    void SetCovariance(Int_t i, Int_t j, Double_t val);

    /** Assignment operator  **/
    FairTrackParam& operator=(const FairTrackParam& par);

  private:
    /** Position of track at given z [cm] **/
    Double32_t fX, fY, fZ;

    /** Direction of track tx = dx/dz; ty = dy/dz **/
    Double32_t fTx, fTy;

    /** Charge over momentum [1/GeV] **/
    Double32_t fQp;

    /** Covariance matrix for the variables x, y, tx, ty, q/p
     ** The 15 elements of the upper triangle of the symmetric matrix
     ** are stored in an array of floats. The sequence of the array is
     ** a[0,0..4], a[1,1..4], a[2,2..4], a[3,3..4], a[4,4].
     **/

    Double32_t fCovMatrix[15];

    ClassDef(FairTrackParam, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairField header file                     -----
// -----                Created 06/01/04  by M. Al-Turany              -----
// -----                Redesign 13/02/06  by V. Friese                -----
// -----                Redesign 04/08/06  by M. Al-Turany               -----
// -------------------------------------------------------------------------

/** FairField.h
 ** @author M.Al-Turany <m.al/turany@gsi.de>
 ** @author V.Friese <v.friese@gsi.de>
 ** @since 06.01.2004
 ** @version 1.0
 **
 ** Abstract base class for magnetic fields in FAIR
 ** Concrete field should implement the pure virtual methods
 ** GetBx, GetBy and GetBz and/or  GetBxyz
 **
 ** Note: Field values should be returned in kG (thanks to Geant3)
 **/

#ifndef FAIRFIELD_H
#define FAIRFIELD_H 1

#include "FairLogger.h"

#include <Rtypes.h>   // for Double_t, Bool_t, etc
#include <TVirtualMagField.h>

class FairField : public TVirtualMagField
{
  public:
    /** Default constructor **/
    FairField();

    /** Constructor with name and title **/
    FairField(const char* name, const char* title = "FAIR Magnetic Field");

    FairField& operator=(const FairField&) { return *this; }

    /** Destructor **/
    virtual ~FairField();

    /** Intialisation. E.g. read in the field map. If needed, to be
     ** implemented in the concrete class.
     **/
    virtual void Init(){};

    /** Test whether field type is Constant **/
    Bool_t IsConst();

    /** Test whether field typ is Map **/
    Bool_t IsMap();

    /** Field type ( 0=constant, 1=map, 2=map sym2, 3 = map sym3 ) **/
    Int_t GetType() const { return fType; }

    /** Get x component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBx([[maybe_unused]] Double_t x, [[maybe_unused]] Double_t y, [[maybe_unused]] Double_t z)
    {
        LOG(warn) << "FairField::GetBx Should be implemented in User class";
        return 0;
    }

    /** Get y component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBy([[maybe_unused]] Double_t x, [[maybe_unused]] Double_t y, [[maybe_unused]] Double_t z)
    {
        LOG(warn) << "FairField::GetBy Should be implemented in User class";
        return 0;
    }

    /** Get z component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBz([[maybe_unused]] Double_t x, [[maybe_unused]] Double_t y, [[maybe_unused]] Double_t z)
    {
        LOG(warn) << "FairField::GetBz Should be implemented in User class";
        return 0;
    }

    /** Get magnetic field. For use of Geant3
     ** @param point            Coordinates [cm]
     ** @param bField (return)  Field components [kG]
     **/
    virtual void GetFieldValue(const Double_t point[3], Double_t* bField);

    void Field(const Double_t point[3], Double_t* B) { GetFieldValue(point, B); }

    /** Screen output. To be implemented in the concrete class. **/
    virtual void Print(Option_t*) const { ; }
    virtual void GetBxyz(const Double_t[3], Double_t*)
    {
        LOG(warn) << "FairField::GetBxyz Should be implemented in User class";
    }

    /**Fill Paramater*/
    virtual void FillParContainer() { LOG(warn) << "FairField::FillParContainer Should be implemented in User class"; }

  protected:
    /** Field type. 1 = constant field, 2 = field map. **/
    Int_t fType;

  private:
    FairField(const FairField&);
    //    FairField& operator=(const FairField&);
    // TODO: Check why the htrack needs this

    ClassDef(FairField, 4);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairFieldFactory header file                  -----
// -----                Created 15/01/07  by M. Al-Turany              -----
// -------------------------------------------------------------------------

#ifndef FAIRFIELDFACTORY_H
#define FAIRFIELDFACTORY_H

#include <Rtypes.h>   // for FairFieldFactory::Class, etc

class FairField;

class FairFieldFactory
{
  public:
    static FairFieldFactory* Instance();
    FairFieldFactory();
    virtual ~FairFieldFactory();
    virtual FairField* createFairField() = 0;
    virtual void SetParm() {}

  protected:
    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] FairFieldFactory* fCreator;
    static FairFieldFactory* fgRinstance;

    ClassDef(FairFieldFactory, 1);

  private:
    FairFieldFactory(const FairFieldFactory& M);
    FairFieldFactory& operator=(const FairFieldFactory&) { return *this; }
};

#endif   // FAIRFIELDFACTORY_H
/********************************************************************************
 * Copyright (C) 2014-2023 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASECONTFACT_H
#define FAIRBASECONTFACT_H

#include "FairContFact.h"   // for FairContFact, etc

#include <Rtypes.h>   // for FairBaseContFact::Class, etc

class FairParSet;

class FairBaseContFact : public FairContFact
{
    /** Factory for all Base parameter containers */
  public:
    /**default ctor*/
    FairBaseContFact();
    /**default dtor*/
    ~FairBaseContFact() override {}
    /** Calls the constructor of the corresponding parameter container.
     * For an actual context, which is not an empty string and not the default context
     * of this container, the name is concatinated with the context. */
    FairParSet* createContainer(FairContainer*) override;
    ClassDefOverride(FairBaseContFact, 0);
};

#endif /* !FAIRBASECONTFACT_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASEPARSET_H
#define FAIRBASEPARSET_H

/**
 * Parameter class for run
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"   // for FairParGenericSet

#include <Rtypes.h>        // for Double_t, etc
#include <TGeoManager.h>   // IWYU pragma: keep needed by cint

class FairParamList;
class FairPrimaryGenerator;
class TObjArray;

class FairBaseParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
     * @param title:  Parameter set title
     * @param context:  Parameter set context
     */

    FairBaseParSet(const char* name = "FairBaseParSet",
                   const char* title = "Class for base parameter io",
                   const char* context = "BaseDefaultContext");
    /** dtor*/
    ~FairBaseParSet() override;
    /** clear*/
    void clear() override;
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
     */
    void putParams(FairParamList*) override;
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*) override;
    /**
     * Set the detector list used in the simulation
     * @param array: TObjArray of detector
     */
    void SetDetList(TObjArray* array) { fDetList = array; }
    /**
     * Set the Generator used in the simulation
     * @param gen: Primary generator used in simulation
     */
    void SetGen(FairPrimaryGenerator* gen) { fPriGen = gen; }
    /**
     * Set the beam momentum (if any) used in the simulation
     * @param BMom: Beam Momentum in GeV/c
     */
    void SetBeamMom(Double_t BMom) { fBeamMom = BMom; }
    /**
     * Set the list of parameter containers used in a run
     * @param array: TObjArray of containers
     */
    void SetContListStr(TObjArray* list) { fContNameList = list; }
    /**
     * Set the random seed used in a run
     * @param RndSeed: Random Seed
     */
    void SetRndSeed(UInt_t RndSeed) { fRandomSeed = RndSeed; }
    /**
     *  Get the detector list used in the simulation
     */
    TObjArray* GetDetList() { return fDetList; }
    /**
     *  Get the Primery generator used in the simulation
     */
    FairPrimaryGenerator* GetPriGen() { return fPriGen; }
    /**
     *  Get the Beam Momentum used in the simulation (GeV/c)
     */
    Double_t GetBeamMom() { return fBeamMom; }
    /**
     *  Get the parameter container list used in this run
     */
    TObjArray* GetContList() { return fContNameList; }
    /**
     *  Get the Random Seed used in this run
     */
    UInt_t GetRndSeed() { return fRandomSeed; }

  protected:
    /// Detectors used in the simulation
    TObjArray* fDetList;
    /// Generator used for simulation
    FairPrimaryGenerator* fPriGen;
    /// Beam momentum (GeV/c)
    Double_t fBeamMom;
    /// List of parameter container names in the RUN
    TObjArray* fContNameList;
    /// Random Seed from gRandom
    UInt_t fRandomSeed;

    ClassDefOverride(FairBaseParSet, 6);

  private:
    FairBaseParSet(const FairBaseParSet& L);
    FairBaseParSet& operator=(const FairBaseParSet&) { return *this; }
};

#endif /* !FAIRBASEPARSET_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETECTOR_H
#define FAIRDETECTOR_H

#include "FairModule.h"   // for FairModule

#include <Rtypes.h>   // for Int_t, Bool_t, etc

class FairLogger;
class FairVolume;
class TClonesArray;

/**
 * Base class for constructing detecors
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairDetector : public FairModule
{
  public:
    /**
      constructor
      Name :  Detector Name
      Active: kTRUE for active detectors  (ProcessHits() will be called)
              kFALSE for inactive detectors
    */
    FairDetector(const char* Name, Bool_t Active, Int_t DetId = 0);
    /**
      default constructor
    */
    FairDetector();
    /**
      destructor
    */
    virtual ~FairDetector();
    /**
      Initialization of the detector is done here
    */
    virtual void Initialize();
    /**
      this method is called for each step during simulation (see FairMCApplication::Stepping())
    */
    virtual Bool_t ProcessHits(FairVolume* v = 0) = 0;
    /**
      this is called at the end of an event after the call to tree fill in the FairRootManager
    */
    virtual void EndOfEvent() {}
    /**
      Registers the produced collections in FAIRRootManager.
    */
    virtual void Register() = 0;

    /**
     Gets the produced collections
    */
    virtual TClonesArray* GetCollection(Int_t iColl) const = 0;
    /**
      has to be called after each event to reset the containers
    */
    virtual void Reset() = 0;

    virtual void CopyClones(TClonesArray*, TClonesArray*, Int_t) {}
    /**
     User actions after finishing of a primary track
    */
    virtual void FinishPrimary() {}
    /**
     Finish MC Run
    */
    virtual void FinishRun() {}
    /**
     User actions at beginning of a primary track
    */
    virtual void BeginPrimary() {}
    /**
     User actions after finishing of each track
    */
    virtual void PostTrack() {}
    /**
     User actions at beginning of each track
    */
    virtual void PreTrack() {}
    /**
     User actions at beginning of event
    */
    virtual void BeginEvent() {}
    /**
     this is called at the end of an event before the call to tree fill in the FairRootManager
    */
    virtual void FinishEvent() {}

    void SaveGeoParams();
    Int_t GetDetId() { return fDetId; }

  protected:
    /** Copy constructor */
    FairDetector(const FairDetector&);
    /** Assignment operator */
    FairDetector& operator=(const FairDetector&);

    void DefineSensitiveVolumes();

    Int_t fDetId;          // Detector Id has to be set from ctr.
    FairLogger* fLogger;   //! /// FairLogger

    ClassDef(FairDetector, 1);
};
#endif   // FAIRDETECTOR_H
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairGeaneApplication header file                   -----
// -----            Created 10/11/10  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_GEANE_APPLICATION_H
#define FAIR_GEANE_APPLICATION_H

#include <Rtypes.h>                  // for Bool_t, etc
#include <TLorentzVector.h>          // for TLorentzVector
#include <TVirtualMCApplication.h>   // for TVirtualMCApplication

class FairField;

/**
 * The Main Application for GEANE
 * @author M. Al-Turany
 * @version 0.1
 * @since 10.11.10
 */

class FairGeaneApplication : public TVirtualMCApplication
{
  public:
    /** default constructor */
    FairGeaneApplication();
    /** Special constructor, used for initializing G3 for Geane track propagation
     *@param Debug    true to print step info*/
    FairGeaneApplication(Bool_t Debug);
    /** default destructor */
    ~FairGeaneApplication() override;
    /** Return Field used in simulation*/
    FairField* GetField() { return fxField; }
    /** Initialize MC engine */
    void InitMC(const char* setup, const char* cuts);
    /**
     * Set the magnetic field for simulation or Geane
     * @param field: magnetic field
     */
    void SetField(FairField* field);
    /** Define action at each step, dispatch the action to the corresponding detectors */
    void GeaneStepping() override;   // MC Application
    void ConstructGeometry() override;
    /**
     * Singelton instance
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] static FairGeaneApplication* Instance()
    {
        return static_cast<FairGeaneApplication*>(TVirtualMCApplication::Instance());
    }

    /**pure virtual functions that hasve to be implimented */

    void InitGeometry() override { ; }
    void GeneratePrimaries() override { ; }
    void BeginEvent() override { ; }
    void BeginPrimary() override { ; }
    void PreTrack() override { ; }
    void PostTrack() override { ; }
    void FinishPrimary() override { ; }
    void FinishEvent() override { ; }
    void Stepping() override { ; }
    void StopRun() { ; }

  private:
    // data members
    /**Magnetic Field Pointer*/
    FairField* fxField;   //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t fMcVersion;   // mc Version
    /** Debug flag*/
    Bool_t fDebug;            //!
    TLorentzVector fTrkPos;   //!

    // Interface to MonteCarlo application
    ClassDefOverride(FairGeaneApplication, 1);

  private:
    FairGeaneApplication(const FairGeaneApplication&);
    FairGeaneApplication& operator=(const FairGeaneApplication&);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairGenerator header file                   -----
// -----          Created 09/06/04  by D. Bertini / V. Friese          -----
// -------------------------------------------------------------------------

/** FairGenerator.h
 *@author D.Bertini <d.bertini@gsi.de>
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairGenerator is the abtract base class for the generators used to
generate input for the transport simulation.Each concrete generator class
derived from this one must implement the abtract method ReadEvent,
which has to use the method FairPrimaryGenerator::AddTrack.
**/

#ifndef FAIRGENERATOR_H
#define FAIRGENERATOR_H

#include <Rtypes.h>   // for Bool_t, etc
#include <TNamed.h>   // for TNamed

class FairPrimaryGenerator;

class FairGenerator : public TNamed
{
  public:
    /** Default constructor. **/
    FairGenerator();

    /** Constructor with name and title **/
    FairGenerator(const char* name, const char* title = "FAIR Generator");

    /** Destructor. **/
    virtual ~FairGenerator();

    /** Abstract method ReadEvent must be implemented by any derived class.
        It has to handle the generation of input tracks (reading from input
        file) and the handing of the tracks to the FairPrimaryGenerator. I
        t is called from FairMCApplication.
        *@param pStack The stack
        *@return kTRUE if successful, kFALSE if not
    **/
    virtual Bool_t ReadEvent(FairPrimaryGenerator* primGen) = 0;

    /**Initialize the generator if needed */
    virtual Bool_t Init() { return kTRUE; }

    /**Finalize the generator if needed */
    virtual void Finish() { return; }

    /** Clone this object (used in MT mode only) */
    virtual FairGenerator* CloneGenerator() const;

  protected:
    /** Copy constructor */
    FairGenerator(const FairGenerator&);
    /** Assignment operator */
    FairGenerator& operator=(const FairGenerator&);

    ClassDef(FairGenerator, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairGenericStack header file            -----
// -----           Created 10/08/04  by D. Bertini                     -----
// -------------------------------------------------------------------------

/** FairGenericStack.h
 *@author D.Bertini <d.bertini@gsi.de>
 * Generic MC stack class
 **/

#ifndef FAIRGENERICSTACK_H
#define FAIRGENERICSTACK_H

#include <Rtypes.h>   // for Double_t, Int_t, etc
#include <TClonesArray.h>
#include <TMCProcess.h>        // for TMCProcess
#include <TVirtualMCStack.h>   // for TVirtualMCStack
#include <map>
#include <tuple>

class FairLogger;
class TParticle;
class TRefArray;
class TIterator;

class FairGenericStack : public TVirtualMCStack
{
  public:
    /** Default constructor  **/
    FairGenericStack();

    /** Destructor with estimated array size  **/
    FairGenericStack(Int_t size);

    /** Destructor  **/
    virtual ~FairGenericStack();

    /** Virtual method PushTrack.
     ** Add a TParticle to the stack.
     ** This function has an extra argument wrt to the function defined in the base class.
     *@param toBeDone         Flag for tracking
     *@param parentID         Index of mother particle
     *@param pdgCode          Particle type (PDG encoding)
     *@param px,py,pz         Momentum components at start vertex [GeV]
     *@param e                Total energy at start vertex [GeV]
     *@param vx,vy,vz         Coordinates of start vertex [cm]
     *@param time             Start time of track [s]
     *@param polx,poly,polz   Polarisation vector
     *@param proc             Production mechanism (VMC encoding)
     *@param ntr              Track number (filled by the stack)
     *@param weight           Particle weight
     *@param is               Generation status code (whatever that means)
     *@param secondparentID   used fot the index of mother of primery in the list
     **/
    virtual void PushTrack(Int_t toBeDone,
                           Int_t parentID,
                           Int_t pdgCode,
                           Double_t px,
                           Double_t py,
                           Double_t pz,
                           Double_t e,
                           Double_t vx,
                           Double_t vy,
                           Double_t vz,
                           Double_t time,
                           Double_t polx,
                           Double_t poly,
                           Double_t polz,
                           TMCProcess proc,
                           Int_t& ntr,
                           Double_t weight,
                           Int_t is,
                           Int_t secondparentID) = 0;

    /** Fill the MCTrack output array, applying filter criteria **/
    virtual void FillTrackArray() {}

    /** Update the track index in the MCTracks and MCPoints **/
    virtual void UpdateTrackIndex(TRefArray* /* detArray=0 */) {}

    /** Set the list of detectors to be used for filltering the stack*/
    void SetDetArrayList(TRefArray* detArray);

    /** Allow a stack to perform a clean-up after a primary particle is finished **/
    virtual void FinishPrimary() {}

    /** Resets arrays and stack and deletes particles and tracks **/
    virtual void Reset() {}

    /** Register the MCTrack array to the Root Manager  **/
    virtual void Register() {}

    virtual TClonesArray* GetListOfParticles() { return 0; }
    virtual void SetParticleArray(__attribute__((unused)) TClonesArray* partArray) {}
    virtual void SetParticleArray(__attribute__((unused)) TClonesArray* partArray,
                                  __attribute__((unused)) Int_t partFrom,
                                  __attribute__((unused)) Int_t partTo)
    {}

    /** Clone this object (used in MT mode only) */
    virtual FairGenericStack* CloneStack() const;

    /** Fast simulation function to move particle to different position.
        In Geant3 it stops the current trajectory, and starts it again in the position given by the user.
        In Geant4 the FastSimulationModel with take over.
        Later, the points are reindexed and the thus created tracks are not stored in the output.
     *@param xx,yy,zz    new position    of the particle
     *@param tt          new proper time of the particle
     *@param px,py,pz    new momentum    of the particle
     *@param en          new energy      of the particle
     **/
    virtual void FastSimMoveParticleTo(Double_t xx,
                                       Double_t yy,
                                       Double_t zz,
                                       Double_t tt,
                                       Double_t px,
                                       Double_t py,
                                       Double_t pz,
                                       Double_t en);
    /** Fast simulation function to stop original particle. **/
    virtual void FastSimStopParticle();
    /** Fast simulation function to generate secondaries.
     *@param xx,yy,zz    position    of the particle
     *@param tt          proper time of the particle
     *@param px,py,pz    momentum    of the particle
     *@param en          energy      of the particle
     **/
    virtual void FastSimPushSecondary(Int_t parentID,
                                      Int_t pdgCode,
                                      Double_t xx,
                                      Double_t yy,
                                      Double_t zz,
                                      Double_t tt,
                                      Double_t px,
                                      Double_t py,
                                      Double_t pz,
                                      Double_t en,
                                      Double_t polx,
                                      Double_t poly,
                                      Double_t polz,
                                      TMCProcess proc,
                                      Double_t weight,
                                      Int_t is);
    /** Allow FairFastSim the retrieval of moved particle position, p1 and p2 to get secondaries **/
    virtual std::tuple<Int_t, Int_t, Int_t> FastSimGetMovedIndex()
    {
        return std::make_tuple(fFSMovedIndex, fFSFirstSecondary, fFSNofSecondaries);
    }
    virtual void FastSimClearMovedIndex()
    {
        fFSMovedIndex = -2;
        fFSFirstSecondary = -2;
        fFSNofSecondaries = 0;
    }

    template<typename T>
    void FastSimUpdateTrackIndex(T* point, Int_t& iTrack);

  protected:
    /** Copy constructor */
    FairGenericStack(const FairGenericStack&);
    /** Assignment operator */
    FairGenericStack& operator=(const FairGenericStack&);

    /** Fair Logger */
    FairLogger* fLogger;   //!

    /** List of detectors registering hits in the simulation */
    TRefArray* fDetList;   //!

    /** Iterator for the detector list*/
    TIterator* fDetIter;

    /**Verbosity level*/
    Int_t fVerbose;

    /** FastSimulation: STL map from new track index to original track index  **/
    std::map<Int_t, Int_t> fFSTrackMap;              //!
    std::map<Int_t, Int_t>::iterator fFSTrackIter;   //!
    Int_t fFSMovedIndex;                             //!
    Int_t fFSFirstSecondary;                         //!
    Int_t fFSNofSecondaries;                         //!

    ClassDef(FairGenericStack, 1);
};

template<typename T>
void FairGenericStack::FastSimUpdateTrackIndex(T* point, Int_t& iTrack)
{
    fFSTrackIter = fFSTrackMap.find(iTrack);   // check if point created by FastSimulation
    if (fFSTrackIter != fFSTrackMap.end()) {   // indeed the point has been created by the FastSimulation mechanism
        iTrack = fFSTrackIter->second;
        point->SetTrackID(iTrack);   // set proper TrackID
    }
}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairGenericVMCConfig header file                -----
// -----            Created 2019.02.19 by R. Karabowicz                -----
// -------------------------------------------------------------------------

#include <string>   // for string

#ifndef FAIR_GENERIC_VMC_CONFIG_H
#define FAIR_GENERIC_VMC_CONFIG_H

class FairGenericVMCConfig
{
  public:
    FairGenericVMCConfig();
    virtual ~FairGenericVMCConfig();

    virtual void Setup(const char* mcEngine);
    virtual void SetupPostInit(const char* mcEngine);

    virtual void UsePostInitConfig(bool useC = true, const char* stringC = "g4ConfigPostInit.C")
    {
        fPostInitFlag = useC;
        fPostInitName = stringC;
    }

  protected:
    bool fPostInitFlag;
    std::string fPostInitName;
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairGeoParSet_H
#define FairGeoParSet_H

/**
 * Parameter class for Geometry stuff
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"   // for FairParGenericSet

#include <Rtypes.h>        // for Double_t, etc
#include <TGeoManager.h>   // IWYU pragma: keep needed by cint

class FairParamList;
class TObjArray;

class FairGeoParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
     * @param title:  Parameter set title
     * @param context:  Parameter set context
     */

    FairGeoParSet(const char* name = "FairGeoParSet",
                  const char* title = "Class for base parameter io",
                  const char* context = "BaseDefaultContext");
    /** dtor*/
    ~FairGeoParSet() override;
    /** clear*/
    void clear() override;
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
     */
    void putParams(FairParamList*) override;
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*) override;
    /**
     * Set the Geometry node list used in the simulation
     * @param array: TObjArray of Geometry nodes
     */
    void SetGeoNodes(TObjArray* array) { fGeoNodes = array; }
    /**
     * Set the Geometry (TGeoManager) used in the simulation
     * @param Geom: TGeoManager of the full geometry
     */
    void SetGeometry(TGeoManager* Geom) { fGeom = Geom; }
    /**
     *  Get the Geometry Nodes list used in the simulation
     */
    TObjArray* GetGeoNodes() { return fGeoNodes; }
    /**
     *  Get the geometry (TGeoManager) used in the simulation
     */
    TGeoManager* GetGeometry() { return fGeom; }

  protected:
    /// List of FairGeoNodes for sensitive volumes
    TObjArray* fGeoNodes;   //!
    /// Full Geometry
    TGeoManager* fGeom;
    ClassDefOverride(FairGeoParSet, 1);

  private:
    FairGeoParSet(const FairGeoParSet& L);
    FairGeoParSet& operator=(const FairGeoParSet&) { return *this; }
};

#endif /* !FairGeoParSet_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairIon header file                      -----
// -----          Created 27/08/04  by V. Friese / D.Bertini           -----
// -------------------------------------------------------------------------

/** FairIon.h
 *@author V.Friese <v.friese@gsi.de>
 *@author D.Bertini <d.bertini@gsi.de>
 **
 ** A class for the user definition of an ion. It will be instantiated
 ** from the constructor of the FairIonGenerator.
 **/

#ifndef FAIRION_H
#define FAIRION_H

#include <Rtypes.h>   // for Int_t, Double_t, etc
#include <TNamed.h>   // for TNamed

class FairLogger;

class FairIon : public TNamed
{
  public:
    /** Default constructor **/
    FairIon();

    /** Standard constructor
     *@param name  name
     *@param z     atomic number
     *@param a     atomic mass
     *@param q     electric charge
     *@param e     excitation energy
     *@param m     mass [GeV]
     ** If mass is not given, it will be set to a times the proton mass.
     **/

    FairIon(const char* name, Int_t z, Int_t a, Int_t q, Double_t e = 0., Double_t m = 0.);
    void SetParams(const char* name, Int_t z, Int_t a, Int_t q, Double_t e = 0., Double_t m = 0.)
    {
        SetName(name);
        fZ = z;
        fA = a;
        fQ = q;
        fExcEnergy = e;
        fMass = m;
    }
    /** Destructor **/
    virtual ~FairIon();

    /** Accessors **/
    /**
     * Return the atomic number
     */
    Int_t GetZ() const { return fZ; }
    /**
     * Return the atomic mass
     */
    Int_t GetA() const { return fA; }
    /**
     * Return the charge
     */
    Int_t GetQ() const { return fQ; }
    /**
     * Return the  excitation energy
     */
    Double_t GetExcEnergy() const { return fExcEnergy; }
    /**
     * Return the mass in GeV
     */
    Double_t GetMass() const { return fMass; }

    /** Modifiers **/
    /**
     * Set the  excitation energy
     */
    void SetExcEnergy(Double_t eExc) { fExcEnergy = eExc; }
    /**
     * Set the atomic mass, use SetMass to set the mass of the ion
     */
    void SetA(Int_t a) { fA = a; }
    /**
     * Set the mass in GeV
     */
    void SetMass(Double_t mass) { fMass = mass; }

  private:
    static Int_t fgNIon;         //! /// Number of ions instantiated. One per generator.
    Int_t fZ;                    /// Atomic number
    Int_t fA;                    /// Atomic mass
    Int_t fQ;                    /// Electric charge
    Double_t fExcEnergy;         /// Excitation energy [GeV]
    Double_t fMass;              /// Mass [GeV]
    FairLogger* fLogger;         //! /// FairLogger

    FairIon(const FairIon&);
    FairIon& operator=(const FairIon&);

    ClassDef(FairIon, 2);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairMCApplication header file                   -----
// -----            Created 06/01/04  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_MC_APPLICATION_H
#define FAIR_MC_APPLICATION_H

#include "FairRadGridManager.h"
#include "FairRunInfo.h"   // for FairRunInfo

#include <Rtypes.h>                  // for Int_t, Bool_t, Double_t, etc
#include <TLorentzVector.h>          // for TLorentzVector
#include <TString.h>                 // for TString
#include <TVirtualMCApplication.h>   // for TVirtualMCApplication
#include <list>                      // for list
#include <map>                       // for map, multimap, etc
#include <memory>                    // for std::unique_ptr

class FairDetector;
class FairEventHeader;
class FairField;
class FairGenericStack;
class FairMCEventHeader;
class FairPrimaryGenerator;
class FairRadLenManager;
class FairRadMapManager;
class FairRootManager;
class FairTask;
class FairTrajFilter;
class FairVolume;
class FairRunSim;
class TChain;
class TIterator;
class TObjArray;
class TRefArray;
class TTask;
class TVirtualMC;

enum class FairMCApplicationState { kUnknownState, kConstructGeometry, kInitGeometry };

/**
 * The Main Application ( Interface to MonteCarlo application )
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairMCApplication : public TVirtualMCApplication
{
  public:
    /** Standard constructor
     *@param name      name
     *@param title     title
     *@param ModList  a TObjArray containing all detectors and modules used in this simulation
     *@param MatName  material file name
     */
    FairMCApplication(const char* name, const char* title, TObjArray* ModList, const char* MatName);
    /** default constructor
     */
    FairMCApplication();

    FairMCApplication(const FairMCApplication&) = delete;
    FairMCApplication& operator=(const FairMCApplication&) = delete;
    FairMCApplication(FairMCApplication&&) = delete;
    FairMCApplication& operator=(FairMCApplication&&) = delete;

    /** default destructor
     */
    ~FairMCApplication() override;
    /** Singelton instance
     */
    static FairMCApplication* Instance();
    virtual void AddDecayModes();
    /**  Add user defined particles (optional) */
    void AddParticles() override;   // MC Application
    /** Add user defined ions (optional)
        Called by TVirtualMC.
        TGeant3 calls AddIons() first, then InitGeometry().
        TGeant4 calls InitGeometry() first, then AddIons().
        This function also initializes event generators.*/
    void AddIons() override;   // MC Application
    /**
     *Add user defined Tasks to be executed after each event (optional)
     * @param fTask: Task that has to be excuted during simulation
     */
    void AddTask(TTask* fTask);
    /** Define actions at the beginning of the event */
    void BeginEvent() override;   // MC Application
    /** Define actions at the beginning of primary track */
    void BeginPrimary() override;   // MC Application
    /** Construct user geometry */
    void ConstructGeometry() override;   // MC Application
    /** Align or misalign geometry before actual run       */
    Bool_t MisalignGeometry() override;
    /** Define parameters for optical processes (optional) */
    void ConstructOpGeometry() override;   // MC Application
    /** Define actions at the end of event */
    void FinishEvent() override;   // MC Application
    /** Define actions at the end of primary track */
    void FinishPrimary() override;   // MC Application
    /** Define actions at the end of run */
    void FinishRun();
    /** Generate primary particles */
    void GeneratePrimaries() override;   // MC Application
    /** Return detector by name  */
    FairDetector* GetDetector(const char* DetName);
    /** Return Field used in simulation*/
    FairField* GetField() { return fxField; }
    /**Return primary generator*/
    FairPrimaryGenerator* GetGenerator();
    /**Return list of tasks*/
    TTask* GetListOfTasks();
    FairGenericStack* GetStack();
    TChain* GetChain();
    /** Initialize geometry
        Called by TVirtualMC.
        TGeant3 calls AddIons() first, then InitGeometry().
        TGeant4 calls InitGeometry() first, then AddIons().
        This function also registers detectors.*/
    void InitGeometry() override;   // MC Application
    /** Initialize MC engine */
    void InitMC(const char* setup, const char* cuts);
    /** Initialize Tasks if any*/
    void InitTasks();
    /**Define actions at the end of each track */
    void PostTrack() override;   // MC Application
    /** Define actions at the beginning of each track*/
    void PreTrack() override;   // MC Application

    /** Clone for worker (used in MT mode only) */
    TVirtualMCApplication* CloneForWorker() const override;

    /** Init application on worker (used in MT mode only) */
    void InitOnWorker() override;

    /** Finish run on worker (used in MT mode only) */
    void FinishRunOnWorker() override;

    /** Run the MC engine
     * @param nofEvents : number of events to simulate
     */
    void RunMC(Int_t nofEvents);
    /**
     * Set the magnetic field for simulation
     * @param field: magnetic field
     */
    void SetField(FairField* field);
    /**
     * Set the event generator  for simulation
     * @param fxGenerator: Event generator(s)
     */
    void SetGenerator(FairPrimaryGenerator* fxGenerator);
    /**
     * Set the parameter containers needed by Tasks(if any)
     */
    void SetParTask();
    /**
     * Switch for using Pythia as external decayer
     * @param decayer: if TRUE pythia will decay particles specifid in the Decay Config macro (see
     * SetPythiaDecayerConfig)
     */
    void SetPythiaDecayer(Bool_t decayer) { fPythiaDecayer = decayer; }
    /**
     * set the decay configuration macro to be used by Pythia
     */
    void SetPythiaDecayerConfig(const TString decayerConf) { fPythiaDecayerConfig = decayerConf; }
    /**
     * Switch for using the radiation length manager
     */
    void SetRadiationLengthReg(Bool_t RadLen);
    /**
     * Switch for using the radiation map manager
     */
    void SetRadiationMapReg(Bool_t RadMap);
    /**
     * Switch for debuging the tracking
     */
    void SetTrackingDebugMode(Bool_t set) { fDebug = set; }
    /**
     * Switch for using 2 or 3 body phase-space decay
     * @param  decay: if TRUE 2/3 body phase space decay will be used for particle specified in the User Decay Config
     * macro (see SetUserDecayConfig)
     */
    void SetUserDecay(Bool_t decay) { fUserDecay = decay; }
    /**
     * set the decay configuration macro to be used by user decay
     */
    void SetUserDecayConfig(const TString decayerConf) { fUserDecayConfig = decayerConf; }
    /** Define action at each step, dispatch the action to the corresponding detectors */
    void Stepping() override;   // MC Application
    /** Stop the run*/
    virtual void StopRun();
    /** Stop the run*/
    virtual void StopMCRun();
    /**Define maximum radius for tracking (optional) */
    Double_t TrackingRmax() const override;   // MC Application
    /** Define maximum z for tracking (optional) */
    Double_t TrackingZmax() const override;   // MC Application

    void AddMeshList(TObjArray* meshList);

    /**
     * Set if the current event should be written to the output file.
     * The default value which is set back after each event is to store
     * the event.
     */
    void SetSaveCurrentEvent(Bool_t set) { fSaveCurrentEvent = set; }

    /**
     * Get the current application state.
     */
    FairMCApplicationState GetState() const { return fState; }

    /**
     * Return non-owning pointer to FairRadGridManager
     */
    auto GetRadGridMan() { return fRadGridMan.get(); }

  private:
    // methods
    Int_t GetIonPdg(Int_t z, Int_t a) const;

    void UndoGeometryModifications();

  protected:
    // data members
    /**
     * \brief Main instance
     *
     * Only set for instances created by \ref CloneForWorker
     * and points to the instance from which the clone was
     * created
     */
    const FairMCApplication* fParent{nullptr};   //!
    /**List of active detector */
    TRefArray* fActiveDetectors;
    /**List of FairTask*/
    FairTask* fFairTaskList;   //!
    /**detector list (Passive and Active)*/
    TRefArray* fDetectors;
    /**Iterator for Module list*/
    TIterator* fModIter;   //!
    /**Module list in simulation*/
    TObjArray* fModules;
    /**Number of sensetive volumes in simulation session*/
    Int_t fNoSenVolumes;   //!
    /**flag for using Pythia as external decayer */
    Bool_t fPythiaDecayer;
    /** Pythia decay config macro*/
    TString fPythiaDecayerConfig;   //!
    /** Simulation Stack  */
    FairGenericStack* fStack;   //!
    /**Pointer to thr I/O Manager */
    FairRootManager* fRootManager;   //!
    /**List of sensetive volumes in all detectors*/
    TRefArray* fSenVolumes;   //!
    /**Magnetic Field Pointer*/
    FairField* fxField;   //
    /**Primary generator*/
    FairPrimaryGenerator* fEvGen;   //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t fMcVersion;   // mc Version
    /** Track visualization manager */
    FairTrajFilter* fTrajFilter;   //!
    /**Flag for accepted tracks for visualization*/
    Bool_t fTrajAccepted;   //!
    /**Flag for using user decay*/
    Bool_t fUserDecay;
    /**User decay config macro*/
    TString fUserDecayConfig;   //!
    /** Debug flag*/
    Bool_t fDebug;   //!
    /**dispatcher internal use */
    std::multimap<Int_t, FairVolume*> fVolMap;   //!
    /** Track position*/
    /**dispatcher internal use RadLeng*/
    std::map<Int_t, Int_t> fModVolMap;   //!
    TLorentzVector fTrkPos;              //!
    /** Flag for Radiation length register mode  */
    Bool_t fRadLength;   //!

    /**Radiation length Manager*/
    FairRadLenManager* fRadLenMan;   //!
    /** Flag for Radiation map register mode  */
    Bool_t fRadMap;   //!
    /**Radiation Map Manager*/
    FairRadMapManager* fRadMapMan;   //!
    /**Radiation map Grid Manager*/
    std::unique_ptr<FairRadGridManager> fRadGridMan{};   //!

    FairEventHeader* fEventHeader;   //!

    FairMCEventHeader* fMCEventHeader;   //!
    /** list of senstive detectors used in the simuation session*/
    std::list<FairDetector*> listActiveDetectors;   //!
    /** list of all detectors used in the simuation session*/
    std::list<FairDetector*> listDetectors;   //!
    /** Pointer to the current MC engine //!
     */
    TVirtualMC* fMC;

    FairRunSim* fRun{nullptr};   //!

    /** Flag if the current event should be saved */
    Bool_t fSaveCurrentEvent;

    /** Current state */
    FairMCApplicationState fState;   //!

    ClassDefOverride(FairMCApplication, 5);

  private:
    /** Private special copy constructor, needed for CloneForWorker */
    FairMCApplication(const FairMCApplication&, std::unique_ptr<FairRunSim>);

    FairRunInfo fRunInfo;   //!
    Bool_t fGeometryIsInitialized;

    /**
     * Clean up the FairRunSim created in CloneForWorker
     */
    std::unique_ptr<FairRunSim> fWorkerRunSim;   //!
};

// inline functions

inline FairMCApplication* FairMCApplication::Instance()
{
    return static_cast<FairMCApplication*>(TVirtualMCApplication::Instance());
}

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRMODULE_H
#define FAIRMODULE_H

#include "FairGeoInterface.h"   // for FairGeoInterface
#include "FairGeoLoader.h"      // for FairGeoLoader
#include "FairGeoNode.h"        // for FairGeoNode
#include "FairGeoVolume.h"      // for FairGeoVolume
#include "FairLogger.h"
#include "FairRun.h"         // for FairRun
#include "FairRuntimeDb.h"   // for FairRuntimeDb

#include <Rtypes.h>      // for Bool_t, Int_t, etc
#include <TList.h>       // for TList (ptr only), TListIter
#include <TNamed.h>      // for TNamed
#include <TObjArray.h>   // for TObjArray
#include <TString.h>     // for TString, operator!=
#include <string>        // for string

class FairVolumeList;
class FairVolume;
class TArrayI;
class TGeoMatrix;
class TGeoNode;
class TGeoVolume;
class TRefArray;
class TVirtualMC;

/**
 * Base class for constructing all detecors and passive volumes
 * @author M. Al-Turany, Denis Bertini
 * @version 1.0
 * @since 01.04.08 M.Al-Turany
 * Add methods to construct geometry via ROOT files
 * Add some documentation
 *
 * Changelog: 29.02.2012 [O.Merle] Fixed missing material assignment for top volume.
 *                                 ... and please - add some documentation to your code.
 */
class FairModule : public TNamed
{
  public:
    /**default ctor*/
    FairModule();
    /**Standard ctor*/
    FairModule(const char* Name, const char* title, Bool_t Active = kFALSE);
    /**default dtor*/
    ~FairModule() override;
    /**Print method should be implemented in detector or module*/
    void Print(Option_t*) const override { ; }
    /**Set the geometry file name o be used*/
    virtual void SetGeometryFileName(TString fname, TString geoVer = "0");
    /**Get the Geometry file name*/
    virtual TString GetGeometryFileName() { return fgeoName; }
    /**Get the geometry file version if used*/
    virtual TString GetGeometryFileVer() { return fgeoVer; }
    /**method called from the MC application to construct the geometry, has to be implimented by user*/
    virtual void ConstructGeometry();
    /**method called from the MC application to set optical geometry properties*/
    virtual void ConstructOpGeometry();
    /**construct geometry from root files (TGeo)*/
    virtual void ConstructRootGeometry(TGeoMatrix* shiftM = nullptr);
    /**construct geometry from standard ASSCII files (Hades Format)*/
    virtual void ConstructASCIIGeometry();
    /**
     * Modify the geometry for the simulation run using methods of the Root geometry package
     * \deprecated Deprecated pre-v18.8, will be removed in v20.
     */
    [[deprecated("Use FairAlignmentHandler instead, see Tutorial4 for examples")]] virtual void ModifyGeometry()
    {
        LOG(warn) << "This function is deprecated. Use FairAlignmentHandler instead, see Tutorial4 for examples.";
    }
    virtual void RegisterAlignmentMatrices() { ; }

    /**construct geometry from GDML files*/
    virtual void ConstructGDMLGeometry(__attribute__((unused)) TGeoMatrix* posrot);
    /** custom settings of processes and cuts for media to be forwarded to the
     ** detector simulation */
    virtual void SetSpecialPhysicsCuts() { ; }
    /** Clone this object (used in MT mode only)*/
    virtual FairModule* CloneModule() const;
    /** Init worker run (used in MT mode only) */
    virtual void BeginWorkerRun() const { ; }
    /** Finish worker run (used in MT mode only) */
    virtual void FinishWorkerRun() const { ; }

    /** @deprecated template function to construct geometry. to be used in derived classes.
     * The first and the third argument are meaningless, just pass nullptr */
    template<class T, class U>
    [[deprecated("Broken signature, use ConstructASCIIGeometry(TString) instead")]] void
        ConstructASCIIGeometry(T*, TString containerName = "", U* = nullptr);
    /** Helper function to construct geometry. */
    template<class T, class U>
    void ConstructASCIIGeometry(TString containerName = "");

    /**Set the sensitivity flag for volumes, called from ConstructASCIIRootGeometry(), and has to be implimented for
     * detectors which use ConstructASCIIRootGeometry() to build the geometry */
    virtual Bool_t IsSensitive(const std::string& name);
    /**The function below is depracated, please change to the new method above */
    virtual Bool_t CheckIfSensitive(__attribute__((unused)) std::string name) __attribute__((
        deprecated("The method CheckIfSensitive is deprecated. Implement IsSensitive in the detector classes.")))
    {
        return kFALSE;
    }
    /**called from ConstructRootGeometry()*/
    virtual void ExpandNode(TGeoNode* Node);
    /**called from ConstructGDMLGeometry()*/
    virtual void ExpandNodeForGDML(__attribute__((unused)) TGeoNode* curNode);
    /**return the MC id of a volume named vname*/
    virtual Int_t getVolId(const TString&) const { return 0; }
    /**return the detector/Module id (which was set in the sim macro for the detector)*/
    Int_t GetModId() { return fModId; }
    /**Set the verbose level in this detector*/
    void SetVerboseLevel(Int_t level) { fVerboseLevel = level; }
    /**return the detector status */
    Bool_t IsActive() { return fActive; }
    /**set the detector/module id*/
    void SetModId(Int_t id) { fModId = id; }
    /** Set the name of the mother volume to which a new geometry is added.
     ** This function is needed for geometries which are defined as ROOT geometry manager.
     **/
    void SetMotherVolume(TString volName) { fMotherVolumeName = volName; }
    /**called from ConstuctASCIIGeometry*/
    void ProcessNodes(TList* aList);
    /**Set the parameter containers*/
    virtual void SetParContainers() { ; }
    /** Initialize everything which has to be done before the construction and modification
     ** of the geometry. Mostly this is needed to read data from the parameter containers.*/
    virtual void InitParContainers() { ; }
    /**return the geo parameter of this detector/module*/
    TList* GetListOfGeoPar() { return flGeoPar; }

    /**list of volumes in a simulation session*/
    static thread_local FairVolumeList* vList;   //!
    /**total number of volumes in a simulaion session*/
    static thread_local Int_t fNbOfVolumes;   //!
    /**list of all sensitive volumes in  a simulaion session*/
    static thread_local TRefArray* svList;   //!

    static thread_local TArrayI* volNumber;   //!
    TString fMotherVolumeName;                //!
    FairVolume* getFairVolume(FairGeoNode* fNode);
    void AddSensitiveVolume(TGeoVolume* v);

  private:
    /** Re-implimented from ROOT:  TGeoMatrix::SetDefaultName()  */
    void SetDefaultMatrixName(TGeoMatrix* matrix);
    void AssignMediumAtImport(TGeoVolume* v);   // O.Merle, 29.02.2012 - see impl.

    /**called from ConstructGDMLGeometry. Changes default ID created by TGDMLParse*/
    void ReAssignMediaId();
    void swap(FairModule& other) throw();

  protected:
    FairModule(const FairModule&);
    FairModule& operator=(const FairModule&);
    TString fgeoVer;
    TString fgeoName;
    Int_t fModId;
    Bool_t fActive;
    Int_t fNbOfSensitiveVol;   //!
    Int_t fVerboseLevel;
    TList* flGeoPar;    //!  list of Detector Geometry parameters
    Bool_t fGeoSaved;   //! flag for initialisation
    TVirtualMC* fMC;    //! cahed pointer to MC (available only after initialization)

    ClassDefOverride(FairModule, 4);
};

template<class T, class U>
void FairModule::ConstructASCIIGeometry(TString containerName)
{
    FairGeoLoader* loader = FairGeoLoader::Instance();
    FairGeoInterface* GeoInterface = loader->getGeoInterface();
    T* MGeo = new T();
    MGeo->print();
    MGeo->setGeomFile(GetGeometryFileName());
    GeoInterface->addGeoModule(MGeo);   // takes ownership!
    Bool_t rc = GeoInterface->readSet(MGeo);
    if (rc) {
        MGeo->create(loader->getGeoBuilder());
    }

    TList* volList = MGeo->getListOfVolumes();
    // store geo parameter
    FairRun* fRun = FairRun::Instance();
    FairRuntimeDb* rtdb = FairRun::Instance()->GetRuntimeDb();

    if ("" != containerName) {
        LOG(info) << "Add GeoNodes for " << MGeo->getDescription() << " to container " << containerName;

        //    U par=(U)(rtdb->getContainer(containerName));
        U* par = static_cast<U*>(rtdb->getContainer(containerName));
        TObjArray* fSensNodes = par->GetGeoSensitiveNodes();
        TObjArray* fPassNodes = par->GetGeoPassiveNodes();

        TListIter iter(volList);
        FairGeoNode* node = nullptr;
        FairGeoVolume* aVol = nullptr;

        while ((node = static_cast<FairGeoNode*>(iter.Next()))) {
            aVol = dynamic_cast<FairGeoVolume*>(node);
            if (node->isSensitive()) {
                fSensNodes->AddLast(aVol);
            } else {
                fPassNodes->AddLast(aVol);
            }
        }
        ProcessNodes(volList);
        par->setChanged();
        par->setInputVersion(fRun->GetRunId(), 1);
    }
}

template<class T, class U>
void FairModule::ConstructASCIIGeometry(T*, TString containerName, U*)
{
    ConstructASCIIGeometry<T, U>(containerName);
}

#endif   // FAIRMODULE_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/// Class FAIRParticle
/// ------------------
/// Extended TParticle with persistent pointers to mother and daughters
/// particles  (Ivana Hrivnacova, 5.4.2002)
/// Used to define particles which will be added to Geant3/4 (M. Al-Turany)

#ifndef FAIR_PARTICLE_H
#define FAIR_PARTICLE_H

#include <Rtypes.h>            // for Int_t, Double_t, Bool_t, etc
#include <TMCParticleType.h>   // for TMCParticleType
#include <TObject.h>           // for TObject
#include <TRef.h>              // for TRef
#include <TRefArray.h>         // for TRefArray
#include <TString.h>           // for TString

class TParticle;

class FairParticle : public TObject
{
  public:
    FairParticle(Int_t id, TParticle* particle);
    FairParticle(Int_t id, TParticle* particle, FairParticle* mother);
    FairParticle(const char* name,
                 Int_t z,
                 Int_t a,
                 Int_t s,
                 Double_t mass,
                 Int_t q,
                 Bool_t stable,
                 Double_t decaytime);
    FairParticle(const char* name, Int_t z, Int_t a, Double_t mass, Int_t q, Bool_t stable, Double_t decaytime);
    FairParticle(Int_t pdg,
                 const TString name,
                 TMCParticleType mcType,
                 Double_t mass,
                 Double_t charge,
                 Double_t lifetime,
                 const TString pType = "Ion",
                 Double_t width = 0,
                 Int_t iSpin = 0,
                 Int_t iParity = 0,
                 Int_t iConjugation = 0,
                 Int_t iIsospin = 0,
                 Int_t iIsospinZ = 0,
                 Int_t gParity = 0,
                 Int_t lepton = 0,
                 Int_t baryon = 0,
                 Bool_t stable = kFALSE);

    FairParticle();

    ~FairParticle() override;

    // methods
    void SetMother(FairParticle* particle);
    void AddDaughter(FairParticle* particle);
    void Print(Option_t* option = "") const override;
    void PrintDaughters() const;

    // get methods
    Int_t GetPDG() const;
    TParticle* GetParticle() const;
    FairParticle* GetMother() const;
    Int_t GetNofDaughters() const;
    FairParticle* GetDaughter(Int_t i) const;
    const char* GetName() const override { return fname.Data(); }
    TMCParticleType GetMCType() { return fmcType; }
    Double_t GetMass() { return fmass; }
    Double_t GetCharge() { return fcharge; }
    Double_t GetDecayTime() { return fDecayTime; }
    const TString& GetPType() { return fpType; }
    Double_t GetWidth() { return fwidth; }
    Int_t GetSpin() { return fiSpin; }
    Int_t GetiParity() { return fiParity; }
    Int_t GetConjugation() { return fiConjugation; }
    Int_t GetIsospin() { return fiIsospin; }
    Int_t GetIsospinZ() { return fiIsospinZ; }
    Int_t GetgParity() { return fgParity; }
    Int_t GetLepton() { return flepton; }
    Int_t GetBaryon() { return fbaryon; }
    Bool_t IsStable() { return fstable; }

  private:
    FairParticle(const FairParticle& P);
    FairParticle& operator=(const FairParticle&) { return *this; }
    // data members
    Int_t fpdg;
    TParticle* fParticle;
    TRef fMother;
    TRefArray fDaughters;
    const TString fname;
    TMCParticleType fmcType;
    Double_t fmass;
    Double_t fcharge;
    Double_t fDecayTime;
    const TString fpType;
    Double_t fwidth;
    Int_t fiSpin;
    Int_t fiParity;
    Int_t fiConjugation;
    Int_t fiIsospin;
    Int_t fiIsospinZ;
    Int_t fgParity;
    Int_t flepton;
    Int_t fbaryon;
    Bool_t fstable;

    ClassDefOverride(FairParticle, 3);
};

#endif   // FAIR_PARTICLE_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH *
 *                                                                              *
 *              This software is distributed under the terms of the *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE" *
 ********************************************************************************/

/** FairPrimaryGenerator.h
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairPrimaryGenerator is responsible for the handling of the MC input.
Several input generators can be registered to it; these have to be
derived from the FairGenerator class. The FairPrimaryGenerator defines
position and (optionally) smearing of the primary vertex.
This class should be instantised only once.

Modified 05.06.07:  add a method DoTracking(Bool_t) to be able to switch on/off
the tracking from the macro (M. Al-Turany)

**/

#ifndef FAIRPRIMARYGENERATOR_H
#define FAIRPRIMARYGENERATOR_H

#include "FairGenerator.h"   // for FairGenerator

#include <Rtypes.h>   // for Double_t, Bool_t, Int_t, etc
#include <TMCProcess.h>
#include <TNamed.h>      // for TNamed
#include <TObjArray.h>   // for TObjArray
#include <TVector3.h>    // for TVector3
#include <iostream>      // for cout

class FairGenericStack;
class FairMCEventHeader;
class TIterator;

class FairPrimaryGenerator : public TNamed
{

  public:
    /** Default constructor. **/
    FairPrimaryGenerator();

    /** Constructor with name and title **/
    FairPrimaryGenerator(const char *name, const char *title = "FAIR Generator");

    /** Destructor. **/
    virtual ~FairPrimaryGenerator();

    /** Initialize the generater (if needed!)*/
    virtual Bool_t Init();

    /** Finalize the generater (if needed!)*/
    virtual void Finish();

    /** Register a generator derived from FairGenerator.  **/
    void AddGenerator(FairGenerator *generator)
    {
        if (!fGenList) {
            std::cout << "Empty fGenList pointer ! " << std::endl;
            return;
        }
        fGenList->Add(generator);
    }

    void SetEventNr(Int_t evtNr) { fEventNr = evtNr; }

    /** Public method GenerateEvent
      To be called at the beginning of each event from FairMCApplication.
      Generates an event vertex and calls the ReadEvent methods from the
      registered generators.
      *@param pStack The particle stack
      *@return kTRUE if successful, kFALSE if not
      **/
    virtual Bool_t GenerateEvent(FairGenericStack *pStack);

    /** Public method AddTrack
      Adding a track to the MC stack. To be called within the ReadEvent
      methods of the registered generators.
      *@param pdgid Particle ID (PDG code)
      *@param px,py,pz Momentum coordinates [GeV]
      *@param vx,vy,vz Track origin relative to event vertex
      **/
    virtual void AddTrack(Int_t pdgid,
                          Double_t px,
                          Double_t py,
                          Double_t pz,
                          Double_t vx,
                          Double_t vy,
                          Double_t vz,
                          Int_t parent = -1,
                          Bool_t wanttracking = true,
                          Double_t e = -9e9,
                          Double_t tof = 0.,
                          Double_t weight = 0.,
                          TMCProcess proc = kPPrimary);

    /** Clone this object (used in MT mode only) */
    virtual FairPrimaryGenerator *ClonePrimaryGenerator() const;

    /** Set beam position and widths.
     *@param beamX0      mean x position of beam at target
     *@param beamY0      mean y position of beam at target
     *@param beamSigmaX  Gaussian beam width in x
     *@param beamSigmaY  Gaussian beam width in y
     **/
    void SetBeam(Double_t beamX0, Double_t beamY0, Double_t beamSigmaX, Double_t beamSigmaY);

    /** Set nominal beam angle and angle widths.
     *@param beamAngleX0      mean x angle of beam at target
     *@param beamAngleY0      mean y angle of beam at target
     *@param beamAngleSigmaX  Gaussian beam angle width in x
     *@param beamAngleSigmaY  Gaussian beam angle width in y
     **/
    void SetBeamAngle(Double_t beamAngleX0, Double_t beamAngleY0, Double_t beamAngleSigmaX, Double_t beamAngleSigmaY);

    /** Public method SetEventPlane
     **@param phiMin   Lower limit for event plane angle [rad]
     **@param phiMax   Upper limit for event plane angle [rad]
     **If set, an event plane angle will be generated with flat
     **distrtibution between phiMin and phiMax.
     **/
    void SetEventPlane(Double_t phiMin, Double_t phiMax);

    /** Set target position and thickness.
     *@param targetZ   z position of target center
     *@param targetDz  full target thickness
     **/
    void SetTarget(Double_t targetZ, Double_t targetDz);

    /** Set target position for multiple tagets. The thickness
     * is the same for all targets.
     *@param nroftargets   number of targets
     *@param *targetZ      z positions of target center
     *@param targetDz      full target thickness
     **/
    void SetMultTarget(Int_t nroftargets, Double_t *targetZ, Double_t targetDz);

    /** Enable vertex smearing in z and/or xy direction **/
    void SmearVertexZ(Bool_t flag);
    void SmearGausVertexZ(Bool_t flag);
    void SmearVertexXY(Bool_t flag);
    void SmearGausVertexXY(Bool_t flag);

    TObjArray *GetListOfGenerators() { return fGenList; }

    /** Set the pointer to the MCEvent **/
    void SetEvent(FairMCEventHeader *event) { fEvent = event; };

    /** Accessor to the MCEvent **/
    FairMCEventHeader *GetEvent() { return fEvent; };

    /** Swich on/off the tracking of a particle*/

    void DoTracking(Bool_t doTracking = kTRUE) { fdoTracking = doTracking; }

    Int_t GetTotPrimary() { return fTotPrim; }

  protected:
    /**  Copy constructor */
    FairPrimaryGenerator(const FairPrimaryGenerator &);
    /**  Assignment operator */
    FairPrimaryGenerator &operator=(const FairPrimaryGenerator &);

    /**  Nominal beam position at target in x [cm] */
    Double_t fBeamX0;
    /** Nominal beam position at target in y [cm]*/
    Double_t fBeamY0;
    /** Beam width (Gaussian) in x [cm]*/
    Double_t fBeamSigmaX;
    /**  Beam width (Gaussian) in y [cm]*/
    Double_t fBeamSigmaY;

    /**  Nominal beam angle at target in x [rad] */
    Double_t fBeamAngleX0;
    /**  Nominal beam angle at target in y [rad] */
    Double_t fBeamAngleY0;
    /**  Actual beam angle at target in x [rad] */
    Double_t fBeamAngleX;
    /**  Actual beam angle at target in y [rad] */
    Double_t fBeamAngleY;
    /** Beam angle width (Gaussian) in x [rad]*/
    Double_t fBeamAngleSigmaX;
    /** Beam angle width (Gaussian) in y [rad]*/
    Double_t fBeamAngleSigmaY;
    /** Actual beam direction at the vertex */
    TVector3 fBeamDirection;

    /** Lower limit for the event plane rotation angle [rad] */
    Double_t fPhiMin;
    /** Upper limit for the event plane rotation angle [rad] */
    Double_t fPhiMax;
    /** Actual event plane rotation angle [rad] */
    Double_t fPhi;

    /**  Nominal z position of center of targets [cm]*/
    Double_t *fTargetZ;   //!
    /**  Number of targets;*/
    Int_t fNrTargets;
    /**  Full target thickness [cm]*/
    Double_t fTargetDz;

    /** Vertex position of current event [cm]*/
    TVector3 fVertex;

    /** Number of primary tracks in current event*/
    Int_t fNTracks;

    /**  Flag for uniform vertex smearing in z*/
    Bool_t fSmearVertexZ;
    /**  Flag for gaus vertex smearing in z*/
    Bool_t fSmearGausVertexZ;
    /**  Flag for vertex smearing in xy*/
    Bool_t fSmearVertexXY;
    /**  Flag for gaus vertex smearing in xy*/
    Bool_t fSmearGausVertexXY;
    /**  Flag for beam gradient calculation*/
    Bool_t fBeamAngle;
    /**  Flag for event plane rotation*/
    Bool_t fEventPlane;

    /**  Pointer to MC stack*/
    FairGenericStack *fStack;   //!
    /**  List of registered generators */
    TObjArray *fGenList;
    /**  Iterator over generator list */
    TIterator *fListIter;   //!
    /**  Pointer to MCEventHeader */
    FairMCEventHeader *fEvent;   //!
    /** go to tracking  */
    Bool_t fdoTracking;   //!
    /** Number of MC tracks before a Generator is called, needed for MC index
     * update */
    Int_t fMCIndexOffset;   //!
    /** Number of all primaries of this run*/
    static Int_t fTotPrim;   //!
    /** Event number (Set by the primary generator if not set already by one of
      the specific generators
   **/
    Int_t fEventNr;

    /** Private method MakeVertex. If vertex smearing in xy is switched on,
      the event vertex is smeared Gaussianlike in x and y direction
      according to the mean beam positions and widths set by the
      SetBeam method. If vertex smearing in z is switched on, the z
      coordinate of the event vertex is flatly distributed over the
      extension of the target.
      To be called at the beginning of the event from the
      GenerateEvent method.
  **/
    virtual void MakeVertex();

    /** Private method MakeBeamAngle. If beam angle smearing in xy
  is switched on, all tracks in an event are rotated by a Gaussianlike
  angle distribution around the x and y axis according to the mean
  beam angle and angle widths set by the SetBeamAngle method.
  To be called at the beginning of the event from the GenerateEvent
  method.
  **/
    virtual void MakeBeamAngle();

    /** Private method MakeEventPlane. If the rotation of the event around the
      z-axis by a random angle is switched on, the complete event is rotated
      by the chosen angle. This function is called at the beginning of the
      event from the GenerateEvent method. The function pick a random
      rotation angle between fPhiMin and fPhiMax which are set using the
      function SetEventPlane.
  **/
    void MakeEventPlane();

    ClassDef(FairPrimaryGenerator, 5);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNIDGENERATOR_H
#define FAIRRUNIDGENERATOR_H

#include <time.h>   // IWYU pragma: keep for timespec
// IWYU pragma: no_include <sys/_structs.h>

typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
typedef unsigned char uuid_t[16];

class FairRunIdGenerator
{
    struct uuid
    {
        uint32_t time_low;
        uint16_t time_mid;
        uint16_t time_hi_and_version;
        uint16_t clock_seq;
        uint8_t node[6];
    };

    struct timespec fTimeSpec;

    int get_random_fd(void);
    void get_random_bytes(void*, int);
    int get_node_id(unsigned char*);
    int get_clock(uint32_t*, uint32_t*, uint16_t*);
    void uuid_generate_time(uuid_t);
    void uuid_generate_random(uuid_t);
    void uuid_generate(uuid_t);
    void uuid_pack(const struct uuid*, uuid_t);
    void uuid_unpack(const uuid_t, struct uuid*);

  public:
    struct timespec getTimeSpec() { return fTimeSpec; }
    struct timespec getTimeSpecFromTID(unsigned int ms);
    unsigned int getTID();

  public:
    FairRunIdGenerator()
        : fTimeSpec()
    {}
    ~FairRunIdGenerator() {}
    unsigned int generateId(void);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUME_H
#define FAIR_VOLUME_H

#include "FairModule.h"

#include <Rtypes.h>    // for Int_t, FairVolume::Class, etc
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString

class FairDetector;
class FairGeoNode;

/**
 * This Object is only used for internal book keeping!
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairVolume : public TNamed
{
  public:
    FairVolume();
    FairVolume(const TString& name, Int_t id = 0, Int_t modId = 0, FairModule* fMod = nullptr);
    ~FairVolume() override;

    void setRealName(TString name) { fRealName = name; }
    const char* getRealName() const { return fRealName.Data(); }
    Int_t getVolumeId() const { return fVolumeId; }
    Int_t getModId() const { return fModId; }
    void setModId(Int_t id) { fModId = id; }
    void setCopyNo(Int_t id) { fCopyNo = id; }
    void setVolumeId(Int_t id) { fVolumeId = id; }
    void setGeoNode(FairGeoNode* d) { fNode = d; }
    void setMotherId(Int_t fM) { fMotherId = fM; }
    void setMotherCopyNo(Int_t copyNo) { fMotherCopyNo = copyNo; }

    FairModule* GetModule() const { return fModule; }
    FairDetector* GetDetector() const { return fDetector; }
    void SetModule(FairModule* mod);

    Int_t getMCid() const { return fMCid; }
    Int_t getCopyNo() const { return fCopyNo; }
    void setMCid(Int_t id) { fMCid = id; }
    FairGeoNode* getGeoNode() const { return fNode; }
    Int_t getMotherId() const { return fMotherId; }
    Int_t getMotherCopyNo() const { return fMotherCopyNo; }

  private:
    FairVolume(const FairVolume&);
    FairVolume& operator=(const FairVolume&);

    TString fRealName{""};            /**Volume Name in ASCII file*/
    Int_t fVolumeId{-1};              /**Volume Id in GeoManager*/
    Int_t fModId{-1};                 /**Module Id in which this volume exist*/
    Int_t fMCid{-1};                  /**Volume Id in MC*/
    Int_t fCopyNo{-1};                /**Volume Copy No*/
    Int_t fMotherId{-1};              /**Mother Volume Id*/
    Int_t fMotherCopyNo{-1};          /**Mother Volume Copy No*/
    FairDetector* fDetector{nullptr}; /** The Detector which will proccess the hits for this volume*/
    FairModule* fModule{nullptr};     /**The Module in which the volume is */
    FairGeoNode* fNode{nullptr};      /**Node corresponding to this volume*/

    ClassDefOverride(FairVolume, 2);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUMELIST_H
#define FAIR_VOLUMELIST_H

#include "FairVolume.h"

#include <Rtypes.h>      // for Int_t, etc
#include <TObjArray.h>   // for TObjArray
#include <TObject.h>     // for TObject
#include <TString.h>     // for TString

// class FairVolume;

/**
 * This Object is only used for internal book keeping!
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairVolumeList : public TObject
{
  private:
    TObjArray* fData;
    FairVolumeList(const FairVolumeList&);
    FairVolumeList& operator=(const FairVolumeList&);

  public:
    FairVolumeList();
    virtual ~FairVolumeList();

    FairVolume* getVolume(TString* name);
    Int_t getVolumeId(TString* name);

    FairVolume* findObject(TString name);
    void addVolume(FairVolume* elem);

    Int_t getEntries() { return fData->GetEntries(); }
    FairVolume* At(Int_t pos) { return (dynamic_cast<FairVolume*>(fData->At(pos))); }

    ClassDef(FairVolumeList, 1);
};

#endif   // FAIR_VOLUMELIST_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairRootFileSink                      -----
// -----                    Created 22.12.2017 by R. Karabowicz            -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef __FAIRROOT__FairRootFileSink__
#define __FAIRROOT__FairRootFileSink__

#include "FairSink.h"

#include <Rtypes.h>
#include <TFile.h>
#include <TString.h>
#include <typeinfo>

class FairEventHeader;
class FairFileHeader;
class TBranch;
class TObjArray;
class TObject;
class TTree;
class TFolder;

class FairRootFileSink : public FairSink
{
  public:
    FairRootFileSink(TFile* f, const char* Title = "OutputRootFile");
    FairRootFileSink(const TString* RootFileName, const char* Title = "OutputRootFile");
    FairRootFileSink(const TString RootFileName, const char* Title = "OutputRootFile");
    //  FairRootFileSink(const FairRootFileSink& file);
    virtual ~FairRootFileSink();

    virtual Bool_t InitSink();
    virtual void Close();
    virtual void Reset();

    virtual Sink_Type GetSinkType() { return kFILESINK; }

    virtual void FillEventHeader(FairEventHeader* feh);

    virtual TFile* OpenRootFile(TString fileName = "");
    TFile* GetRootFile() { return fRootFile; }
    virtual TString GetFileName() { return (fRootFile ? fRootFile->GetName() : ""); }

    virtual void SetOutTree(TTree* fTree) { fOutTree = fTree; }
    TTree* GetOutTree() { return fOutTree; }

    virtual void Fill();

    virtual Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0);

    virtual void RegisterImpl(const char*, const char*, void*);
    virtual void RegisterAny(const char* brname, const std::type_info& oi, const std::type_info& pi, void* obj);

    virtual void WriteFolder();
    virtual bool CreatePersistentBranchesAny();

    virtual void WriteObject(TObject* f, const char*, Int_t option = 0);
    virtual void WriteGeometry();

    virtual FairSink* CloneSink();

  private:
    /** Title of input sink, could be input, background or signal*/
    TString fOutputTitle;
    /** ROOT file */
    TFile* fRootFile;
    /** Output Tree  */
    TTree* fOutTree;
    /**  list of folders from all input (and friends) files */
    TObjArray* fListFolder;   //!
    /** folder structure of output */
    TFolder* fCbmout;
    /** Initialization flag, true if initialized */
    Bool_t fIsInitialized;

    FairRootFileSink(const FairRootFileSink&);
    FairRootFileSink operator=(const FairRootFileSink&);

    void TruncateBranchNames();
    void TruncateBranchNames(TBranch* b, TString ffn);
    // bool CreatePersistentBranchesAny();

    /**File Header*/
    FairFileHeader* fFileHeader;   //!

    bool fPersistentBranchesDone{false};   //!

    ClassDef(FairRootFileSink, 1);
};

#endif /* defined(__FAIRROOT__FairRootFileSink__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairSink                              -----
// -----                    Created 22.12.2017 by R. Karabowicz            -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRSINK_H
#define FAIRSINK_H

#include <Rtypes.h>
#include <TString.h>
#include <map>        // map
#include <memory>     // unique_ptr
#include <string>     // string
#include <typeinfo>   // type_info

class TObject;
class TFolder;
class TTree;

enum Sink_Type
{
    kONLINESINK,
    kFILESINK
};

class FairSink
{
  public:
    FairSink();
    FairSink(const FairSink& sink);
    virtual ~FairSink();

    virtual Bool_t InitSink() = 0;
    virtual void Close() = 0;
    virtual void Reset() = 0;

    virtual Sink_Type GetSinkType() = 0;
    virtual TString GetFileName() { return ""; }

    void SetRunId(Int_t runId) { fRunId = runId; }
    Int_t GetRunId() const { return fRunId; }

    virtual void SetOutTree(TTree* fTree) = 0;

    virtual void Fill() = 0;

    virtual Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) = 0;

    virtual void RegisterImpl(const char*, const char*, void*) = 0;
    virtual void RegisterAny(const char* brname, const std::type_info& oi, const std::type_info& pi, void* obj) = 0;

    virtual void WriteFolder() = 0;
    virtual bool CreatePersistentBranchesAny() = 0;

    virtual void WriteObject(TObject* f, const char*, Int_t option = 0) = 0;
    virtual void WriteGeometry() = 0;

    virtual FairSink* CloneSink() = 0;

  protected:
    struct TypeAddressPair
    {
        TypeAddressPair(const std::type_info& oi, const std::type_info& pi, void* a)
            : origtypeinfo(oi)
            , persistenttypeinfo(pi)
            , ptraddr(a)
        {}
        const std::type_info& origtypeinfo;         // type_info of type addr points to
        const std::type_info& persistenttypeinfo;   // type_info of ROOT persistent branch (drops pointers)
        void* ptraddr;                              // address of a pointer (pointing to origtypeinfo);
    };

    Int_t fRunId;

    /**folder structure of output*/
    TFolder* fOutFolder;
    /// A map of branchnames to typeinformation + memory address;
    /// used for branches registered to bes stored; use of ptr here
    /// since type_info cannot be copied
    std::map<std::string, std::unique_ptr<TypeAddressPair const>> fPersistentBranchesMap;   //!

  public:
    ClassDef(FairSink, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

#ifndef __FAIRROOT__FairFileSourceBase__
#define __FAIRROOT__FairFileSourceBase__

#include "FairSource.h"

#include <TFile.h>
#include <list>
#include <map>

/**
 * \brief Internal base class for FairFileSource and FairMixedSource
 */
class FairFileSourceBase : public FairSource
{
  public:
    ~FairFileSourceBase() override;
    void Reset() override {}
    Source_Type GetSourceType() override { return kFILE; }
    void SetParUnpackers() override {}
    Bool_t InitUnpackers() override { return kTRUE; }
    Bool_t ReInitUnpackers() override { return kTRUE; }

    Bool_t CompareBranchList(TFile* fileHandle, TString inputLevel);

  protected:
    FairFileSourceBase()
        : FairSource(){};

    std::map<TString, std::list<TString>> fCheckInputBranches{};   //!

    ClassDefOverride(FairFileSourceBase, 0);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairFileSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairFileSource__
#define __FAIRROOT__FairFileSource__

#include "FairFileSourceBase.h"

#include <TArrayI.h>
#include <TChain.h>
#include <TF1.h>
#include <TFile.h>
#include <TFolder.h>
#include <TString.h>
#include <list>
#include <map>
#include <memory>

class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TTree;

class FairFileSource : public FairFileSourceBase
{
  public:
    FairFileSource(TFile* f, const char* Title = "InputRootFile", UInt_t identifier = 0);
    FairFileSource(const TString* RootFileName, const char* Title = "InputRootFile", UInt_t identifier = 0);
    FairFileSource(const TString RootFileName, const char* Title = "InputRootFile", UInt_t identifier = 0);
    // FairFileSource(const FairFileSource& file);
    ~FairFileSource() override;

    Bool_t Init() override;
    Int_t ReadEvent(UInt_t i = 0) override;
    void Close() override;

    /**Check the maximum event number we can run to*/
    Int_t CheckMaxEventNo(Int_t EvtEnd = 0) override;
    /**Read the tree entry on one branch**/
    void ReadBranchEvent(const char* BrName) override;
    /**Read specific tree entry on one branch**/
    void ReadBranchEvent(const char* BrName, Int_t Entry) override;
    void FillEventHeader(FairEventHeader* feh) override;

    const TFile* GetRootFile() { return fRootFile; }
    /** Add a friend file (input) by name)*/
    void AddFriend(TString FileName);
    /**Add ROOT file to input, the file will be chained to already added files*/
    void AddFile(TString FileName);
    void AddFriendsToChain();
    void PrintFriendList();
    void CheckFriendChains();
    void CreateNewFriendChain(TString inputFile, TString inputLevel);
    TTree* GetInTree() { return fInChain->GetTree(); }
    TChain* GetInChain() { return fInChain; }
    TFile* GetInFile() { return fRootFile; }
    void CloseInFile()
    {
        if (fRootFile) {
            fRootFile->Close();
        }
    }
    void SetInTree(TTree* tempTree);
    TObjArray* GetListOfFolders() { return fListFolder; }
    TFolder* GetBranchDescriptionFolder() { return fCbmroot; }
    UInt_t GetEntries() { return fNoOfEntries; }

    //    TList*              GetBranchNameList() {return fBranchNameList;}

    void SetInputFile(TString name);

    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime).
     * The total repetition time is beamTime + gapTime */
    void SetBeamTime(Double_t beamTime, Double_t gapTime);
    /** Set the min and max limit for event time in ns */
    void SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void SetEventMeanTime(Double_t mean);
    void SetEventTime();
    Double_t GetDeltaEventTime();
    void SetFileHeader(FairFileHeader* f) { fFileHeader = f; }
    Double_t GetEventTime();

    Bool_t ActivateObject(TObject** obj, const char* BrName) override;
    Bool_t ActivateObjectAny(void**, const std::type_info&, const char*) override;

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void SetEvtHeaderNew(Bool_t Status) { fEvtHeaderIsNew = Status; }
    Bool_t IsEvtHeaderNew() { return fEvtHeaderIsNew; }

    /** Allow to disable the testing the file layout when adding files to a chain.
     */
    void SetCheckFileLayout(Bool_t enable) { fCheckFileLayout = enable; }

    /**Read one event from source to find out which RunId to use*/
    Bool_t SpecifyRunId() override;

  private:
    /** Title of input source, could be input, background or signal*/
    TString fInputTitle;
    /**ROOT file*/
    TFile* fRootFile;
    /** Current Entry number */
    Int_t fCurrentEntryNr;   //!
    /** List of all files added with AddFriend */
    std::list<TString> fFriendFileList;                                 //!
    std::list<TString> fInputChainList;                                 //!
    std::map<TString, TChain*> fFriendTypeList;                         //!
    std::list<TString> fInputLevel;                                     //!
    std::map<TString, std::multimap<TString, TArrayI>> fRunIdInfoAll;   //!
    /**Input Chain */
    TChain* fInChain;
    /**Input Tree */
    TTree* fInTree;
    /** list of folders from all input (and friends) files*/
    TObjArray* fListFolder;   //!
    /**folder structure of output*/
    TFolder* fCbmout;
    /**folder structure of input*/
    TFolder* fCbmroot;
    /***/
    UInt_t fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t IsInitialized;

    FairFileSource(const FairFileSource&);
    FairFileSource operator=(const FairFileSource&);

    /** MC Event header */
    FairMCEventHeader* fMCHeader;   //!

    /**Event Header*/
    FairEventHeader* fEvtHeader;   //!

    /**File Header*/
    FairFileHeader* fFileHeader;   //!

    /** This is true if the event time used, came from simulation*/
    Bool_t fEventTimeInMCHeader;   //!
    /**This flag is true if the event header was created in this session
     * otherwise it is false which means the header was created in a previous data
     * level and used here (e.g. in the digi)
     */
    Bool_t fEvtHeaderIsNew;   //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t fCurrentEntryNo;   //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t fTimeforEntryNo;   //!

    /** min time for one event (ns) */
    Double_t fEventTimeMin;   //!
    /** max time for one Event (ns) */
    Double_t fEventTimeMax;   //!
    /** Time of event since th start (ns) */
    Double_t fEventTime;   //!
    /** Time of particles in beam (ns) */
    Double_t fBeamTime;   //!
    /** Time without particles in beam (gap) (ns) */
    Double_t fGapTime;   //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t fEventMeanTime;   //!
    /** used to generate random numbers for event time; */
    std::unique_ptr<TF1> fTimeProb;   //!
    /** True if the file layout should be checked when adding files to a chain.
     *  Default value is true.
     */
    Bool_t fCheckFileLayout;   //!

    ClassDefOverride(FairFileSource, 3);
};

#endif /* defined(__FAIRROOT__FairFileSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairMixedSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairMixedSource__
#define __FAIRROOT__FairMixedSource__

#include "FairFileSourceBase.h"

#include <TArrayI.h>
#include <TChain.h>
#include <TF1.h>
#include <TFile.h>
#include <list>
#include <map>
#include <memory>

class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TString;
class TFolder;
class TObject;

class FairRootManager;

class FairMixedSource : public FairFileSourceBase
{
  public:
    FairMixedSource(TFile* f, const char* Title = "InputRootFile", UInt_t identifier = 0);
    FairMixedSource(const TString* RootFileName, const char* Title = "InputRootFile", UInt_t identifier = 0);
    FairMixedSource(const TString RootFileName,
                    const Int_t signalId,
                    const char* Title = "InputRootFile",
                    UInt_t identifier = 0);
    //  FairMixedSource(const FairMixedSource& file);
    ~FairMixedSource() override;

    Bool_t Init() override;
    Int_t ReadEvent(UInt_t i = 0) override;
    void Close() override;

    /**Check the maximum event number we can run to*/
    Int_t CheckMaxEventNo(Int_t EvtEnd = 0) override;
    /**Read the tree entry on one branch**/
    void ReadBranchEvent(const char* BrName) override;
    /** Read specific tree entry on one branch**/
    void ReadBranchEvent(const char* BrName, Int_t Entry) override;

    void FillEventHeader(FairEventHeader* feh) override;

    const TFile* GetRootFile() { return fRootFile; }
    /** Add a friend file (input) by name)*/

    Bool_t ActivateObject(TObject** obj, const char* BrName) override;
    Bool_t ActivateObjectAny(void**, const std::type_info&, const char*) override;

    void ReadBKEvent(UInt_t i = 0);

    /**Set the input signal file
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file
     */
    void SetSignalFile(TString name, UInt_t identifier);
    /**Set the input background file by name*/
    void SetBackgroundFile(TString name);
    /**Add signal file to input
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file to which this signal should be added
     */
    void AddSignalFile(TString name, UInt_t identifier);
    void AddBackgroundFile(TString name);

    TChain* GetBGChain() { return fBackgroundChain; }
    TChain* GetSignalChainNo(UInt_t i);

    Bool_t OpenBackgroundChain();
    Bool_t OpenSignalChain();

    /**Set the signal to background ratio in event units
     *@param background :  Number of background Events for one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     */
    void BGWindowWidthNo(UInt_t background, UInt_t Signalid);
    /**Set the signal to background rate in time units
     *@param background :  Time of background Events before one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     */
    void BGWindowWidthTime(Double_t background, UInt_t Signalid);

    /** Set the min and max limit for event time in ns */
    void SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void SetEventMeanTime(Double_t mean);
    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime).
     * The total repetition time is beamTime + gapTime */
    void SetBeamTime(Double_t beamTime, Double_t gapTime);
    void SetEventTime();
    Double_t GetDeltaEventTime();
    void SetFileHeader(FairFileHeader* f) { fFileHeader = f; }
    Double_t GetEventTime();

    TObjArray* GetListOfFolders() { return fListFolder; }
    TFolder* GetBranchDescriptionFolder() { return fCbmroot; }
    UInt_t GetEntries() { return fNoOfEntries; }

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void SetEvtHeaderNew(Bool_t Status) { fEvtHeaderIsNew = Status; }
    Bool_t IsEvtHeaderNew() { return fEvtHeaderIsNew; }

    /** Use the Backgraund RunID to initialize the parameter for the run */
    void UseRunIdFromBG();
    /** Use the Backgraund RunID to initialize the parameter for the run
     *@param identifier: Signal file identifier to be used by default we take the first Signal
     */
    void UseRunIdfromSG(UInt_t identifier = 1);

  private:
    /**IO manager */
    FairRootManager* fRootManager;

    /** Title of input source, could be input, background or signal*/
    TString fInputTitle;
    /**ROOT file*/
    TFile* fRootFile;
    /** List of all files added with AddFriend */
    std::list<TString> fFriendFileList;                                 //!
    std::list<TString> fInputChainList;                                 //!
    std::map<TString, TChain*> fFriendTypeList;                         //!
    std::list<TString> fInputLevel;                                     //!
    std::map<TString, std::multimap<TString, TArrayI>> fRunIdInfoAll;   //!
    /** list of folders from all input (and friends) files*/
    TObjArray* fListFolder;   //!
    /**folder structure of output*/
    TFolder* fCbmout;
    /**folder structure of input*/
    TFolder* fCbmroot;
    /***/
    UInt_t fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t IsInitialized;

    /** MC Event header */
    FairMCEventHeader* fMCHeader;   //!

    /**Event Header*/
    FairEventHeader* fEvtHeader;   //!

    /**Output Event Header*/
    FairEventHeader* fOutHeader;   //!

    /**File Header*/
    FairFileHeader* fFileHeader;   //!

    /** This is true if the event time used, came from simulation*/
    Bool_t fEventTimeInMCHeader;   //!
    /**This flag is true if the event header was created in this session
     * otherwise it is false which means the header was created in a previous data
     * level and used here (e.g. in the digi)
     */
    Bool_t fEvtHeaderIsNew;   //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t fCurrentEntryNo;   //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t fTimeforEntryNo;   //!
    /* /\**No of entries in BG Chain*\/ */
    UInt_t fNoOfBGEntries;   //!
    /* /\**Hold the current entry for each input chain*\/ */
    std::map<UInt_t, UInt_t> fCurrentEntry;   //!

    /** min time for one event (ns) */
    Double_t fEventTimeMin;   //!
    /** max time for one Event (ns) */
    Double_t fEventTimeMax;   //!
    /** Time of event since th start (ns) */
    Double_t fEventTime;   //!
    /** Time of particles in beam (ns) */
    Double_t fBeamTime;   //!
    /** Time without particles in beam (gap) (ns) */
    Double_t fGapTime;   //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t fEventMeanTime;   //!
    /** used to generate random numbers for event time; */
    std::unique_ptr<TF1> fTimeProb;   //!

    /**holds the SB ratio by number*/
    std::map<UInt_t, Double_t> fSignalBGN;   //!
    /* /\**True for background window in entry units*\/ */
    Bool_t fSBRatiobyN;   //!
    /* /\**True for background window in time units (ns) *\/ */
    Bool_t fSBRatiobyT;   //!

    /**Actual identifier of the added signals, this is used to identify how many signals are added*/
    UInt_t fActualSignalIdentifier;   //!
    /** Total number of signals added (Types and not files!)*/
    UInt_t fNoOfSignals;   //!
    /** list of chains which has to be created for the different signals*/
    std::list<TString>* fSignalChainList;   //!
    /**Chain containing the background*/
    TChain* fBackgroundChain;                    //!
    std::map<UInt_t, TChain*> fSignalTypeList;   //!

    /**True if RunId is taken from Backgraund*/
    Bool_t fRunIdFromBG;   //!
    /**True if RunId is taken from Signal */
    Bool_t fRunIdFromSG;   //!
    /** Identifier of signal file for RunID
     * Zero if RunId is taken from BG.
     */
    UInt_t fRunIdFromSG_identifier;   //!

    /**Read one event from source to find out which RunId to use*/
    Bool_t SpecifyRunId() override;

    FairMixedSource(const FairMixedSource&);
    FairMixedSource& operator=(const FairMixedSource&);

  public:
    ClassDefOverride(FairMixedSource, 0);
};

#endif /* defined(__FAIRROOT__FairMixedSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairSource                            -----
// -----                    Created 01.11.2013 by F. Uhlig                 -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRSOURCE_H
#define FAIRSOURCE_H

#include "FairLogger.h"
#include "TClass.h"

#include <Rtypes.h>
#include <TObject.h>

class FairEventHeader;

enum Source_Type
{
    kONLINE,
    kFILE
};

class FairSource : public TObject
{
  public:
    FairSource();
    FairSource(const FairSource& source);
    virtual ~FairSource();
    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t = 0) = 0;
    virtual Bool_t SpecifyRunId() = 0;
    virtual void Close() = 0;
    virtual void Reset() = 0;
    virtual Bool_t ActivateObject(TObject**, const char*) { return kFALSE; }
    virtual Bool_t ActivateObjectAny(void**, const std::type_info&, const char*) { return kFALSE; }
    virtual Source_Type GetSourceType() = 0;
    virtual void SetParUnpackers() = 0;
    virtual Bool_t InitUnpackers() = 0;
    virtual Bool_t ReInitUnpackers() = 0;
    /**Check the maximum event number we can run to*/
    virtual Int_t CheckMaxEventNo(Int_t = 0) { return -1; }
    /**Read the tree entry on one branch**/
    virtual void ReadBranchEvent(const char*) { return; }
    virtual void ReadBranchEvent(const char*, Int_t) { return; }
    virtual void FillEventHeader(FairEventHeader* feh);
    void SetRunId(Int_t runId) { fRunId = runId; }
    Int_t GetRunId() const { return fRunId; }

  protected:
    Int_t fRunId;

  public:
    ClassDef(FairSource, 2);
};

namespace {

template<typename S>
bool ActivateObjectAnyImpl(S* source, void** obj, const std::type_info& info, const char* brname)
{
    // we check if the types match at all
    auto br = source->GetBranch(brname);
    if (!br) {
        // branch not found in source
        return false;
    }

    // look up the TClass and resulting typeid stored in this branch
    auto cl = TClass::GetClass(br->GetClassName());
    if (!cl) {
        // class not found
        return false;
    }

    auto storedtype = cl->GetTypeInfo();

    // check consistency of types
    if (info.hash_code() != storedtype->hash_code()) {
        LOG(info) << "Trying to read from branch " << brname << " with wrong type " << info.name()
                  << " (expected: " << storedtype->name() << ")\n";
        return false;
    }
    source->SetBranchStatus(brname, 1);
    // force to use the (void*) interface which is non-checking
    source->SetBranchAddress(brname, (void*)obj);
    return true;
}

}   // namespace

#endif
#ifndef FAIR_LINK_MANAGER_H
#define FAIR_LINK_MANAGER_H

#include <Rtypes.h>    // for Bool_t, Int_t, UInt_t, etc
#include <TMCtls.h>    // for multi-threading
#include <TObject.h>   // for TObject
#include <set>         // for set of branch types to ignore

class FairLogger;

class FairLinkManager : public TObject
{
  public:
    /**ctor*/
    FairLinkManager();
    /**dtor*/
    virtual ~FairLinkManager();

    /** static access method */
    static FairLinkManager* Instance();
    virtual void AddIgnoreType(Int_t type);   ///< Adds a BranchId (Type) to which links are not included in the link
                                              ///< list. Either ignore types or include types can be given.
    virtual Bool_t IsIgnoreType(Int_t type) const;

    virtual void AddIncludeType(Int_t type);   ///< Adds a BranchId (Type) to which links are included in the link list.
                                               ///< Either ignore types or include types can be given (XOR).

    std::set<Int_t> GetIgnoreTypes() const { return fIgnoreTypes; }

  private:
    /**private methods*/
    FairLinkManager(const FairLinkManager&);
    FairLinkManager& operator=(const FairLinkManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/

    std::set<Int_t> fIgnoreTypes;   //!
    Bool_t fIgnoreSetting;

    /**Singleton instance*/
    static TMCThreadLocal FairLinkManager* fgInstance;

    FairLogger* fLogger;   //!

    ClassDef(FairLinkManager, 1);
};

#endif   // FAIR_ROOT_MANAGER_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairRadGridManager source file             -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------
#ifndef FAIRRADGRIDMANAGER_H
#define FAIRRADGRIDMANAGER_H 1

#include <Rtypes.h>           // for Float_t, Double_t, Int_t, etc
#include <TLorentzVector.h>   // for TLorentzVector
#include <TObjArray.h>        // for TObjArray
#include <TString.h>          // for TString
#include <iostream>           // for basic_ostream::operator<<, etc

class FairMesh;
class TClonesArray;

/**
 * @class FairRadGridManager
 */

class FairRadGridManager
{
  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadGridManager class.
     */
    FairRadGridManager();
    /**
     * Destructor.
     */
    virtual ~FairRadGridManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadGridManager, 1);

  private:
    FairRadGridManager(const FairRadGridManager&);
    FairRadGridManager& operator=(const FairRadGridManager&);

    static FairRadGridManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray* fPointCollection;
    /**track index */
    Int_t fTrackID;   //!
    /**volume id */
    Int_t fVolumeID;   //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;   //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;   //!
    /**  momentum in*/
    TLorentzVector fMomIn;   //!
    /**  momentum out*/
    TLorentzVector fMomOut;   //!
    /**track time */
    Double_t fTime;   //!
    /**track length */
    Double_t fLength;   //!
    /** energy loss */
    Double_t fELoss;   //!
    /** mass umber*/
    Float_t fA;
    /** atomic number*/
    Float_t fZmat;
    /**  density */
    Float_t fDensity;
    /**radition length */
    Float_t fRadl;
    /**absorption length */
    Float_t fAbsl;
    /**estimator*/
    Int_t fEstimator;
    /** the mesh */
    TObjArray* fMeshList;
    /** output file name */
    TString fOutputFileName;

  public:
    TObjArray* GetMeshList() { return fMeshList; }
    void AddMeshList(TObjArray* list)
    {
        std::cout << " grid manag " << list->GetEntriesFast() << std::endl;
        fMeshList = list;
    }
    Bool_t IsTrackInside(TLorentzVector& vec, FairMesh* aMesh);
    Bool_t IsTrackEntering(TLorentzVector& vec1, TLorentzVector& vec2);
    /** fill the 2D mesh */
    void FillMeshList();
    /**initialize the manager*/
    void Init();
    /**reset*/
    void Reset();
    /**set output file name*/
    void SetOutputFileName(TString tempString) { fOutputFileName = tempString; }
    TString GetOutputFileName() { return fOutputFileName; }
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadGridManager object, created
     * with FairRadGridManager::FairRadGridManager().
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated("Maybe use FairMCApplcation::GetRadGridMan()")]] static FairRadGridManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenManager source file             -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADLENMANAGER_H
#define FAIRRADLENMANAGER_H 1

#include <Rtypes.h>           // for Float_t, Double_t, Int_t, etc
#include <TLorentzVector.h>   // for TLorentzVector

class TClonesArray;
class TVirtualMC;

/**
 * @class FairRadLenManager
 */

class FairRadLenManager
{
  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadLenManager class.
     */
    FairRadLenManager();

    /**
     * Destructor.
     */
    virtual ~FairRadLenManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadLenManager, 1);

  private:
    FairRadLenManager(const FairRadLenManager&);
    FairRadLenManager& operator=(const FairRadLenManager&);

    static FairRadLenManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray* fPointCollection;
    /**track index */
    Int_t fTrackID;   //!
    /**volume id */
    Int_t fVolumeID;   //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;   //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;   //!
    /**  momentum in*/
    TLorentzVector fMomIn;   //!
    /**  momentum out*/
    TLorentzVector fMomOut;   //!
    /**track time */
    Double_t fTime;   //!
    /**track length */
    Double_t fLength;   //!
    /** energy loss */
    Double_t fELoss;   //!
    /** mass umber*/
    Float_t fA;
    /** atomic number*/
    Float_t fZmat;
    /**  density */
    Float_t fDensity;
    /**radition length */
    Float_t fRadl;
    /**absorption length */
    Float_t fAbsl;

  public:
    /**Add point to collection*/
    void AddPoint(TVirtualMC* aMC, const Int_t ModuleId);
    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated("Use AddPoint(TVirtualMC*, ...)")]] void AddPoint(const Int_t ModuleId);
    /**initialize the manager*/
    void Init();
    /**reset*/
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadLenManager object, created
     * with FairRadLenManager::FairRadLenManager().
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] static FairRadLenManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadMapManager source file            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADMAPMANAGER_H
#define FAIRRADMAPMANAGER_H 1

#include <Rtypes.h>           // for Double_t, Float_t, Int_t, etc
#include <TLorentzVector.h>   // for TLorentzVector

class TClonesArray;
class TMap;
class TVirtualMC;

/**
 * @class FairRadMapManager
 */

class FairRadMapManager
{
  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadMapManager class.
     */
    FairRadMapManager();

    /**
     * Destructor.
     */
    virtual ~FairRadMapManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadMapManager, 1);

  private:
    FairRadMapManager(const FairRadMapManager&);
    FairRadMapManager& operator=(const FairRadMapManager&);

    static FairRadMapManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray* fPointCollection;
    /**track index */
    Int_t fTrackID;   //!
    /**volume id */
    Int_t fVolumeID;   //!
    /** pid */
    Int_t fPdg;   //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;   //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;   //!
    /**  momentum in*/
    TLorentzVector fMomIn;   //!
    /**  momentum out*/
    TLorentzVector fMomOut;   //!
    /**track time */
    Double_t fTime;   //!
    /**track length */
    Double_t fLength;   //!
    /**track setp */
    Double_t fStep;
    /** energy loss */
    Double_t fELoss;   //!
    /**dose */
    Double_t fDose;
    Double_t fDoseSL;
    /** mass umber*/
    Float_t fA;
    /** atomic number*/
    Float_t fZmat;
    /** radiation length*/
    Float_t fRadl;
    /**  density */
    Float_t fDensity;
    /**absorption length */
    Float_t fAbsl;
    //**volume, mass */
    Double_t fActVol;
    Double_t fActMass;

    TMap* fMassMap;

  public:
    /**Add point to collection*/
    void AddPoint(TVirtualMC* aMC, const Int_t);
    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated("Use AddPoint(TVirtualMC*, ...)")]] void AddPoint(const Int_t ModuleId);
    /**initialize the manager*/
    void Init();
    /**reset*/
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadMapManager object, created
     * with FairRadMapManager::FairRadMapManager().
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] static FairRadMapManager* Instance();
    //  void GetGeoManager();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairRingSorter.h
 *
 *  Created on: Jul 15, 2010
 *      Author: stockman
 */

#ifndef FairRingSorter_H_
#define FairRingSorter_H_

#include <Rtypes.h>    // for FairRingSorter::Class, etc
#include <TObject.h>   // for TObject
#include <iostream>    // for operator<<, ostream, etc
#include <map>         // for multimap
#include <utility>     // for pair
#include <vector>      // for vector

class FairTimeStamp;

class FairRingSorter : public TObject
{
  public:
    FairRingSorter(int size = 100, double width = 10)
        : TObject()
        , fRingBuffer(size)
        , fOutputData()
        , fLowerBoundPointer(0, 0)
        , fCellWidth(width)
        , fVerbose(0)
    {}

    virtual ~FairRingSorter(){};

    virtual FairTimeStamp* CreateElement(FairTimeStamp* data);

    virtual void AddElement(FairTimeStamp* digi, double timestamp);
    virtual void WriteOutElements(int index);   ///< writes out the entries from LowerBoundPointer up to index
    virtual void WriteOutElement(int index);    ///< writes out the entry at the index and clears it
    virtual void WriteOutAll() { WriteOutElements(fLowerBoundPointer.first); }
    virtual double GetBufferSize() { return fCellWidth * fRingBuffer.size(); }
    virtual std::vector<FairTimeStamp*> GetOutputData() { return fOutputData; }

    virtual void DeleteOutputData() { fOutputData.clear(); }
    virtual void SetLowerBound(double timestampOfHitToWrite);

    virtual void print(std::ostream& out = std::cout)
    {
        out << "RingSorter: Size " << fRingBuffer.size() << " CellWidth: " << fCellWidth << "\n";
        out << "LowerBoundPointer at index: " << fLowerBoundPointer.first << " Time: " << fLowerBoundPointer.second
            << "\n";
        out << "| ";
        for (unsigned int i = 0; i < fRingBuffer.size(); i++) {
            out << fRingBuffer[i].size() << " |";
        }
        out << std::endl;
    }

  private:
    int CalcIndex(double val);
    std::vector<std::multimap<double, FairTimeStamp*>> fRingBuffer;
    std::vector<FairTimeStamp*> fOutputData;
    std::pair<int, double> fLowerBoundPointer;
    double fCellWidth;
    int fVerbose;

    ClassDef(FairRingSorter, 1);
};

#endif /* FairRingSorter_H_ */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

/** FairRingSorterTask.h
 **
 **/

#ifndef FairRingSorterTask_H
#define FairRingSorterTask_H

#include "FairRingSorter.h"   // for FairRingSorter
#include "FairTask.h"         // for FairTask, InitStatus

#include <Rtypes.h>    // for Bool_t, Int_t, kTRUE, etc
#include <TString.h>   // for TString

class FairTimeStamp;
class TClonesArray;

class FairRingSorterTask : public FairTask
{
  public:
    /** Default constructor **/
    FairRingSorterTask()
        : FairTask("SorterTask")
        , fSorter(0)
        , fPersistance(kTRUE)
        , fDigiPixelMCInfo(kFALSE)
        , fNumberOfCells(1000)
        , fWidthOfCells(10)
        , fInputBranch()
        , fInputArray(0)
        , fOutputBranch()
        , fFolder()
        , fOutputArray(0)
        , fEntryNr(0)
    {
        SetVerbose(0);
    }

    /** Named constructor **/
    FairRingSorterTask(const char* name)
        : FairTask(name)
        , fSorter(0)
        , fPersistance(kTRUE)
        , fDigiPixelMCInfo(kFALSE)
        , fNumberOfCells(1000)
        , fWidthOfCells(10)
        , fInputBranch()
        , fInputArray(0)
        , fOutputBranch()
        , fFolder()
        , fOutputArray(0)
        , fEntryNr(0)
    {
        SetVerbose(0);
    }

    FairRingSorterTask(Int_t numberOfCells,
                       Double_t widthOfCells,
                       TString inputBranch,
                       TString outputBranch,
                       TString folderName)
        : FairTask("Sorter")
        , fSorter(0)
        , fPersistance(kTRUE)
        , fDigiPixelMCInfo(kFALSE)
        , fNumberOfCells(numberOfCells)
        , fWidthOfCells(widthOfCells)
        , fInputBranch(inputBranch)
        , fInputArray(0)
        , fOutputBranch(outputBranch)
        , fFolder(folderName)
        , fOutputArray(0)
        , fEntryNr(0)
    {
        SetVerbose(0);
    }

    /** Destructor **/
    ~FairRingSorterTask() override { delete fSorter; }

    /** Virtual method Init **/
    InitStatus Init() override;
    InitStatus ReInit() override;

    /** Virtual method Exec **/
    void Exec(Option_t* opt) override;
    void FinishEvent() override;
    void FinishTask() override;

    void SetPersistance(Bool_t p = kTRUE) { fPersistance = p; };
    Bool_t GetPersistance() { return fPersistance; };

    virtual void AddNewDataToTClonesArray(FairTimeStamp* data);
    virtual FairRingSorter* InitSorter(Int_t numberOfCells, Double_t widthOfCells) const;

  protected:
    FairRingSorter* fSorter;
    /** switch to turn on/off storing the arrays to a file*/
    Bool_t fPersistance;
    /** switch to turn on/off storing additional MC Info of Digis*/
    Bool_t fDigiPixelMCInfo;
    Int_t fNumberOfCells;
    Double_t fWidthOfCells;   // in ns
    /** Input array of PndSdsPixelDigis **/
    TString fInputBranch;
    TClonesArray* fInputArray;
    /** Output array of sorted PndSdsDigis **/
    TString fOutputBranch;
    TString fFolder;
    TClonesArray* fOutputArray;
    Int_t fEntryNr;
    FairRingSorterTask(const FairRingSorterTask&);
    FairRingSorterTask& operator=(const FairRingSorterTask&);

    ClassDefOverride(FairRingSorterTask, 2);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_ROOT_MANAGER_H
#define FAIR_ROOT_MANAGER_H

#include "FairLogger.h"
#include "FairSink.h"
#include "FairSource.h"

#include <Rtypes.h>      // for Bool_t, Int_t, UInt_t, etc
#include <TChain.h>      // for TChain
#include <TObject.h>     // for TObject
#include <TRefArray.h>   // for TRefArray
#include <TString.h>     // for TString, operator<
#include <map>           // for map, multimap, etc
#include <memory>
#include <string>
#include <type_traits>   // is_pointer, remove_pointer, is_const, remove...
#include <typeinfo>
#include <vector>

class BinaryFunctor;
class FairEventHeader;
class FairFileHeader;
class FairLink;
class FairTSBufferFunctional;
class FairWriteoutBuffer;
class TBranch;
class TClonesArray;
class TObjArray;
class TCollection;
class TFile;
class TFolder;
class TList;
class TNamed;
class TTree;

/**
 * I/O Manager class
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairRootManager : public TObject
{
  public:
    /**dtor*/
    ~FairRootManager() override;
    Bool_t AllDataProcessed();
    /** Add a branch name to the Branchlist and give it an id*/
    Int_t AddBranchToList(const char* name);
    /**
    Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist   */
    Int_t CheckBranch(const char* BrName);

    void CloseSink()
    {
        if (fSink) {
            fSink->Close();
        }
    }
    /**Create a new file and save the current TGeoManager object to it*/
    void CreateGeometryFile(const char* geofile);
    void Fill();
    void LastFill();
    TClonesArray* GetEmptyTClonesArray(TString branchName);
    TClonesArray* GetTClonesArray(TString branchName);
    /**Update the list of Memory branches from the source used*/
    void UpdateBranches();

    /**Return branch name by Id*/
    TString GetBranchName(Int_t id);
    /**Return Id of a branch named */
    Int_t GetBranchId(TString const& BrName);

    /**The MCTrack branch stands out since it is required by the framework algorithms**/
    Int_t GetMCTrackBranchId() const { return fMCTrackBranchId; }

    /**Return a TList of TObjString of branch names available in this session*/
    TList* GetBranchNameList() { return fBranchNameList; }

    /**  Get the Object (container) for the given branch name,
         this method can be used to access the data of
         a branch that was created from a different
         analysis task, and not written in the tree yet.
         the user have to cast this pointer to the right type.
         Return a pointer to the object (collection) saved in the fInChain branch named BrName*/
    TObject* GetObject(const char* BrName);

    /// Initializes and returns a default object for a branch or looks it up when it exists already.
    /// Returns nullptr when the branch does not exist or looking up with wrong type.
    /// The name Init indicates that this functions should be called only in Init sections of FairTasks.
    /// The returned default object will be filled with data by the framework.
    template<typename T>
    T InitObjectAs(const char* BrName);

    /** Return a pointer to the object (collection) saved in the fInTree branch named BrName*/
    Double_t GetEventTime();
    /** Returns a clone of the data object the link is pointing to. The clone has to be deleted in the calling code! */
    TObject* GetCloneOfLinkData(const FairLink link);
    /** Get the data of the given branch name,
     *  this method runs over multiple entries
     *  of the tree and selects the data according
     *  to the function and the parameter given.
     */

    TClonesArray* GetCloneOfTClonesArray(const FairLink link);

    void InitTSBuffer(TString branchName, BinaryFunctor* function);
    TClonesArray* GetData(TString branchName, BinaryFunctor* function, Double_t parameter);
    TClonesArray* GetData(TString branchName,
                          BinaryFunctor* startFunction,
                          Double_t startParameter,
                          BinaryFunctor* stopFunction,
                          Double_t stopParameter);
    void RegisterTSBuffer(TString branchName, FairTSBufferFunctional* functionalBuffer)
    {
        fTSBufferMap[branchName] = functionalBuffer;
    }
    void TerminateTSBuffer(TString branchName);
    void TerminateAllTSBuffer();
    FairTSBufferFunctional* GetTSBuffer(TString branchName) { return fTSBufferMap[branchName]; }

    /** static access method */
    static FairRootManager* Instance();

    /**Read a single entry from background chain*/
    Int_t ReadEvent(Int_t i = 0);
    /** Read a single entry from each branch that is not read via TSBuffers*/
    Int_t ReadNonTimeBasedEventFromBranches(Int_t i = 0);
    /**Read the tree entry on one branch**/
    void ReadBranchEvent(const char* BrName);
    /**Read the tree entry on one branch for a specific entry**/
    void ReadBranchEvent(const char* BrName, Int_t entry);

    /**Read all entries from input tree(s) with time stamp from current time to dt (time in ns)*/

    Int_t GetRunId();

    Bool_t ReadNextEvent(Double_t dt);
    /**create a new branch in the output tree
     *@param name            Name of the branch to create
     *@param Foldername      Folder name containing this branch (e.g Detector name)
     *@param obj             Pointer of type TNamed (e.g. MCStack object)
     *@param toFile          if kTRUE, branch will be saved to the tree*/
    void Register(const char* name, const char* Foldername, TNamed* obj, Bool_t toFile);
    /**create a new branch in the output tree
     *@param name            Name of the branch to create
     *@param Foldername      Folder name containing this branch (e.g Detector name)
     *@param obj             Pointer of type TCollection (e.g. TClonesArray of hits, points)
     *@param toFile          if kTRUE, branch will be saved to the tree*/
    void Register(const char* name, const char* Foldername, TCollection* obj, Bool_t toFile);

    /** create a new branch based on an arbitrary type T (for which a dictionary must exist) **/
    template<typename T>
    void RegisterAny(const char* name, T*& obj, Bool_t toFile);

    void RegisterInputObject(const char* name, TObject* obj);

    TClonesArray* Register(TString branchName, TString className, TString folderName, Bool_t toFile);
    /** Register a new FairWriteoutBuffer to the map. If a Buffer with the same map key already exists the given buffer
     * will be deleted and the old will be returned!*/
    FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer);
    /**Update the list of time based branches in the output file*/
    void UpdateListOfTimebasedBranches();
    /**Use time stamps to read data and not tree entries
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] void RunWithTimeStamps() {}

    /**Set the branch name list*/
    void SetBranchNameList(TList* list);
    /** Replace the time based branch name list*/
    void SetTimeBasedBranchNameList(TList* list);

    /** \deprecated Deprecated in v18.8, will be removed in v20. */
    [[deprecated]] void FillEventHeader(FairEventHeader* feh)
    {
        if (fSource)
            fSource->FillEventHeader(feh);
    }

    /**Enables a last Fill command after all events are processed to store any data which is still in Buffers*/
    void SetLastFill(Bool_t val = kTRUE) { fFillLastData = val; }
    /**When creating TTree from TFolder the fullpath of the objects is used as branch names
     * this method truncate the full path from the branch names
     */

    Int_t Write(const char* name = nullptr, Int_t option = 0, Int_t bufsize = 0) override;
    /** Write the current TGeoManager to file*/
    void WriteGeometry();
    /**Write the file header object to the output file*/
    void WriteFileHeader(FairFileHeader* f);
    /**Write the folder structure used to create the tree to the output file */
    void WriteFolder();

    /**Check the maximum event number we can run to*/
    Int_t CheckMaxEventNo(Int_t EvtEnd = 0);

    void StoreWriteoutBufferData(Double_t eventTime);
    void StoreAllWriteoutBufferData();
    void DeleteOldWriteoutBufferData();

    Int_t GetEntryNr() { return fEntryNr; }
    void SetEntryNr(Int_t val) { fEntryNr = val; }

    void SetUseFairLinks(Bool_t val) { fUseFairLinks = val; };
    Bool_t GetUseFairLinks() const { return fUseFairLinks; };

    /**
     * @param Status : if  true all inputs are mixed, i.e: each read event will take one entry from each input and put
     * them in one big event and send it to the next step
     */
    /* void SetMixAllInputs(Bool_t Status) { */
    /*    fMixAllInputs=kTRUE; */
    /* } */

    /** These methods have been moved to the FairFileSource */
    void SetSource(FairSource* tempSource) { fSource = tempSource; }
    FairSource* GetSource() { return fSource; }
    Bool_t InitSource();

    void SetSink(FairSink* tempSink) { fSink = tempSink; }
    FairSink* GetSink() { return fSink; }
    Bool_t InitSink();

    void SetListOfFolders(TObjArray* ta) { fListFolder = ta; }
    TChain* GetInChain() { return fSourceChain; }
    TChain* GetSignalChainNo(UInt_t i) { return fSignalChainList[i]; }
    TTree* GetInTree()
    {
        if (fSourceChain)
            return fSourceChain->GetTree();
        return 0;
    }
    const TFile* GetRootFile()
    {
        if (fSourceChain)
            return fSourceChain->GetFile();
        return 0;
    }
    TFile* GetInFile()
    {
        if (fSourceChain)
            return fSourceChain->GetFile();
        return 0;
    }
    void SetInChain(TChain* tempChain, Int_t ident = -1);
    /* /\**Set the input tree when running on PROOF worker*\/ */

    void SetFinishRun(Bool_t val = kTRUE) { fFinishRun = val; }
    Bool_t FinishRun() { return fFinishRun; }

    static void SetTreeName(const std::string& tname) { fTreeName = tname; }
    static void SetFolderName(const std::string& tname) { fFolderName = tname; }

    const static char* GetTreeName();
    const static char* GetFolderName();

    /**public Members for multi-threading */
    Int_t GetInstanceId() const { return fId; }
    void UpdateFileName(TString& fileName);

    /** Return a pointer to the output File of type TFile */
    TFile* GetOutFile();
    /** Return a pointer to the output tree of type TTree */
    TTree* GetOutTree();

    /**Read one event from source to find out which RunId to use*/
    Bool_t SpecifyRunId();

  private:
    // helper struct since std::pair has problems with type_info
    struct TypeAddressPair
    {
        TypeAddressPair(const std::type_info& oi, const std::type_info& pi, void* a)
            : origtypeinfo(oi)
            , persistenttypeinfo(pi)
            , ptraddr(a)
        {}
        const std::type_info& origtypeinfo;         // type_info of type addr points to
        const std::type_info& persistenttypeinfo;   // type_info of ROOT persistent branch (drops pointers)
        void* ptraddr;                              // address of a pointer (pointing to origtypeinfo);
    };

    /**private methods*/
    /**ctor*/
    FairRootManager();
    FairRootManager(const FairRootManager&);
    FairRootManager& operator=(const FairRootManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/
    TObject* ActivateBranch(const char* BrName);
    void AddFriends();
    /**Add a branch to memory, it will not be written to the output files*/
    void AddMemoryBranch(const char*, TObject*);

    template<typename T>
    void AddMemoryBranchAny(const char* name, T** obj);
    template<typename T>
    T GetMemoryBranchAny(const char* name) const;

    template<typename T>
    void RegisterImpl(const char* name, const char* Foldername, T* obj, Bool_t toFile);

    /** Internal Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist
    */
    Int_t CheckBranchSt(const char* BrName);
    /**Create the Map for the branch persistency status  */
    void CreatePerMap();
    TObject* GetMemoryBranch(const char*);
    //   void                GetRunIdInfo(TString fileName, TString inputLevel);

    FairWriteoutBuffer* GetWriteoutBuffer(TString branchName);

    // private helper function to emit a warning
    void EmitMemoryBranchWrongTypeWarning(const char* brname, const char* typen1, const char* typen2) const;

    /**private Members*/
    Int_t fOldEntryNr;
    /**folder structure of output*/
    TFolder* fOutFolder;
    /**folder structure of input*/
    TFolder* fRootFolder;
    /** current time in ns*/
    Double_t fCurrentTime;
    TObject** fObj2;   //!
    /** Counter for the number of branches activiated */
    Int_t fNObj;   //!
    /** A list which hold the pointer to the branch
     * and the name of the branch in memory, it contains all branches (TClonesArrays)
     * persistance and Memory only branches
     */
    std::map<TString, TObject*> fMap;   //!

    /**folder name variable*/
    static std::string fFolderName;   //!
    /**tree name variable*/
    static std::string fTreeName;   //!
    static std::string GetNameFromFile(const char* namekind);

    /// A map of branchnames to typeinformation + memory address;
    /// used for branches registered with RegisterAny; use of ptr here
    /// since type_info cannot be copied
    std::map<std::string, std::unique_ptr<TypeAddressPair const>> fAnyBranchMap;   //!

    /**Branch id for this run */
    Int_t fBranchSeqId;
    /**List of branch names as TObjString*/
    TList* fBranchNameList;   //!

    /**The branch ID for the special (required) MCTrack branch**/
    Int_t fMCTrackBranchId;   //!

    /**List of Time based branchs names as TObjString*/
    TList* fTimeBasedBranchNameList;   //!
    /** Internally used to compress empty slots in data buffer*/
    std::map<TString, TClonesArray*> fActiveContainer;
    /** Internally used to read time ordered data from branches*/
    std::map<TString, FairTSBufferFunctional*> fTSBufferMap;     //!
    std::map<TString, FairWriteoutBuffer*> fWriteoutBufferMap;   //!
    std::map<Int_t, TBranch*> fInputBranchMap;                   //!    //Map of input branch ID with TBranch pointer
    /**Flag for creation of Map for branch persistency list  */
    Bool_t fBranchPerMap;
    /** Map for branch persistency list */
    std::map<TString, Int_t> fBrPerMap;   //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t fCurrentEntryNo;   //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t fTimeforEntryNo;   //!
    Bool_t fFillLastData;     //!
    Int_t fEntryNr;           //!

    TObjArray* fListFolder;   //!

    FairSource* fSource;

    TChain* fSourceChain = nullptr;
    std::map<UInt_t, TChain*> fSignalChainList;   //!

    FairEventHeader* fEventHeader;

    FairSink* fSink;

    Bool_t fUseFairLinks;   //!
    Bool_t fFinishRun;      //!
    /** List of branches used with no-time stamp in time-based session */
    TRefArray fListOfNonTimebasedBranches{};   //!

    /**private Members for multi-threading */
    // global static data members
    static Int_t fgCounter;   // The counter of instances
    // data members
    Int_t fId;   // This manager ID

    ClassDefOverride(FairRootManager, 14);
};

// FIXME: move to source since we can make it non-template dependent
template<typename T>
void FairRootManager::AddMemoryBranchAny(const char* brname, T** obj)
{
    if (fAnyBranchMap.find(brname) == fAnyBranchMap.end()) {
        auto& ot = typeid(T*);
        auto& pt = typeid(T);
        fAnyBranchMap[brname] = std::unique_ptr<TypeAddressPair const>(new TypeAddressPair(ot, pt, (void*)obj));
    }
}

// try to retrieve an object address from the registered branches/names
template<typename T>
T FairRootManager::GetMemoryBranchAny(const char* brname) const
{
    static_assert(std::is_pointer<T>::value, "Return type of GetMemoryBranchAny has to be a pointer");
    using P = typename std::remove_pointer<T>::type;
    auto iter = fAnyBranchMap.find(brname);
    if (iter != fAnyBranchMap.end()) {
        // verify type consistency
        if (typeid(P).hash_code() != iter->second->origtypeinfo.hash_code()) {
            EmitMemoryBranchWrongTypeWarning(brname, typeid(P).name(), iter->second->origtypeinfo.name());
            return nullptr;
        }
        return static_cast<T>(iter->second->ptraddr);
    }
    return nullptr;
}

template<typename T>
void FairRootManager::RegisterAny(const char* brname, T*& obj, bool persistence)
{
    AddBranchToList(brname);
    // we are taking the address of the passed pointer
    AddMemoryBranchAny<T>(brname, &obj);
    if (persistence) {
        auto& ot = typeid(T*);
        auto& pt = typeid(T);
        if (fSink)
            fSink->RegisterAny(brname, ot, pt, &obj);
        else
            LOG(fatal) << "The sink does not exist to store persistent branches.";
    }
}

// this function serves as a factory (or lookup) for memory managed
// instances associated to branches
// it returns a pointer to unmodifiable instance of T
template<typename TPtr>
TPtr FairRootManager::InitObjectAs(const char* brname)
{
    static_assert(std::is_pointer<TPtr>::value, "Return type of GetObjectAs has to be a pointer");
    using X = typename std::remove_pointer<TPtr>::type;
    static_assert(std::is_const<X>::value, "Return type of GetObjectAs has to be pointer to const class");
    using T = typename std::remove_const<X>::type;

    // is there already an object associated to the branch in memory??
    // then just return
    T** obj = GetMemoryBranchAny<T**>(brname);
    // obj is some address/instance holding TPtr instances
    if (obj != nullptr)
        return *obj;

    if (!fSource) {
        return nullptr;
    }

    // it does not seem to be the case, let us create the pointer which will be initialized
    // with the data (pointer to T)
    T** addr = new T*;
    // init the pointee to a default obj which we can return
    (*addr) = new T;
    // try to find and activate in the source
    auto succeeded = fSource->ActivateObjectAny((void**)addr, typeid(T), brname);

    if (!succeeded) {
        delete (*addr);
        delete addr;
        return nullptr;
    }
    // add into branch list
    AddMemoryBranchAny<T>(brname, addr);

    // NOTE: ideally we would do proper resource management for addr and *addr
    // since the FairRootManager becomes owner of these pointers/instances; Unfortunately this
    // is quite a difficult task since we would have to store something like std::unique_ptr<T> in a member
    // container which we cannot know a priori; Some solutions we could think of in the future are
    // a) use the Destructor mechanism of ROOT::TClass since we still have the type info.
    // b) investigate if boost::any could be of help here
    // In any case, this problem is not very critical in the sense that FairRootManager is a singleton and hence
    // cannot really leak memory (Assuming that the destructors of T are not doing something non-trivial).
    return *addr;
}

#endif   // FAIR_ROOT_MANAGER_H
/********************************************************************************
 * Copyright (C) 2014-2023 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUN_H
#define FAIRRUN_H

#include "FairAlignmentHandler.h"
#include "FairEventHeader.h"
#include "FairSink.h"
#include "FairSource.h"

#include <Rtypes.h>   // for Int_t, Bool_t, etc
#include <TMCtls.h>   // for multi-threading
#include <TNamed.h>   // for TNamed
#include <TString.h>
#include <map>
#include <memory>
#include <string>

class FairEventHeader;
class FairFileHeader;
class FairRootManager;
class FairRuntimeDb;
class FairSink;
class FairTask;
class TFile;
class FairField;
class TGeoHMatrix;

/**
 * Configure the Simuation or Analysis
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairRun : public TNamed
{
    friend class FairMCApplication;

  public:
    /**
     * default ctor
     */
    FairRun(Bool_t isMaster = kTRUE);
    /**
     * default dtor
     */
    ~FairRun() override;
    /**
     * static instance
     */
    static FairRun* Instance();
    /**
     * Add a FAIRTask to the simulation or analysis
     */
    virtual void AddTask(FairTask* t);
    virtual void StoreTaskNames(const FairTask* t);
    virtual void SetTask(FairTask* t);
    /**
     * Initialize the Simulation or analysis
     */
    virtual void Init() = 0;
    /*
     * Get the magnetic field *
     */
    virtual FairField* GetField() = 0;
    /**
     * run the analysis or simulation
     */
    virtual void Run(Int_t NStart = 0, Int_t NStop = 0) = 0;
    /**
     *       Set the experiment dependent run header
     *       for each run
     */
    void SetEventHeader(FairEventHeader* EvHeader) { fEvtHeader = EvHeader; }
    /**
     * return a pointer to the RuntimeDB
     */
    FairRuntimeDb* GetRuntimeDb() { return fRtdb; }
    /**
     * Set the sink
     */
    void SetSink(std::unique_ptr<FairSink> newsink);
    void SetSink(FairSink* tempSink);
    /**
     * return a non-owning pointer to the sink
     */
    FairSink* GetSink() { return fSink.get(); }
    /**
     * return the run ID for the actul run
     */
    Int_t GetRunId() { return (static_cast<Int_t>(fRunId)); }

    /**
     * Set the Run ID
     */
    void SetRunId(UInt_t runId) { fRunId = runId; }

    /**Get the detector specific run header*/
    FairEventHeader* GetEventHeader();
    /**
     * return true for Anaylsis session
     */
    Bool_t IsAna() { return fAna; }
    /**
     *Get task by name
     */

    FairTask* GetTask(const char* taskName);
    /**
     *Get Main Task
     */
    FairTask* GetMainTask() { return fTask; }
    /**
     * Return the number of Tasks added to this Run
     */
    Int_t GetNTasks() { return fNTasks; }

    /**Create a new file and save the TGeoManager to it*/
    void CreateGeometryFile(const char* geofile);

    /**
     * Set if RunInfo file should be written
     * \deprecated Use SetGenerateRunInfo() instead.
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] void SetWriteRunInfoFile(Bool_t write);

    //** Set if RunInfo should be generated */
    void SetGenerateRunInfo(Bool_t write) { fGenerateRunInfo = write; }

    /**
     * Get info if RunInfo file is written
     * \deprecated Use \ref IsRunInfoGenerated() instead.
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] Bool_t GetWriteRunInfoFile();

    //** Get info if RunInfo file is written */
    Bool_t IsRunInfoGenerated() { return fGenerateRunInfo; }

    //** Switches the use of FairLinks */
    void SetUseFairLinks(Bool_t val);

    //** Get info if run on master */
    Bool_t GetIsMaster() const { return fIsMaster; }

    //** Mark/Unmark event to be filled into output. Default is TRUE. */
    void MarkFill(Bool_t flag) { fMarkFill = flag; }

    //** Get option string */
    TString GetOptions() { return fOptions; };

    //** Set option string */
    void SetOptions(const TString& s) { fOptions = s; };

    /**
     * Set the output file name for analysis or simulation
     * \deprecated Use \ref FairSink and \ref SetSink().
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] virtual void SetOutputFile(const char* fname);
    /**
     * Set the output file for analysis or simulation
     * \deprecated Use \ref FairSink and \ref SetSink().
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] virtual void SetOutputFile(TFile* f);
    /**
     * Set the  output file name without creating the file
     * \deprecated Use \ref FairSink and \ref SetSink().
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] void SetOutputFileName(const TString& name);
    /**
     * \deprecated Use \ref FairSink and \ref SetSink().
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] TFile* GetOutputFile();

    /**
     * New functions which allow to postpone creating a new Sink in MT
     * to be kept after clean-up of deprecated functions above
     */
    void SetUserOutputFileName(const TString& name);
    TString GetUserOutputFileName() const;

    void AddAlignmentMatrices(const std::map<std::string, TGeoHMatrix>& alignmentMatrices, bool invertMatrices = false);

    /**
     * \brief Set the input signal file
     *
     * Takes an owning pointer!
     */
    virtual void SetSource(FairSource* tempSource);
    /** Return non-owning pointer to source **/
    FairSource* GetSource() { return fSource.get(); }
    FairRootManager& GetRootManager() { return *fRootManager; }
    FairRootManager const& GetRootManager() const { return *fRootManager; }

  private:
    FairRun(const FairRun& M);
    FairRun& operator=(const FairRun&) { return *this; }
    /** Number of Tasks added*/
    Int_t fNTasks;

  protected:
    /** static pointer to this run*/
    static TMCThreadLocal FairRun* fRunInstance;
    /** RuntimeDb*/
    FairRuntimeDb* fRtdb;
    /** Tasks used*/
    FairTask* fTask;
    /**IO manager */
    FairRootManager* fRootManager;
    /**Output sink*/
    std::unique_ptr<FairSink> fSink{};   //!
    /**Output file name set by user*/
    TString fUserOutputFileName;
    /**Options for derived classes, to be set & parsed by user*/
    TString fOptions;
    /**Run Id*/
    UInt_t fRunId;   //!
    /** true for Anaylsis session*/
    Bool_t fAna;   //!
    /** MC Event Header */
    FairEventHeader* fEvtHeader;   //!
    /** File  Header */
    FairFileHeader* fFileHeader;
    /** true if RunInfo file should be written*/
    Bool_t fGenerateRunInfo;   //!
    /** true if on master*/
    Bool_t fIsMaster;   //!

    Bool_t fMarkFill;   //!

    FairAlignmentHandler fAlignmentHandler;

    std::unique_ptr<FairSource> fSource{};   //!

    void AlignGeometry() const;
    /**
     * Call FillEventHeader on the source
     */
    void FillEventHeader()
    {
        if (fSource)
            fSource->FillEventHeader(fEvtHeader);
    }

    /**
     * Get the RunId of the Event Header
     */
    UInt_t GetEvtHeaderRunId() const { return fEvtHeader->GetRunId(); }

    ClassDefOverride(FairRun, 5);
};
#endif   // FAIRRUN_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANA_H
#define FAIRRUNANA_H

/**
 * Configure and manage the  Analysis
 * @author M. Al-Turany D. Bertini
 * @version 0.1
 * @since 28.02.05
 */

#include "FairRootManager.h"   // for FairRootManager
#include "FairRun.h"           // for FairRun
#include "FairRunInfo.h"       // for FairRunInfo

#include <Rtypes.h>    // for Bool_t, Double_t, UInt_t, etc
#include <TString.h>   // for TString

class FairField;
class TF1;
class TFile;

class FairSource;
class FairFileSource;
class FairMixedSource;

class FairRunAna : public FairRun
{

  public:
    static FairRunAna* Instance();
    virtual ~FairRunAna();
    FairRunAna();
    /**initialize the run manager*/
    void Init() override;
    /**Run from event number NStart to event number NStop */
    void Run(Int_t NStart = 0, Int_t NStop = 0) override;
    /**Run over the whole input file with timpe window delta_t as unit (entry)*/
    void Run(Double_t delta_t);
    /**Run for the given single entry*/
    void Run(Long64_t entry);
    /**Run event reconstruction from event number NStart to event number NStop */
    void RunEventReco(Int_t NStart, Int_t NStop);
    /**Run over all TSBuffers until the data is processed*/
    void RunTSBuffers();
    /** the dummy run does not check the evt header or the parameters!! */
    void DummyRun(Int_t NStart, Int_t NStop);
    /** This methode is only needed and used with ZeroMQ
     * it read a certain event and call the task exec, but no output is written
     * @param entry : entry number in the tree
     */
    void RunMQ(Long64_t entry);
    /** Run on a list of lmd files*/
    void RunOnLmdFiles(UInt_t NStart = 0, UInt_t NStop = 0);

    void RunOnTBData();
    /** finish tasks, write output*/
    void TerminateRun();

    /** Switch On/Off the storing of FairEventHeader in output file*/
    void SetEventHeaderPersistence(Bool_t flag) { fStoreEventHeader = flag; }

    void Reinit(UInt_t runId);
    UInt_t getRunId() { return fRunId; }
    /** Get the magnetic field **/
    FairField* GetField() override { return fField; }
    /** Set the magnetic Field */
    void SetField(FairField* ffield) { fField = ffield; }
    /** Set external geometry file */
    void SetGeomFile(const char* GeoFileName);
    /** Return a pointer to the geometry file */
    TFile* GetGeoFile() { return fInputGeoFile; }
    /** Initialization of parameter container is set to static, i.e: the run id is
     *  is not checked anymore after initialization
     */

    void SetContainerStatic(Bool_t tempBool = kTRUE);
    Bool_t GetContainerStatic() { return fStatic; };
    void RunWithTimeStamps();
    Bool_t IsTimeStamp() { return fTimeStamps; }

    /** Set the flag for proccessing lmd files */
    void StopProcessingLMD(void) { fFinishProcessingLMDFile = kTRUE; }
    /** Get the status of lmd file proccessing */
    Bool_t GetLMDProcessingStatus(void) { return fFinishProcessingLMDFile; }

  protected:
    /**
     * Virtual function which calls the Fill function of the IOManager.
     * Allows to override the function with an experiment specific version.
     **/
    virtual void Fill();

  private:
    FairRunAna(const FairRunAna& M);
    FairRunAna& operator=(const FairRunAna&) { return *this; }

    FairRunInfo fRunInfo;   //!

  protected:
    /** This variable became true after Init is called*/
    Bool_t fIsInitialized;
    TFile* fInputGeoFile;
    static FairRunAna* fgRinstance;
    Bool_t fLoadGeo;
    /** true for static initialisation of parameters */
    Bool_t fStatic;   //!
    FairField* fField;
    Bool_t fTimeStamps;
    Bool_t fInFileIsOpen;   //!
    /** min time for one event (ns) */
    Double_t fEventTimeMin;   //!
    /** max time for one Event (ns) */
    Double_t fEventTimeMax;   //!
    /** Time of event since th start (ns) */
    Double_t fEventTime;   //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t fEventMeanTime;   //!
    /** used to generate random numbers for event time; */
    TF1* fTimeProb;   //!
    /** Flag for proccessing lmd-files*/
    Bool_t fFinishProcessingLMDFile;   //!

    /** Temporary member to preserve old functionality without setting source in macro */
    FairFileSource* fFileSource;   //!
    /** Temporary member to preserve old functionality without setting source in macro */
    FairMixedSource* fMixedSource;   //!
    /** Flag for Event Header Persistency */
    Bool_t fStoreEventHeader;   //!

    ClassDefOverride(FairRunAna, 6);
};

#endif   // FAIRRUNANA_H
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNSIM_H
#define FAIRRUNSIM_H

#include "FairGenericVMCConfig.h"
#include "FairIon.h"             // for FairIon
#include "FairMCApplication.h"   // for FairMCApplication
#include "FairParticle.h"        // for FairParticle
#include "FairRun.h"             // for FairRun

#include <Rtypes.h>      // for Bool_t, Double_t, Int_t, etc
#include <TMCtls.h>      // for multi-threading
#include <TObjArray.h>   // for TObjArray
#include <TString.h>     // for TString
#include <functional>
#include <memory>
#include <utility>

class FairField;
class FairMCEventHeader;
class FairMesh;
class FairModule;
class FairPrimaryGenerator;

/**
 * \brief Configure the Simulation session
 * \ingroup base_steer
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairRunSim : public FairRun
{
  public:
    /** default ctor*/
    FairRunSim(Bool_t isMaster = kTRUE);
    /** default dtor*/
    ~FairRunSim() override;
    /** Singelton instance*/
    static FairRunSim* Instance();
    /**
     *       Add a module to the simulation (e.g. PIPE, Magnet, ..etc)
     */
    void AddModule(FairModule* Mod);
    /**
     *       Add a user defined ion to the simulation
     */
    void AddNewIon(FairIon* ion) { fIons->Add(ion); }
    /**
     *       Add a user defined ion to the simulation
     */
    void AddNewParticle(FairParticle* Particle) { fParticles->Add(Particle); }
    /**
     *       this method is used by the FAIRMCApplication
     */
    TObjArray* GetUserDefIons();
    /**
     *       this method is used by the FAIRMCApplication
     */
    TObjArray* GetUserDefParticles();

    /**
     *       Initialize the Simulation
     */
    void Init() override;
    /**
     *       run the  simulation
     */
    void Run(Int_t NEvents = 0, Int_t NotUsed = 0) override;
    /**
     *       Set the magnetic that has to be used for simulation field
     */
    void SetField(FairField* field);
    /**
     *       Set the event generator that has to be used for simulation field
     */
    void SetGenerator(FairPrimaryGenerator* Gen);

    /**
     *       Set the experiment dependent event header
     *       for each Monte Carlo Event
     */
    void SetMCEventHeader(FairMCEventHeader* McHeader) { fMCEvHead = McHeader; }

    /** Set the material file name to be used */
    void SetMaterials(const char* MatFileName);

    /**switch On/Off the track visualisation */
    void SetStoreTraj(Bool_t storeTraj = kTRUE) { fStoreTraj = storeTraj; }

    /**Return the switch for the track visualisation */
    Bool_t GetStoreTraj() const { return fStoreTraj; }

    /**switch On/Off the debug mode */
    void SetTrackingDebugMode(Bool_t set)
    {
        if (fApp) {
            fApp->SetTrackingDebugMode(set);
        }
    }

    /**Set geometry builder*/
    void SetGeoModel(const char* name);

    /**return the geometry loader used in this session*/
    TString* GetGeoModel() { return &fLoaderName; }

    /**Get the field used in simulation*/
    FairField* GetField() override { return fField; }

    /**Get the detector specific event header*/
    FairMCEventHeader* GetMCEventHeader();

    /**return the full list of modules used in simulation*/
    TObjArray* GetListOfModules() { return ListOfModules; }

    /**Get the used primary generator*/
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    FairPrimaryGenerator* GetPrimaryGenerator() { return fGen; }
#pragma GCC diagnostic pop

    /**switch On/Off external decayer (Pythia) */
    void SetPythiaDecayer(Bool_t decayer) { fPythiaDecayer = decayer; }

    /**switch On external decayer (Pythia). Config macro will be used */
    void SetPythiaDecayer(const TString& Config);

    /**switch On user defined decay, Config  macro will be called  */
    void SetUserDecay(const TString& Config);

    /**switch On/Off user defined decay if true gconfig/UserDecay.C macro will be called  */
    void SetUserDecay(Bool_t decay) { fUserDecay = decay; }

    /**Flag for external decayer*/
    Bool_t IsExtDecayer() { return fPythiaDecayer; }

    /**Flag for User decay*/
    Bool_t IsUserDecay() { return fUserDecay; }

    /**Switch on/off Radiation length register */
    void SetRadLenRegister(Bool_t value) { fRadLength = value; }

    void SetRadMapRegister(Bool_t value) { fRadMap = value; }

    void SetRadGridRegister(Bool_t value) { fRadGrid = value; }

    void AddMesh(FairMesh* Mesh);

    void SetUserConfig(const TString& Config) { fUserConfig = Config; }
    TString GetUserConfig() { return fUserConfig; }

    void SetUserCuts(const TString& Cuts) { fUserCuts = Cuts; }
    TString GetUserCuts() { return fUserCuts; }

    /** Set Beam energy in GeV/c */
    void SetBeamMom(Double_t BeamMom)
    {
        fBeamMom = BeamMom;
        fUseBeamMom = kTRUE;
    }

    /** Get the Beam energy */
    Double_t GetBeamMom() { return fBeamMom; }

    /**Get beam energy flag */
    Bool_t UseBeamMom() { return fUseBeamMom; }
    void SetFieldContainer();

    void SetSimSetup(std::function<void()> f)
    {
        fSimSetup = f;
        fUseSimSetupFunction = true;
    }
    void SetSimSetupPostInit(std::function<void()> f)
    {
        fSimSetupPostInit = f;
        fUseSimSetupPostInitFunction = true;
    }

    void SetSimulationConfig(std::unique_ptr<FairGenericVMCConfig> tconf) { fSimulationConfig = std::move(tconf); }
    /**
     * Get non-owning pointer
     */
    FairGenericVMCConfig* GetSimulationConfig() { return fSimulationConfig.get(); }

    void SetIsMT(Bool_t isMT) { fIsMT = isMT; }
    Bool_t IsMT() const { return fIsMT; }

    void SetImportTGeoToVMC(Bool_t v) { fImportTGeoToVMC = v; }
    Bool_t IsImportTGeoToVMC() const { return fImportTGeoToVMC; }

    void StopMCRun() { fApp->StopMCRun(); }

    /**
     * Get non-owning pointer to FairMCApplication
     */
    auto GetMCApplication() { return fApp; }

  private:
    FairRunSim(const FairRunSim& M);
    FairRunSim& operator=(const FairRunSim&) { return *this; }
    void SetMCConfig();
    void CheckFlukaExec();

  protected:
    Int_t count{0};                     //!< Internal counter
    FairMCApplication* fApp{nullptr};   //!< Main VMC application
    Double_t fBeamMom{0};               //!< Beam Energy in GeV/c
    Bool_t fUseBeamMom{kFALSE};         //!< flag for use Beam Energy
    /**
     * Primary Event Generator
     *
     * \deprecated Use \ref GetPrimaryGenerator() / \ref SetGenerator()
     * \deprecated Deprecated in v18.8, will be removed in v19.2.
     */
    [[deprecated("Use Setter/Getter")]] FairPrimaryGenerator* fGen{nullptr};   //!

    FairMCEventHeader* fMCEvHead;                   //!                          /** MC Event Header */
    static TMCThreadLocal FairRunSim* fginstance;   //!              /** Singleton Instance */
    FairField* fField;                              /** Magnetic Field */
    TObjArray* fIons;                               //!                              /** Array of user defined ions */
    TObjArray* fParticles;                          //!                         /** Array of user defined particles*/
    TObjArray* ListOfModules;                       //!                       /** Array of used modules */
    TString MatFname;                               //!                           /** Material file name */
    Bool_t fStoreTraj;                              //!                       /** Trajectory store flags */
    TString fLoaderName{"TGeo"};                    //!< Geometry Model (TGeo or G3)
    Bool_t fPythiaDecayer;                          //!                    /** flag for using Pythia decayer*/
    TString fPythiaDecayerConfig;                   //!               /** Macro for Pythia decay configuration*/
    Bool_t fUserDecay;                              /** flag for setting user decay */
    TString fUserDecayConfig;                       //!                   /** Macro for decay configuration*/
    Bool_t fRadLength;                              //!                       /** flag for registring radiation length*/
    Bool_t fRadMap;                                 //!                            /** flag for RadiationMapManager
    Bool_t fRadGrid;                                //!
    TObjArray* fMeshList;                           //!                          /** radiation grid scoring
    TString fUserConfig;                            //!                        /** Macro for geant configuration*/
    TString fUserCuts;                              //!                          /** Macro for geant cuts*/
    Bool_t fIsMT;                                   //!                              /** MT mode option (Geant4 only)*/
    Bool_t fImportTGeoToVMC;                        //!                   /** Allow importing TGeometry to VMC */
    std::function<void()> fSimSetup;   //!                          /** A user provided function to do sim setup /
                                       //!                          instead of using macros **/
    bool fUseSimSetupFunction = false;
    std::function<void()> fSimSetupPostInit;   //!                          /** A user provided function to do sim setup
                                               //!                          / instead of using macros **/
    bool fUseSimSetupPostInitFunction = false;
    std::unique_ptr<FairGenericVMCConfig> fSimulationConfig{};   //!                 /** Simulation configuration */

    ClassDefOverride(FairRunSim, 2);
};

#endif   // FAIRRUNSIM_H
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairTask header file                      -----
// -----          Created 12/01/04  by M. Al-Turany / D. Bertini       -----
// -------------------------------------------------------------------------

/** FairTask
 * @author M. Al-Turany, Denis Bertini
 * @since 12.01.04
 **
 ** Base class for tasks in the cbmroot framework.
 ** Derived classes should implement the Exec method.
 **/

#ifndef FAIRTASK_H
#define FAIRTASK_H

#include <Rtypes.h>    // for Int_t, FairTask::Class, etc
#include <TString.h>   // for TString
#include <TTask.h>     // for TTask
#include <map>

class FairLogger;

enum InitStatus
{
    kSUCCESS,
    kERROR,
    kFATAL
};

/**
 * \ingroup base_steer
 */
class FairTask : public TTask
{
  public:
    /** Default constructor **/
    FairTask();

    /** Standard constructor
     *@param name        Name of task
     *@param iVerbose    Verbosity level
     **/
    FairTask(const char* name, Int_t iVerbose = 1);

    FairTask(const FairTask&) = delete;
    FairTask& operator=(const FairTask&) = delete;
    FairTask(FairTask&&) = delete;
    FairTask& operator=(FairTask&&) = delete;

    /** Destructor **/
    ~FairTask() override;

    /** Initialisation at begin of run. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void InitTask();

    /** Reinitialisation. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void ReInitTask();

    /** Set parameters. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void SetParTask();

    /** Action at end of run. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    virtual void FinishTask();

    /** Action at end of event. For this task and all of the subtasks. **/
    virtual void FinishEvent();

    /** Set verbosity level. For this task and all of the subtasks. **/
    void SetVerbose(Int_t iVerbose);

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] void SetInputPersistance(Bool_t val) { fInputPersistance = val; }
#pragma GCC diagnostic pop

    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] void CheckInputPersistance(TString branchName);

    void ExecuteTask(Option_t* option = "0") override;   // *MENU*

    /** Set persistency of branch with given name true or false
     *  In case is is set to false the branch will not be written to the output.
     **/
    void SetOutputBranchPersistent(TString, Bool_t);

    /** Check if the branch with the given name is persistent.
     *  If the branch is not in the map, the default return value is true.
     **/
    Bool_t IsOutputBranchPersistent(TString);

    void SetStreamProcessing(Bool_t val = kTRUE) { fStreamProcessing = val; }

  protected:
    Int_t fVerbose;                           //  Verbosity level
    [[deprecated]] Int_t fInputPersistance;   ///< \deprecated Deprecated in v18.8, will be removed in v20.
    FairLogger* fLogger;                      //!
    Bool_t fStreamProcessing;

    /** Intialisation at begin of run. To be implemented in the derived class.
     * \retval  kSUCCESS   If not kSUCCESS, task will be set inactive.
     **/
    virtual InitStatus Init() { return kSUCCESS; };

    /** Reinitialisation. To be implemented in the derived class.
     * \retval  kSUCCESS   If not kSUCCESS, task will be set inactive.
     **/
    virtual InitStatus ReInit() { return kSUCCESS; };

    /** Intialise parameter containers.
        To be implemented in the derived class.
    **/
    virtual void SetParContainers(){};

    /** Action at end of run. For this task and all of the subtasks.
        To be implemented in the derived class.
    **/
    virtual void Finish(){};

    /** Recursive intialisation of subtasks at begin of run **/
    void InitTasks();

    /** Recursive reinitialisation of subtasks **/
    void ReInitTasks();

    void ExecuteTasks(Option_t* option) override;

    /** Recursive parameter initialisation for subtasks **/
    void SetParTasks();

    /** Recursive finish of subtasks **/
    void FinishTasks();

    /** Recursive FinishEvent of subtasks **/
    void FinishEvents();

  private:
    std::map<TString, Bool_t> fOutputPersistance;

    ClassDefOverride(FairTask, 4);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// ********************************************* //
// ***        D. Kresan   2004-Sep-14        *** //
// ***        D.Kresan@gsi.de                *** //
// ********************************************* //

#ifndef FAIR_TRAJ_FILTER_H
#define FAIR_TRAJ_FILTER_H 1

#include <Rtypes.h>      // for Double_t, Bool_t, Int_t, etc
#include <TGeoTrack.h>   // IWYU pragma: keep needed by cint // TODO: is this still relevant for CINT?
#include <TMCtls.h>      // for multi-threading
#include <TMath.h>       // for Pi, TwoPi
#include <TString.h>     // for TString

class TClonesArray;
class TParticle;

/**
 * @class FairTrajFilter
 * The filter for storing of the trajectories.
 * This singleton class controls storing of trajectories
 * in the gGeoManager list during the simulation.
 * It is created, if FairRun::SetStoreTraj(kTRUE) was called
 * in the run macro
 * before the initialisation. The cuts should be applied
 * after initialisation and before run via
 * FairTrajFilter::Instance()->Set...Cut(...) methods.
 * Three modes of momentum cut (phase space, polar and decart reference systems),
 * are self-excluded. The last that was set, is applied in the simulation.
 * All other cuts are combined together.
 * @author D. Kresan
 * @version 0.1
 * @since 2004-Sep-15
 */

class FairTrajFilter
{
  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairTrajFilter class.
     * The pointer to this object can be reached via FairTrajFilter::Instance().
     */
    FairTrajFilter();

    /**
     * Destructor.
     */
    virtual ~FairTrajFilter();

    /**
     * Class definition.
     */
    ClassDef(FairTrajFilter, 1);

  private:
    FairTrajFilter(const FairTrajFilter&);
    FairTrajFilter& operator=(const FairTrajFilter&);

    static TMCThreadLocal FairTrajFilter* fgInstance;

    Double_t fVxMin;
    Double_t fVxMax;
    Double_t fVyMin;
    Double_t fVyMax;
    Double_t fVzMin;
    Double_t fVzMax;

    Double_t fPMin;
    Double_t fPMax;
    Double_t fThetaMin;
    Double_t fThetaMax;
    Double_t fPhiMin;
    Double_t fPhiMax;

    Double_t fPxMin;
    Double_t fPxMax;
    Double_t fPyMin;
    Double_t fPyMax;
    Double_t fPzMin;
    Double_t fPzMax;

    Double_t fPtMin;
    Double_t fPtMax;
    Double_t fRapidityMin;
    Double_t fRapidityMax;

    Int_t fKinCutType;

    Double_t fEtotMin;
    Double_t fEtotMax;

    Bool_t fStorePrim;
    Bool_t fStoreSec;

    Double_t fStepSizeMin;

    /**
     * collection of tracks
     */
    TClonesArray* fTrackCollection;

    TGeoTrack* fCurrentTrk;

  public:
    TGeoTrack* AddTrack(Int_t trackId, Int_t pdgCode);
    TGeoTrack* AddTrack(TParticle* p);
    TGeoTrack* CheckAddTrack(Int_t trackId, TParticle* p);
    TGeoTrack* GetCurrentTrk() { return fCurrentTrk; }

    void Init(TString brName = "GeoTracks", TString folderName = "MCGeoTrack");
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairTrajFilter object, created
     * with FairTrajFilter::FairTrajFilter().
     */
    static FairTrajFilter* Instance();

    /**
     * This function applies all availible cuts on different variables.
     * @param p - pointer to the TParticle object.
     * @return kTRUE - if particle survives the cuts. Otherwise - kFALSE.
     */
    Bool_t IsAccepted(const TParticle* p) const;

    /**
     * This function enables the vertex cut.
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param Box in coordinate space. Only trajectories, created inside this box
     * will be stored. Default values - the cave dimensions.
     */
    void SetVertexCut(Double_t vxMin = -2000.,
                      Double_t vyMin = -2000.,
                      Double_t vzMin = -2000.,
                      Double_t vxMax = 2000.,
                      Double_t vyMax = 2000.,
                      Double_t vzMax = 2000.);

    /**
     * This function enables the momentum cut (polar reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (polar reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutP(Double_t pMin = 0.,
                         Double_t thetaMin = 0.,
                         Double_t phiMin = 0.,
                         Double_t pMax = 1e10,
                         Double_t thetaMax = TMath::Pi(),
                         Double_t phiMax = TMath::TwoPi());

    /**
     * This function enables the momentum cut (decart reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (decart reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutD(Double_t pxMin = -1e10,
                         Double_t pyMin = -1e10,
                         Double_t pzMin = -1e10,
                         Double_t pxMax = 1e10,
                         Double_t pyMax = 1e10,
                         Double_t pzMax = 1e10);

    /**
     * This function enables the cut in phase space (pt-rapidity).
     * @param The region in phase space (pt-rapidity). Only particles
     * inside this region will be stored.
     * Default values - whole pt-rapidity range.
     */
    void SetPtRapidityCut(Double_t ptMin = 0.,
                          Double_t ptMax = 1e10,
                          Double_t rapidityMin = -1e10,
                          Double_t rapidityMax = 1e10);

    /**
     * This function enables the cut on total energy.
     * @param Total energy range. Only particles with total energy value
     * inside this range will be stored. Deafult values - whole energy range.
     */
    void SetEnergyCut(Double_t etotMin = 0., Double_t etotMax = 1e10);

    /**
     * This function controls the storing of primaries.
     * @param storePrim - boolean flag to control the storing of primaries.
     */
    inline void SetStorePrimaries(Bool_t storePrim = kTRUE) { fStorePrim = storePrim; };

    /**
     * This function controls the storing of secondaries.
     * @param storeSec - boolean flag to control the storing of secondaries.
     */
    inline void SetStoreSecondaries(Bool_t storeSec = kTRUE) { fStoreSec = storeSec; };

    /**
     * This function controls the process of adding the points to the trajectory.
     * @param stepSizeMin - minimum value of step size, wich will be added to
     * the trajectory.
     */
    void SetStepSizeCut(Double_t stepSizeMin = 0.);

    /**
     * This is the getter for the vertex cut.
     * @param References to the variables where return values should be stored.
     */
    void GetVertexCut(Double_t& vxMin,
                      Double_t& vyMin,
                      Double_t& vzMin,
                      Double_t& vxMax,
                      Double_t& vyMax,
                      Double_t& vzMax) const;

    /**
     * This is the getter for the momentum cut (polar reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutP(Double_t& pMin,
                         Double_t& thetaMin,
                         Double_t& phiMin,
                         Double_t& pMax,
                         Double_t& thetaMax,
                         Double_t& phiMax) const;

    /**
     * This is the getter for the momentum cut (decart reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutD(Double_t& pxMin,
                         Double_t& pyMin,
                         Double_t& pzMin,
                         Double_t& pxMax,
                         Double_t& pyMax,
                         Double_t& pzMax) const;

    /**
     * This is the getter for the space phase cut.
     * @param References to the variables where return values should be stored.
     */
    void GetPtRapidityCut(Double_t& ptMin, Double_t& ptMax, Double_t& rapidityMin, Double_t& rapidityMax) const;

    /**
     * This is the getter for the total energy cut.
     * @param References to the variables where return values should be stored.
     */
    void GetEnergyCut(Double_t& etotMin, Double_t& etotMax) const;

    /**
     * This is the getter for flag of storing of primaries.
     * @return kTRUE if primaries should be stored.
     */
    inline Bool_t IsPrimariesStored() const { return fStorePrim; };

    /**
     * This is the getter for flag of storing of secondaries.
     * @return kTRUE if secondaries should be stored.
     */
    inline Bool_t IsSecondariesStored() const { return fStoreSec; };

    /**
     * This is the getter for the step size cut.
     * @return The minimum value of the step size wich still should be
     * added to the trajectory.
     */
    inline Double_t GetStepSizeCut() const { return fStepSizeMin; };

    TGeoTrack* GetTrack(Int_t trackId);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairTSBufferFunctionalFunctional_H_
#define FairTSBufferFunctionalFunctional_H_

#include "FairTimeStamp.h"   // for FairTimeStamp

#include <Rtypes.h>     // for Int_t, Bool_t, Double_t, etc
#include <TObject.h>    // for TObject
#include <TString.h>    // for TString
#include <functional>   // for binary_function
#include <iostream>     // for operator<<, basic_ostream, etc

class TBranch;
class TClonesArray;
class TTree;

/**
 * \class BinaryFunctor
 * \brief Base class for all functors which are used in the FairTSBufferFunctional
 * \see FairTSBufferFunctional
 *
 * The class is a base class to control which data is extracted by the FairTSBufferFunctional class for processing.
 * The important method to overwrite is Call. It gets the actual data which is read in from the tree and a parameter.
 * If the actual data is not anymore part of the data you want to have Call returns true to stop the reading of data.
 * Otherwise it should return false.
 * The method TimeOut is used to break the processing if for example always the same data is requested.
 */

class BinaryFunctor
{
  public:
    using first_argument_type = FairTimeStamp*;
    using second_argument_type = double;
    using result_type = bool;

    virtual bool operator()(FairTimeStamp* a, double b) { return Call(a, b); };
    virtual bool Call(FairTimeStamp* a, double b) = 0;
    virtual bool TimeOut() { return false; }
    virtual void ResetTimeOut(){};

    virtual ~BinaryFunctor(){};
};

/**
 * \class StopTime
 * Gives you all the data which is older than the given parameter StopTime.
 * It does not return the data requested before.
 */

class StopTime : public BinaryFunctor
{
  public:
    StopTime()
        : fRequestTime(-1)
        , fOldTime(-1)
        , fSameTimeRequestCounter(0){};

    /**
     * \parameter b: StopTime: All data older than StopTime is returned
     */
    bool Call(FairTimeStamp* a, double b) override
    {
        fRequestTime = b;
        // std::cout << "StopTime: " << a->GetTimeStamp() << " > " <<  b << std::endl;
        return a->GetTimeStamp() > b;
    };

    bool TimeOut() override
    {
        if (fRequestTime != fOldTime) {
            fOldTime = fRequestTime;
            fSameTimeRequestCounter = 0;
            // std::cout << "RequestedTime: " << fRequestTime << std::endl;
            return false;
        } else if (fRequestTime == fOldTime) {
            std::cout << "-I- FairTSBufferFunctional StopTime has requested the same data as before: " << fRequestTime
                      << std::endl;
            fSameTimeRequestCounter++;
        } else {
            std::cout << "-E- FairTSBufferFunctional StopTime Functor has requested time " << fRequestTime
                      << " smaller than old time " << fOldTime << std::endl;
            return true;
        }
        return fSameTimeRequestCounter > 9;
    }

    void ResetTimeOut() override { fSameTimeRequestCounter = 0; }

  private:
    double fRequestTime;
    double fOldTime;
    int fSameTimeRequestCounter;
};

/**
 * \class TimeGap
 * Returns you all the data between two time gaps of a given length.
 */

class TimeGap : public BinaryFunctor
{
  public:
    TimeGap()
        : fOldTime(-1.){};

    /**
     * \parameter b : TimeGap: All data between two time gaps which are larger than TimeGap are returned
     */
    bool Call(FairTimeStamp* a, double b) override
    {
        double aTime = a->GetTimeStamp();

        if (fOldTime < 0) {
            fOldTime = aTime;
            return false;
        }
        if (aTime - fOldTime > b) {
            fOldTime = aTime;
            return true;
        } else {
            fOldTime = aTime;
            return false;
        }
    };

  private:
    double fOldTime;
};

/**
 * \class FairTSBufferFunctional
 * \brief A class to access time ordered data in a root branch
 *
 * In the constructor of the class one has to give the branch name of the data, the tree the data is stored in
 * and a BinaryFunctor which contains the method how the data should be extracted. Several example functors already
 * exists. To extract the data one has to call GetData with a parameter which fits to the selected functor. GetData
 * returns a TClonesArray which contains the data.
 *
 *
 * Be careful! The buffer runs through the time ordered data in one time direction only. This means that you cannot
 * request data which is older than the data you have requested before.
 *
 * Addition: This is not true anymore. GetData(Double_t, Double_t) is able to get also data which is older but this only
 * works if you request a fixed time via StopTime functor. For other functors the behavior is unpredictable.
 *
 *  Created on: Feb 18, 201
 *      Author: stockman
 */

class FairTSBufferFunctional : public TObject
{
  public:
    FairTSBufferFunctional(TString branchName,
                           TTree* sourceTree,
                           BinaryFunctor* stopFunction,
                           BinaryFunctor* startFunction = 0);

    ~FairTSBufferFunctional() override {}
    TClonesArray* GetData(Double_t stopParameter);
    TClonesArray* GetData(Double_t startParameter, Double_t stopParameter);
    Int_t GetBranchIndex() { return fBranchIndex; }

    void SetBranchIndex(const Int_t val) { fBranchIndex = val; }
    void SetStartFunction(BinaryFunctor* function) { fStartFunction = function; }
    void SetStopFunction(BinaryFunctor* function) { fStopFunction = function; }
    Bool_t AllDataProcessed();
    void Terminate() { fTerminate = kTRUE; }

    Bool_t TimeOut()
    {
        Bool_t stopTimeOut = fStopFunction->TimeOut();
        Bool_t startTimeOut = kTRUE;
        if (fStartFunction != 0) {
            startTimeOut = fStartFunction->TimeOut();
            //        if (startTimeOut == kTRUE && stopTimeOut == kFALSE){
            //          fStartFunction->ResetTimeOut();
            //        }
            //        else if (startTimeOut == kFALSE && stopTimeOut == kTRUE){
            //          fStopFunction->ResetTimeOut();
            //        }
        }
        return (stopTimeOut && startTimeOut);
    }

    Int_t FindStartIndex(Double_t startParameter);

  private:
    void ReadInNextFilledEntry();
    Int_t ReadInPreviousFilledEntry(Int_t startEntry);
    void ReadInNextEntry();   //** used only if no function is given and input data is directly passed through to the
                              // OutputArray
    void ReadInEntry(Int_t number);
    void AbsorbDataBufferArray();   //< Absorbs the complete data from fInputArray to fBufferArray

    TClonesArray* fOutputArray;
    TClonesArray* fBufferArray;
    TClonesArray* fInputArray;

    BinaryFunctor* fStartFunction;
    BinaryFunctor* fStopFunction;

    TBranch* fBranch;
    Int_t fBranchIndex;

    Bool_t fTerminate;

    Int_t fVerbose;

    FairTSBufferFunctional(const FairTSBufferFunctional&);
    FairTSBufferFunctional& operator=(const FairTSBufferFunctional&);

    ClassDefOverride(FairTSBufferFunctional, 0);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * @class FairWriteoutBuffer
 *
 * @author Tobias Stockmanns
 * @brief A container class to store digi data during events
 *
 * The FairWriteoutBuffer class provides a container which handles the storage of data between
 * events. The data has to be given with an active time, the absolute time the data is active in the
 * detector and can influence the output of the data.
 * FillNewData is used to put new data into the container.
 * WriteOutData with a given actual time stores the data which has an active time older than the given time
 * in the corresponding TClonesArray of the FairRootManager.
 * At the end of the task WriteOutAllData has to be called to store the data which is still in the buffer.
 * If one adds data via FillNewData into the buffer which is already present in the buffer, Modify is called.
 * The standard behavior of Modify is that the new data is ignored to simulate pile-up. If a different behavior
 * is wanted one has to overwrite Modify in a derived class.
 *
 * The data which should be stored in the buffer has to be derived from FairTimeStamp.
 * It needs an operator< and a method equal if the same detector element is hit.
 *
 * To use this buffer one has to derive his own buffer class from FairWriteoutBuffer and overwrite the pure virtual
 * functions.
 */

#ifndef FairWriteoutBuffer_H_
#define FairWriteoutBuffer_H_

#include "FairLogger.h"        // for FairLogger
#include "FairRootManager.h"   // for FairRootManager
#include "FairTimeStamp.h"     // for FairTimeStamp

#include <Rtypes.h>         // for Bool_t, Int_t, etc
#include <TClonesArray.h>   // for TClonesArray
#include <TObject.h>        // for TObject
#include <TString.h>        // for TString
#include <iostream>         // for cout, ostream
#include <map>              // for multimap
#include <utility>          // for pair
#include <vector>           // for vector

class FairWriteoutBuffer : public TObject
{
  public:
    FairWriteoutBuffer()
        : TObject()
        , fStartTime_map()
        , fDeadTime_map()
        , fBranchName()
        , fClassName()
        , fTreeSave(false)
        , fActivateBuffering(kFALSE)
        , fVerbose(0)
        , fLogger(FairLogger::GetLogger()){};
    FairWriteoutBuffer(TString branchName, TString className, TString folderName, Bool_t persistance);
    ~FairWriteoutBuffer() override {}

    virtual void SaveDataToTree(Bool_t val = kTRUE)
    {
        fTreeSave = val;   ///< If SaveDataToTree is set the data is stored at the end of the buffering into the given
                           ///< TClonesArray.
    }
    virtual void ActivateBuffering(Bool_t val = kTRUE)
    {
        fActivateBuffering = val;   ///< fActivateBuffering has to be set to kTRUE to use the buffering. Otherwise the
                                    ///< data is directly stored in the given TClonesArray.
    }

    Bool_t IsBufferingActivated() { return fActivateBuffering; }

    /// Fills a pointer to a data object into the buffer. StartTime gives the time when the data can influence later
    /// data, activeTime gives the time how long the data can influence later data. Both time data has to be given as an
    /// absolute time!
    virtual void FillNewData(FairTimeStamp* data, double startTime, double activeTime);

    virtual Int_t GetNData() { return fDeadTime_map.size(); }
    virtual std::vector<FairTimeStamp*> GetRemoveOldData(double time);
    virtual std::vector<FairTimeStamp*> GetAllData();

    virtual void SetVerbose(Int_t val) { fVerbose = val; }

    virtual void DeleteOldData()
    {
        if (fBranchName.Length() > 0) {
            TClonesArray* myArray = FairRootManager::Instance()->GetTClonesArray(fBranchName);
            myArray->Delete();
        }
    }

    virtual void WriteOutData(double time);
    virtual void WriteOutAllData();

  protected:
    virtual void AddNewDataToTClonesArray(
        FairTimeStamp* data) = 0;   ///< store the data from the FairTimeStamp pointer in a TClonesArray (you have to
                                    ///< cast it to your type of data)
    virtual double FindTimeForData(
        FairTimeStamp* data) = 0;   ///< if the same data object (like a pad or a pixel) is already present in the
                                    ///< buffer, the time of this object has to be returned otherwise -1
    virtual void FillDataMap(FairTimeStamp* data, double activeTime) = 0;   ///< add a new element in the search buffer
    virtual void EraseDataFromDataMap(
        FairTimeStamp* data) = 0;   ///< delete the element from the search buffer (see PndSdsDigiPixelWriteoutBuffer)

    /// Modify defines the behavior of the buffer if data should be stored which is already in the buffer. Parameters
    /// are the old data with the active time, the new data with an active time. Modify returns than a vector with the
    /// new data which should be stored.
    virtual std::vector<std::pair<double, FairTimeStamp*>> Modify(std::pair<double, FairTimeStamp*> oldData,
                                                                  std::pair<double, FairTimeStamp*>)
    {
        std::vector<std::pair<double, FairTimeStamp*>> result;
        result.push_back(oldData);
        return result;
    }

    virtual void WriteOutDataDeadTimeMap(double time);
    virtual void MoveDataFromStartTimeMapToDeadTimeMap(double time);
    virtual void FillDataToDeadTimeMap(FairTimeStamp* data, double activeTime, double startTime);

    virtual void PrintData(FairTimeStamp* data)
    {
        std::cout << data->GetTimeStamp();
    };   ///< Method should be overwritten in derived classes to print the data of an object stored in the buffer
    virtual void PrintDeadTimeMap();
    virtual void PrintStartTimeMap();

    std::multimap<double, std::pair<double, FairTimeStamp*>> fStartTime_map;
    std::multimap<double, FairTimeStamp*> fDeadTime_map;

    TString fBranchName;
    TString fClassName;
    Bool_t fTreeSave;
    Bool_t fActivateBuffering;
    Int_t fVerbose;
    FairLogger* fLogger;   //! /// FairLogger

  private:
    FairWriteoutBuffer(const FairWriteoutBuffer&);
    FairWriteoutBuffer& operator=(const FairWriteoutBuffer&);

    ClassDefOverride(FairWriteoutBuffer, 1);
};

#endif /* FairWriteoutBuffer_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----            FairAnaSelector header file                        -----
// -----            Created 14/10/11  by R. Karabowicz                 -----
// -----            Updated 01/02/12  by R. Karabowicz                 -----
// -------------------------------------------------------------------------

#ifndef FAIRANASELECTOR_H
#define FAIRANASELECTOR_H

#include "FairLogger.h"   // for FairLogger, MESSAGE_ORIGIN

#include <Rtypes.h>          // for Int_t, Bool_t, etc
#include <TSelector.h>       // for TSelector
#include <TSelectorList.h>   // for TSelectorList
#include <TString.h>         // for TString
#include <TTree.h>           // for TTree

class FairFileSource;
class FairRunAnaProof;

class TFile;
class TList;
class TObject;
class TProofOutputFile;

class FairAnaSelector : public TSelector
{
  public:
    TProofOutputFile* fProofFile;
    TFile* fFile;
    TTree* fChain;   //! pointer to the analyzed TTree or TChain
    FairRunAnaProof* fRunAna;

    FairAnaSelector(TTree* /*tree*/ = 0)
        : fProofFile(0)
        , fFile(0)
        , fChain(0)
        , fRunAna(nullptr)
        , fProofSource(0)
        , fCurrentDirectory("")
    {}

    ~FairAnaSelector() override {}
    Int_t Version() const override { return 1; }
    void Begin(TTree* tree) override;
    void SlaveBegin(TTree* tree) override;
    void Init(TTree* tree) override;
    Bool_t Notify() override;
    Bool_t Process(Long64_t entry) override;
    Int_t GetEntry(Long64_t entry, Int_t getall = 0) override
    {
        return fChain ? fChain->GetTree()->GetEntry(entry, getall) : 0;
    }
    void SetOption(const char* option) override { fOption = option; }
    void SetObject(TObject* obj) override { fObject = obj; }
    void SetInputList(TList* input) override { fInput = input; }
    TList* GetOutputList() const override { return fOutput; }
    void SlaveTerminate() override;
    void Terminate() override;

    void SetFairRunAnaProof(FairRunAnaProof* runAna) { fRunAna = runAna; }

  private:
    FairAnaSelector(const FairAnaSelector&);
    FairAnaSelector operator=(const FairAnaSelector&);

    FairFileSource* fProofSource;

    TString fCurrentDirectory;

    ClassDefOverride(FairAnaSelector, 0);
};

#endif   // FAIRANASELECTOR_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANAPROOF_H
#define FAIRRUNANAPROOF_H

/**
 * Configure and manage the  Analysis on proof
 * @author R. Karabowicz
 * @version 0.1
 * @since 30.04.2013
 */

#include "FairFileSource.h"   // FairRunAnaProof can only accept FairFileSource as source
#include "FairRunAna.h"

#include <Rtypes.h>
#include <TProof.h>

class FairRunAnaProof : public FairRunAna
{
  public:
    /** \deprecated Deprecated in v18.8, will be removed in v20. */
    [[deprecated]] static FairRunAnaProof* Instance();
    virtual ~FairRunAnaProof();
    FairRunAnaProof(const char* proofName = "");

    /**initialize the run manager*/
    void Init() override;

    /** Init containers executed on PROOF, which is part of Init when running locally*/
    void InitContainers();

    /**Run from event number NStart to event number NStop */
    void Run(Int_t NStart = 0, Int_t NStop = 0) override;
    /**Run for one event, used on PROOF nodes*/
    void RunOneEvent(Long64_t entry);
    /**Run on proof from event NStart to event NStop*/
    void RunOnProof(Int_t NStart, Int_t NStop);

    /** set the input tree of fRootManager when running on PROOF worker*/
    /* void        SetInTree (TTree* tempTree)   { */
    /*   fRootManager->SetInTree (tempTree); */
    /* } */

    /** GetProof */
    TProof* GetProof() { return fProof; }

    /** To be set to kTRUE only when running on PROOF worker, only by TSelector */
    void SetRunOnProofWorker(Bool_t tb = kTRUE) { fRunOnProofWorker = tb; }
    /** Set PROOF ARchive (PAR) file name*/
    void SetProofParName(TString parName) { fProofParName = parName; }
    /** Set directory for storing output files*/
    void SetOutputDirectory(TString dirName) { fOutputDirectory = dirName; }
    /** Set PROOF output status, possibilities: "copy","merge"*/
    void SetProofOutputStatus(TString outStat) { fProofOutputStatus = outStat; }

    void SetSource(FairSource* tempSource) override;

  protected:
    static FairRunAnaProof* fRAPInstance;

    /** PROOF **/
    TProof* fProof;
    /** executing on PROOF worker*/
    Bool_t fRunOnProofWorker;   //!
    /** PROOF server name*/
    TString fProofServerName;   //!
    /** PROOF ARchive (PAR) file name*/
    TString fProofParName;   //!
    /** Output directory*/
    TString fOutputDirectory;   //!
    /** Output status indicator: "copy","merge","dataset"*/
    TString fProofOutputStatus;

  private:
    FairRunAnaProof(const FairRunAnaProof&);
    FairRunAnaProof operator=(const FairRunAnaProof&);

    FairFileSource* fProofFileSource;

    ClassDefOverride(FairRunAnaProof, 1);
};

#endif   // FAIRRUNANAPROOF_H

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from G__Base dictionary payload:42:
In file included from /home/physics/fair_install/FairRootInstall/include/FairWriteoutBuffer.h:37:
In file included from /home/physics/fair_install/FairRootInstall/include/FairTimeStamp.h:11:
In file included from /home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData_Interface.h:11:
/home/physics/fair_install/FairRootInstall/include/FairLink.h:104:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<<(std::ostream& out, const FairLink& link)
                         ^
/home/physics/fair_install/FairRootInstall/include/FairLink.h:104:26: note: previous definition is here
    friend std::ostream& operator<<(std::ostream& out, const FairLink& link)
                         ^
In file included from G__Base dictionary payload:42:
In file included from /home/physics/fair_install/FairRootInstall/include/FairWriteoutBuffer.h:37:
In file included from /home/physics/fair_install/FairRootInstall/include/FairTimeStamp.h:11:
In file included from /home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData_Interface.h:12:
/home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData.h:128:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData& data)
                         ^
/home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData.h:128:26: note: previous definition is here
    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData& data)
                         ^
In file included from G__Base dictionary payload:42:
In file included from /home/physics/fair_install/FairRootInstall/include/FairWriteoutBuffer.h:37:
In file included from /home/physics/fair_install/FairRootInstall/include/FairTimeStamp.h:11:
/home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData_Interface.h:79:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData_Interface& data)
                         ^
/home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData_Interface.h:79:26: note: previous definition is here
    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData_Interface& data)
                         ^
In file included from G__Base dictionary payload:42:
In file included from /home/physics/fair_install/FairRootInstall/include/FairWriteoutBuffer.h:37:
/home/physics/fair_install/FairRootInstall/include/FairTimeStamp.h:69:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<<(std::ostream& out, const FairTimeStamp& link)
                         ^
/home/physics/fair_install/FairRootInstall/include/FairTimeStamp.h:69:26: note: previous definition is here
    friend std::ostream& operator<<(std::ostream& out, const FairTimeStamp& link)
                         ^
G__Base dictionary payload:2694:18: error: no viable overloaded '='
    fFSTrackIter = fFSTrackMap.find(iTrack);   // check if point created by FastSimulation
    ~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~
G__Base dictionary payload:2696:30: error: member reference type 'std::map<Int_t, Int_t>::iterator' (aka '_Rb_tree_iterator<std::pair<const int, int> >') is not a pointer; did you mean to use '.'?
        iTrack = fFSTrackIter->second;
                 ~~~~~~~~~~~~^~
                             .
G__Base dictionary payload:2696:32: error: no member named 'second' in 'std::_Rb_tree_iterator<std::pair<const int, int> >'
        iTrack = fFSTrackIter->second;
                 ~~~~~~~~~~~~  ^
G__Base dictionary payload:6517:19: error: no viable overloaded '='
        fSimSetup = f;
        ~~~~~~~~~ ^ ~
/usr/include/c++/11/bits/std_function.h:487:7: note: candidate function not viable: no known conversion from 'std::function<void ()>' to 'std::function<void ()> &&' for 1st argument
      operator=(function&& __x) noexcept
      ^
/usr/include/c++/11/bits/std_function.h:501:7: note: candidate function not viable: no known conversion from 'std::function<void ()>' to 'std::nullptr_t' (aka 'nullptr_t') for 1st argument
      operator=(nullptr_t) noexcept
      ^
/usr/include/c++/11/type_traits:2205:46: note: candidate template ignored: disabled by 'enable_if' [with _Functor = std::function<void ()> &]
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;
                                             ^
/usr/include/c++/11/bits/std_function.h:540:2: note: candidate template ignored: could not match 'reference_wrapper' against 'function'
        operator=(reference_wrapper<_Functor> __f) noexcept
        ^
G__Base dictionary payload:6522:27: error: no viable overloaded '='
        fSimSetupPostInit = f;
        ~~~~~~~~~~~~~~~~~ ^ ~
/usr/include/c++/11/bits/std_function.h:487:7: note: candidate function not viable: no known conversion from 'std::function<void ()>' to 'std::function<void ()> &&' for 1st argument
      operator=(function&& __x) noexcept
      ^
/usr/include/c++/11/bits/std_function.h:501:7: note: candidate function not viable: no known conversion from 'std::function<void ()>' to 'std::nullptr_t' (aka 'nullptr_t') for 1st argument
      operator=(nullptr_t) noexcept
      ^
/usr/include/c++/11/type_traits:2205:46: note: candidate template ignored: disabled by 'enable_if' [with _Functor = std::function<void ()> &]
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;
                                             ^
/usr/include/c++/11/bits/std_function.h:540:2: note: candidate template ignored: could not match 'reference_wrapper' against 'function'
        operator=(reference_wrapper<_Functor> __f) noexcept
        ^
In file included from /home/physics/fair_install/FairSoft/build/Build/root/input_line_4:2:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/Rtypes.h:191:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/TGenericClassInfo.h:22:
In file included from /usr/include/c++/11/vector:67:
/usr/include/c++/11/bits/stl_vector.h:680:30: error: no member named '_M_start' in 'std::_Vector_base<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_Vector_impl'
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                      ~~~~~~~~~~~~~ ^
G__Base dictionary payload:5257:5: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::~vector' requested here
    FairRingSorter(int size = 100, double width = 10)
    ^
In file included from /home/physics/fair_install/FairSoft/build/Build/root/input_line_4:2:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/Rtypes.h:191:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/TGenericClassInfo.h:22:
In file included from /usr/include/c++/11/vector:67:
/usr/include/c++/11/bits/stl_vector.h:557:16: error: no member named '_M_finish' in 'std::_Vector_base<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_Vector_impl'
        this->_M_impl._M_finish =
        ~~~~~~~~~~~~~ ^
G__Base dictionary payload:5275:66: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::vector' requested here
    virtual std::vector<FairTimeStamp*> GetOutputData() { return fOutputData; }
                                                                 ^
In file included from /home/physics/fair_install/FairSoft/build/Build/root/input_line_4:2:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/Rtypes.h:191:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/TGenericClassInfo.h:22:
In file included from /usr/include/c++/11/vector:67:
/usr/include/c++/11/bits/stl_vector.h:919:40: error: no member named '_M_finish' in 'std::_Vector_base<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_Vector_impl'
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
                         ~~~~~~~~~~~~~ ^
/usr/include/c++/11/bits/stl_vector.h:554:19: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::size' requested here
      : _Base(__x.size(),
                  ^
G__Base dictionary payload:5275:66: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::vector' requested here
    virtual std::vector<FairTimeStamp*> GetOutputData() { return fOutputData; }
                                                                 ^
In file included from /home/physics/fair_install/FairSoft/build/Build/root/input_line_4:2:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/Rtypes.h:191:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/TGenericClassInfo.h:22:
In file included from /usr/include/c++/11/vector:67:
/usr/include/c++/11/bits/stl_vector.h:1499:39: error: no member named '_M_start' in 'std::_Vector_base<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_Vector_impl'
      { _M_erase_at_end(this->_M_impl._M_start); }
                        ~~~~~~~~~~~~~ ^
G__Base dictionary payload:5277:51: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::clear' requested here
    virtual void DeleteOutputData() { fOutputData.clear(); }
                                                  ^
In file included from /home/physics/fair_install/FairSoft/build/Build/root/input_line_4:2:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/Rtypes.h:191:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/TGenericClassInfo.h:22:
In file included from /usr/include/c++/11/vector:67:
/usr/include/c++/11/bits/stl_vector.h:1794:36: error: no member named '_M_finish' in 'std::_Vector_base<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_Vector_impl'
        if (size_type __n = this->_M_impl._M_finish - __pos)
                            ~~~~~~~~~~~~~ ^
/usr/include/c++/11/bits/stl_vector.h:1499:9: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_M_erase_at_end' requested here
      { _M_erase_at_end(this->_M_impl._M_start); }
        ^
G__Base dictionary payload:5277:51: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::clear' requested here
    virtual void DeleteOutputData() { fOutputData.clear(); }
                                                  ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class FairFileSource with content:

#line 1 "G__Base dictionary payload"

#ifndef BUILD_PROOF_SUPPORT
  #define BUILD_PROOF_SUPPORT 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilder header file                -----
// -----                  Created 23/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------

/** FairEventBuilder
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 23/09/2013
 *@version 1.0
 **
 ** FairRoot base task for the event buffers.
 ** The tasks may:
 ** 1. analyze data to reconstruct event times or other characteristics
 **    in the function TClonesArray* FindEvents(), that returns
 **    TClonesArray of FairRecoEvents
 ** 2. identify the data that could belong to event in the
 **    function and insert this identified data to the output TClonesArrays
 **    in the function StoreEventData(event)
 ** The implementations may be using any or both of the above functions.
 **/

#ifndef FAIREVENTBUILDER_H
#define FAIREVENTBUILDER_H 1

#include "FairRecoEventHeader.h"
#include "FairWriteoutBuffer.h"

#include <Rtypes.h>
#include <TStopwatch.h>
#include <TString.h>
#include <utility>   // pair
#include <vector>

class TClonesArray;
// class FairRecoEventHeader;

class FairEventBuilder : public FairWriteoutBuffer
{
  public:
    /** Default constructor **/
    FairEventBuilder();

    /** Constructor with task name **/
    FairEventBuilder(TString branchName, TString className, TString folderName, Bool_t persistance);

    /** Destructor **/
    virtual ~FairEventBuilder();

    virtual void WriteOutAllDeadTimeData();

    virtual std::vector<std::pair<double, FairRecoEventHeader*>> FindEvents() = 0;
    virtual void StoreEventData(FairRecoEventHeader* /*recoEvent*/) = 0;

    void SetIdentifier(Int_t ident) { fIdentifier = ident; }
    Int_t GetIdentifier() { return fIdentifier; }

    virtual Bool_t Init() = 0;

    virtual void Print(Option_t* option = "") const = 0;

    /** Finish at the end of each event **/
    virtual void Finish();

    Double_t AllowedTime() { return fMaxAllowedEventCreationTime; };
    void SetMaxAllowedTime(Double_t td) { fMaxAllowedEventCreationTime = td; };

    void SetBuilderName(const char* name) { fBuilderName = name; }
    TString GetBuilderName() { return fBuilderName; }

  private:
    TString fBuilderName;

    TStopwatch fTimer;
    Double_t fExecTime;

    Int_t fIdentifier;
    Double_t fMaxAllowedEventCreationTime;

    ClassDef(FairEventBuilder, 1);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilderManager header file              -----
// -----                  Created 20/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------

/** FairEventBuilderManager
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 20/09/2013
 *@version 1.0
 **
 ** FairRoot general task for recreating events in Time-Based reconstruction mode.
 ** Various experiments should implement their own version of Event Builder.
 ** The main member of the task is vector of reconstructed events fRecoEvents.
 ** It also contains a vector of implementations of FairEventBuilders, that are
 ** responsible for feeding fRecoEvents vector via FindEvents() function.
 **
 ** The heart of the experiment-specific implemenations is
 ** the AnalyzeAndExtractEvents() function, which should interpret
 ** the experimental data to reconstruct events.
 **/

#ifndef FAIREVENTBUILDERMANAGER_H
#define FAIREVENTBUILDERMANAGER_H 1

#include "FairEventBuilder.h"
#include "FairTask.h"

#include <Rtypes.h>   // ClassDef
#include <vector>

class TClonesArray;

class FairEventBuilderManager : public FairTask
{
  public:
    /** Default constructor **/
    FairEventBuilderManager();

    /** Constructor with task name **/
    FairEventBuilderManager(const char* name, Int_t iVerbose = 1);

    /** Destructor **/
    virtual ~FairEventBuilderManager();

    /** Execution **/
    virtual void Exec(Option_t* opt);

    /** Adding FairEventBuilder **/
    virtual void AddEventBuilder(FairEventBuilder* eventBuilder);

  protected:
    std::vector<FairEventBuilder*> fEventBuilders;
    std::vector<std::vector<std::pair<double, FairRecoEventHeader*>>> fPossibleEvents;

    /** Fill events from various builders **/
    virtual Double_t FillEventVectors();

    /** Analyze and extract events - experiment specific **/
    virtual void AnalyzeAndExtractEvents(Double_t maxEventTimeAllowed) = 0;

    /** Create output tree structure **/
    virtual void CreateAndFillEvent(FairRecoEventHeader* recoEvent);

  private:
    /** Intialisation **/
    virtual InitStatus Init();

    /** Reinitialisation **/
    virtual InitStatus ReInit();

    /** Finish at the end of each event **/
    virtual void Finish();

    ClassDef(FairEventBuilderManager, 1);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2023 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairEventHeader header file                      -----
// -----          Created 08/09/04                 D.Bertini           -----
// -------------------------------------------------------------------------

#ifndef FAIREVENTHEADER_H
#define FAIREVENTHEADER_H

#include <Rtypes.h>   // for Int_t, Double_t, UInt_t, ClassDef, etc
#include <TNamed.h>   // for TNamed

/**
 *  Event Header Class
 **@author D.Bertini <d.bertini@gsi.de>
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairEventHeader : public TNamed
{
  public:
    /** Default constructor */
    FairEventHeader() = default;

    /**
     * Destructor
     */
    ~FairEventHeader() override = default;

    /** Get the run ID for this run*/
    UInt_t GetRunId() const { return fRunId; }

    /** Get the MC time for this event*/
    Double_t GetEventTime() const { return fEventTime; }

    /** Get the MC input file Id for this event*/
    Int_t GetInputFileId() const { return fInputFileId; }

    /**The entry number in the original MC chain */
    Int_t GetMCEntryNumber() const { return fMCEntryNo; }

    /** Set the run ID for this run
     * @param runid : unique run id
     */
    void SetRunId(UInt_t runid) { fRunId = runid; }

    /** Set the MC time for this event
     * @param time : time in ns
     */
    void SetEventTime(Double_t time) { fEventTime = time; }

    /** Set the Signal file Id for this event*/
    void SetInputFileId(Int_t id) { fInputFileId = id; }

    /**The entry number in the original MC chain */
    void SetMCEntryNumber(Int_t id) { fMCEntryNo = id; }

    virtual void Register(Bool_t Persistance = kTRUE);

  protected:
    /** Run Id */
    UInt_t fRunId{0};
    /** Event Time **/
    Double_t fEventTime{-1.};
    /** Input file identifier, the file description is in the File header*/
    Int_t fInputFileId{0};
    /**MC entry number from input chain*/
    Int_t fMCEntryNo{0};

    ClassDefOverride(FairEventHeader, 3);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                         FairFileHeader source file           -----
// -----            Created 20/04/11                 M.Al-Turany        -----
// -------------------------------------------------------------------------

#ifndef FAIRFILEHEADER_H
#define FAIRFILEHEADER_H

#include <Rtypes.h>    // for UInt_t, etc
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString

class FairFileInfo;
class TFile;
class TList;

/**
 *  File Header Class
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairFileHeader : public TNamed
{
  public:
    /** Default constructor */
    FairFileHeader();

    /**Add a class name of a task*/
    void AddTaskClassName(TString taskname);

    /** Set the run ID for this run
     * @param runid : unique run id
     */
    void SetRunId(UInt_t runid) { fRunId = runid; }

    /** Get the run ID for this run*/
    UInt_t GetRunId() { return fRunId; }

    /** Return the list of tasks class names */
    TList* GetListOfTasks() { return fTaskList; }

    void AddInputFile(TFile* f, UInt_t id, UInt_t ChId);

    /**
     * Destructor
     */
    virtual ~FairFileHeader();

    FairFileInfo* GetFileInfo(UInt_t id, UInt_t ChId);

  protected:
    /** Run Id */
    UInt_t fRunId;

    /**list of TObjStrings presenting the class names of tasks used to produce this file */
    TList* fTaskList;

    /**list of TObjStrings presenting the input files used to produce this file*/
    TList* fFileList;

  private:
    FairFileHeader(const FairFileHeader&);
    FairFileHeader& operator=(const FairFileHeader&);

    ClassDef(FairFileHeader, 2);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//  FairFileInfo.h
//  Created by Mohammad Al-Turany on 6/21/11.
//
#ifndef FAIRFILEINFO_H
#define FAIRFILEINFO_H

#include <Rtypes.h>    // for UInt_t, FairFileInfo::Class, etc
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString

class TFile;

class FairFileInfo : public TNamed
{
  public:
    FairFileInfo();
    FairFileInfo(TFile* file, UInt_t id, UInt_t ChId);
    virtual ~FairFileInfo();

    TString GetPath() { return fPath; }
    UInt_t GetSize() { return fSize; }
    UInt_t GetIdentifier() { return fIdentifier; }
    UInt_t GetOrderInChain() { return fInChainId; }

    void Print(Option_t* option = "") const;

    void SetPath(TString path) { fPath = path; }
    void SetSize(UInt_t size) { fSize = size; }
    void SetIdentifier(UInt_t id) { fIdentifier = id; }
    void SetOrderInChain(UInt_t id) { fInChainId = id; }

  protected:
    /** Full path of file*/
    TString fPath;
    /** size of file in bytes*/
    UInt_t fSize;
    /** Signal file identifier used*/
    UInt_t fIdentifier;
    /** file order in the chain*/
    UInt_t fInChainId;

  private:
    FairFileInfo(const FairFileInfo&);
    FairFileInfo& operator=(const FairFileInfo&);

    ClassDef(FairFileInfo, 1);
};

#endif   // FAIRFILEINFO_H
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRHIT_H
#define FAIRHIT_H

#include "FairTimeStamp.h"   // for FairTimeStamp

#include <Rtypes.h>     // for Double_t, Int_t, Double32_t, etc
#include <TVector3.h>   // for TVector3

/**
 * Abstract base class for reconstructed hits in the FAIR detectors.
 **@author V.Friese <v.friese@gsi.de>
 **@author D.Bertini <d.bertini@gsi.de>
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairHit : public FairTimeStamp
{
  public:
    /** Default constructor **/
    FairHit();

    /** Constructor with hit parameters **/
    FairHit(Int_t detID, const TVector3& pos, const TVector3& dpos, Int_t index);

    /** Destructor **/
    virtual ~FairHit();

    /** Accessors **/
    Double_t GetDx() const { return fDx; };
    Double_t GetDy() const { return fDy; };
    Double_t GetDz() const { return fDz; };
    Int_t GetRefIndex() const { return fRefIndex; };
    void PositionError(TVector3& dpos) const;
    Int_t GetDetectorID() const { return fDetectorID; };
    Double_t GetX() const { return fX; };
    Double_t GetY() const { return fY; };
    Double_t GetZ() const { return fZ; };
    void Position(TVector3& pos) const;

    /** Modifiers **/
    void SetDx(Double_t dx) { fDx = dx; }
    void SetDy(Double_t dy) { fDy = dy; }
    void SetDz(Double_t dz) { fDz = dz; }
    void SetDxyz(Double_t dx, Double_t dy, Double_t dz);
    void SetPositionError(const TVector3& dpos);
    void SetRefIndex(Int_t index) { fRefIndex = index; }
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);

    /*** Output to screen */
    virtual void Print(const Option_t*) const { ; }

  protected:
    Double32_t fDx, fDy, fDz;   ///< Errors of position [cm]
    Int_t fRefIndex;            ///< Index of FairMCPoint for this hit
    Int_t fDetectorID;          ///< Detector unique identifier
    Double32_t fX, fY, fZ;      ///< Position of hit [cm]

    ClassDef(FairHit, 3);
};

inline void FairHit::PositionError(TVector3& dpos) const { dpos.SetXYZ(fDx, fDy, fDz); }

inline void FairHit::SetDxyz(Double_t dx, Double_t dy, Double_t dz)
{
    fDx = dx;
    fDy = dy;
    fDz = dz;
}

inline void FairHit::SetPositionError(const TVector3& dpos)
{
    fDx = dpos.X();
    fDy = dpos.Y();
    fDz = dpos.Z();
}

inline void FairHit::Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); }

inline void FairHit::SetXYZ(Double_t x, Double_t y, Double_t z)
{
    fX = x;
    fY = y;
    fZ = z;
}

inline void FairHit::SetPosition(const TVector3& pos)
{
    fX = pos.X();
    fY = pos.Y();
    fZ = pos.Z();
}

#endif   // FAIRHIT_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairLink.h
 *
 *  Created on: Dec 23, 2009
 *      Author: stockman
 *      "Pointer" to any data structure inside a root file with a tree structure
 *      Contains four information:
 *      	File : in which file is the data written (-1 : actual number; 254 : maximum number)
 *      	Entry: entry number in branch of a tree (-1 : actual entry)
 *      	Type : branch inside the tree (-1 : FairLink not set; 65534 : maximum number)
 *      	Index: position inside a container stored in the given branch and entry
 *      	Weight: weighting factor to describe probabilities of a MC truth match
 *
 */

#ifndef FAIRLINK_H_
#define FAIRLINK_H_

#include <Rtypes.h>   // for Int_t, Float_t, etc, ClassDefNV
#include <iostream>   // for ostream, cout

class FairLink
{
  public:
    FairLink();
    FairLink(Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(TString branchName, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, TString branchName, Int_t index, Float_t weight = 1.);
    ~FairLink(){};

    void SetLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.)
    {
        SetFile(file);
        SetEntry(entry);
        SetType(type);
        SetIndex(index);
        SetWeight(weight);
    };
    void SetLink(Int_t type, Int_t index, Float_t weight = 1.)
    {
        SetFile(-1);
        SetEntry(-1);
        SetType(type);
        SetIndex(index);
        SetWeight(weight);
    };
    int GetFile() const;
    int GetEntry() const { return fEntry; }
    int GetType() const;
    int GetIndex() const { return fIndex; }
    float GetWeight() const { return fWeight; }

    void SetFile(int file);
    void SetEntry(int entry) { fEntry = entry; };
    void SetType(int type);
    void SetIndex(int index) { fIndex = index; };

    void SetWeight(Float_t weight) { fWeight = weight; }
    void AddWeight(Float_t weight) { fWeight += weight; }

    void PrintLinkInfo(std::ostream& out = std::cout) const;

    bool operator==(const FairLink& link) const
    {
        return (GetFile() == link.GetFile() || link.GetFile() == -1)
               && (GetEntry() == link.GetEntry() || link.GetEntry() == -1) && GetType() == link.GetType()
               && GetIndex() == link.GetIndex();
    }

    bool operator<(const FairLink& link) const
    {
        if (GetFile() != -1 && link.GetFile() != -1) {
            if (GetFile() < link.GetFile())
                return true;
            else if (link.GetFile() < GetFile())
                return false;
        }
        if (GetEntry() != -1 && link.GetEntry() != -1) {
            if (GetEntry() < link.GetEntry())
                return true;
            else if (link.GetEntry() < GetEntry())
                return false;
        }
        if (GetType() < link.GetType())
            return true;
        else if (link.GetType() < GetType())
            return false;
        if (GetIndex() < link.GetIndex())
            return true;
        else if (link.GetIndex() < GetIndex())
            return false;

        return false;
    }

    friend std::ostream& operator<<(std::ostream& out, const FairLink& link)
    {
        link.PrintLinkInfo(out);
        return out;
    }

    ClassDefNV(FairLink, 5);

    template<class Archive>
    void serialize(Archive& ar, const unsigned int)
    {
        ar& fFile;
        ar& fType;
        ar& fEntry;
        ar& fIndex;
        ar& fWeight;
    }

  private:
    unsigned char fFile;
    unsigned short fType;
    int fEntry;
    int fIndex;
    float fWeight;
};

inline FairLink::FairLink()
    : fFile(0)
    , fType(0)
    , fEntry(-1)
    , fIndex(-1)
    , fWeight(1.0)
{}

inline FairLink::FairLink(Int_t type, Int_t index, Float_t weight)
    : fFile(0)
    , fType(0)
    , fEntry(-1)
    , fIndex(index)
    , fWeight(weight)
{
    SetType(type);
}

inline FairLink::FairLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight)
    : fFile(0)
    , fType(0)
    , fEntry(entry)
    , fIndex(index)
    , fWeight(weight)
{
    SetFile(file);
    SetType(type);
}

inline void FairLink::SetType(int type)
{
    if (type < -1)
        return;
    fType = type + 1;
}

inline int FairLink::GetType() const
{
    int type = fType;
    return type - 1;
}

inline void FairLink::SetFile(int file)
{
    if (file < -1)
        return;
    fFile = file + 1;
}

inline int FairLink::GetFile() const
{
    int file = fFile;
    return file - 1;
}

#endif /* FAIRLINK_H_ */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/** FairMCEventHeader.h
 *@author V.Friese <v.friese@gsi.de>
 ** Data class (level MC) containing information about the input event.
 ** 15.05.2008 change the event time to ns (M. Al-Turany)
 **/

#ifndef FAIRMCEVENTHEADER_H
#define FAIRMCEVENTHEADER_H 1

#include <Rtypes.h>     // for Double_t, UInt_t, etc
#include <TNamed.h>     // for TNamed
#include <TVector3.h>   // for TVector3
#include <limits>       // for std::numeric_limits

class FairMCEventHeader : public TNamed
{
  public:
    /// Alias name for event id type
    using EventID = UInt_t;

    /// Sentinel value for the event id, meaning no event id stored
    static constexpr EventID NoEventID = std::numeric_limits<EventID>::max();

    /** Default constructor **/
    FairMCEventHeader();

    /** Constructor with all members
     **
     *@param iEvent   event identifier
     *@param x,y,z    vertex oordinates [cm]
     *@param t        event time [ns]
     *@param b        impact parameter [fm] (if relevant)
     *@param nPrim    number of input tracks
     **/
    FairMCEventHeader(EventID iEvent, Double_t x, Double_t y, Double_t z, Double_t t, Double_t b, Int_t nPrim);

    /** Standard constructor with run identifier **/
    FairMCEventHeader(UInt_t runId);

    /** Destructor **/
    virtual ~FairMCEventHeader();

    /** Accessors **/
    UInt_t GetRunID() const { return fRunId; }        /// run identifier
    EventID GetEventID() const { return fEventId; }   /// event identifier
    /// check whether an event id is set
    Bool_t HasEventID() const { return fEventId != NoEventID; }
    Double_t GetX() const { return fX; }         /// vertex x [cm]
    Double_t GetY() const { return fY; }         /// vertex y [cm]
    Double_t GetZ() const { return fZ; }         /// vertex z [cm]
    Double_t GetT() const { return fT; }         /// event time [ns]
    Double_t GetB() const { return fB; }         /// impact parameter [fm]
    Int_t GetNPrim() const { return fNPrim; }    /// number of input tracks
    Bool_t IsSet() const { return fIsSet; }      /// Flag
    Double_t GetRotX() const { return fRotX; }   /// rot. around x-axis [rad]
    Double_t GetRotY() const { return fRotY; }   /// rot. around y-axis [rad]
    Double_t GetRotZ() const { return fRotZ; }   /// rot. around z-axis [rad]

    void GetVertex(TVector3& vertex) { vertex.SetXYZ(fX, fY, fZ); }

    /** Modifiers **/
    void SetEventID(EventID eventId) { fEventId = eventId; }
    void SetRunID(UInt_t runId) { fRunId = runId; }
    void SetTime(Double_t t) { fT = t; }
    void SetB(Double_t b) { fB = b; }
    void SetNPrim(Int_t nPrim) { fNPrim = nPrim; }
    void MarkSet(Bool_t isSet) { fIsSet = isSet; }
    void SetVertex(Double_t x, Double_t y, Double_t z);
    void SetVertex(const TVector3& vertex);
    void SetRotX(Double_t rotx) { fRotX = rotx; }
    void SetRotY(Double_t roty) { fRotY = roty; }
    void SetRotZ(Double_t rotz) { fRotZ = rotz; }

    /** Reset all members **/
    void Reset();

    /** Register the class as data branch to the output */
    virtual void Register();

  protected:
    UInt_t fRunId;                 ///  Run identifier
    EventID fEventId{NoEventID};   ///  Event identifier
    Double32_t fX;                 ///  Primary vertex x [cm]
    Double32_t fY;                 ///  Primary vertex y [cm]
    Double32_t fZ;                 ///  Primary vertex z [cm]
    Double32_t fT;                 ///  Event time [s]
    Double32_t fB;                 ///  Impact parameter [fm] (if relevant)
    Int_t fNPrim;                  ///  Number of input tracks
    Bool_t fIsSet;                 ///  Flag whether variables are filled
    Double32_t fRotX;              ///  Rotation around x-axis (beam tilt) [rad]
    Double32_t fRotY;              ///  Rotation around y-axis (beam tilt) [rad]
    Double32_t fRotZ;              ///  Rotation around z-axis (event plane) [rad]

    ClassDef(FairMCEventHeader, 2);
};

inline void FairMCEventHeader::SetVertex(Double_t x, Double_t y, Double_t z)
{
    fX = x;
    fY = y;
    fZ = z;
}

inline void FairMCEventHeader::SetVertex(const TVector3& vertex)
{
    fX = vertex.X();
    fY = vertex.Y();
    fZ = vertex.Z();
}

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**  FairMCPoint.h
 * This is the base class for all MC Points generated by the transport of
 * tracks through active detectors.
 **/

#ifndef FAIRMCPOINT_H
#define FAIRMCPOINT_H

#include "FairMultiLinkedData_Interface.h"   // for FairMultiLinkedData

#include <Rtypes.h>     // for Double_t, Double32_t, Int_t, etc
#include <TVector3.h>   // for TVector3

class FairMCPoint : public FairMultiLinkedData_Interface
{
  public:
    /** Default constructor **/
    FairMCPoint();

    /** Constructor with arguments
     *@param trackID  Index of MCTrack
     *@param detID    Detector ID
     *@param pos      Point coordinates [cm]
     *@param mom      Momentum of track at MCPoint [GeV]
     *@param tof      Time since event start [ns]
     *@param length   Track length since creation [cm]
     *@param eLoss    Energy deposit [GeV]
     *@param EventId  MC event id
     **/
    FairMCPoint(Int_t trackID,
                Int_t detID,
                TVector3 pos,
                TVector3 mom,
                Double_t tof,
                Double_t length,
                Double_t eLoss,
                UInt_t EventId = 0);

    /** Destructor **/
    virtual ~FairMCPoint();

    /** Accessors */
    UInt_t GetEventID() const { return fEventId; }   /// event identifier
    Int_t GetTrackID() const { return fTrackID; }
    Double_t GetPx() const { return fPx; }
    Double_t GetPy() const { return fPy; }
    Double_t GetPz() const { return fPz; }
    Double_t GetTime() const { return fTime; }
    Double_t GetLength() const { return fLength; }
    Double_t GetEnergyLoss() const { return fELoss; }
    void Momentum(TVector3& mom) const { mom.SetXYZ(fPx, fPy, fPz); }
    Int_t GetDetectorID() const { return fDetectorID; };
    Double_t GetX() const { return fX; };
    Double_t GetY() const { return fY; };
    Double_t GetZ() const { return fZ; };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); }

    /** Modifiers **/
    void SetEventID(UInt_t eventId) { fEventId = eventId; }
    virtual void SetTrackID(Int_t id) { fTrackID = id; }
    void SetTime(Double_t time) { fTime = time; }
    void SetLength(Double_t length) { fLength = length; }
    void SetEnergyLoss(Double_t eLoss) { fELoss = eLoss; }
    void SetMomentum(const TVector3& mom);
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);

    /** Output to screen **/
    virtual void Print(const Option_t* opt = 0) const;

  protected:
    Int_t fTrackID;             ///< Track index
    UInt_t fEventId;            ///< MC Event id
    Double32_t fPx, fPy, fPz;   ///< Momentum components [GeV]
    Double32_t fTime;           ///< Time since event start [ns]
    Double32_t fLength;         ///< Track length since creation [cm]
    Double32_t fELoss;          ///< Energy loss at this point [GeV]
    Int_t fDetectorID;          ///< Detector unique identifier
    Double32_t fX, fY, fZ;      ///< Position of hit [cm]

    ClassDef(FairMCPoint, 5);
};

inline void FairMCPoint::SetMomentum(const TVector3& mom)
{
    fPx = mom.Px();
    fPy = mom.Py();
    fPz = mom.Pz();
}

inline void FairMCPoint::SetXYZ(Double_t x, Double_t y, Double_t z)
{
    fX = x;
    fY = y;
    fZ = z;
}

inline void FairMCPoint::SetPosition(const TVector3& pos)
{
    fX = pos.X();
    fY = pos.Y();
    fZ = pos.Z();
}

#endif   // FAIRMCPOINT_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairMesh header file                    -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------

#ifndef FAIRMESH_H
#define FAIRMESH_H

#include <Rtypes.h>    // for Double_t, Int_t, etc
#include <TH2.h>       // for TH2D
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString

/**
 * Abstract base class for Mesh Objects.
 **@author D.Bertini <d.bertini@gsi.de>
 */
class FairMesh : public TObject
{
  public:
    /** Default constructor **/
    FairMesh();
    FairMesh(const char*);

    /** Destructor **/
    virtual ~FairMesh();

    /** Accessors **/
    Double_t GetXmin() const { return fXmin; };
    Double_t GetYmin() const { return fYmin; };
    Double_t GetZmin() const { return fZmin; };

    Double_t GetXmax() const { return fXmax; };
    Double_t GetYmax() const { return fYmax; };
    Double_t GetZmax() const { return fZmax; };

    /** Modifiers **/
    void SetX(Double_t xmin, Double_t xmax, Int_t nbin)
    {
        fXmin = xmin;
        fXmax = xmax;
        NXbin = nbin;
    }
    void SetY(Double_t ymin, Double_t ymax, Int_t nbin)
    {
        fYmin = ymin;
        fYmax = ymax;
        NYbin = nbin;
    }
    void SetZ(Double_t zmin, Double_t zmax, Int_t nbin)
    {
        fZmin = zmin;
        fZmax = zmax;
        NZbin = nbin;
    }

    TH2D* GetMeshTid() { return fMeshTid; }
    TH2D* GetMeshFlu() { return fMeshFlu; }
    TH2D* GetMeshSEU() { return fMeshSEU; }
    /*** Output to screen */
    // virtual void Print(const Option_t* opt = 0) const {;}

    Double_t GetDiag() { return fDiag; }
    Double_t GetBinVolume() { return fBinVolume; }

    void fillTID(Double_t x, Double_t y, Double_t we) { fMeshTid->Fill(x, y, we); }
    void fillFluence(Double_t x, Double_t y, Double_t we) { fMeshFlu->Fill(x, y, we); }
    void fillSEU(Double_t x, Double_t y, Double_t we) { fMeshSEU->Fill(x, y, we); }
    void Scale(Double_t fac)
    {
        fMeshTid->Scale(fac);
        fMeshFlu->Scale(fac);
        fMeshSEU->Scale(fac);
    }

    void calculate();

    void print();

  protected:
    Double_t fXmin, fYmin, fZmin;
    Double_t fXmax, fYmax, fZmax;
    Int_t NXbin, NYbin, NZbin;
    Double_t fBinVolume;
    Double_t fDiag;
    TH2D* fMeshTid;   // !mesh
    TH2D* fMeshFlu;   // !mesh
    TH2D* fMeshSEU;   // !mesh
    TString fhname;   // !mesh

  private:
    FairMesh(const FairMesh&);
    FairMesh& operator=(const FairMesh&);

    ClassDef(FairMesh, 1);
};

#endif
/**
 * FairMultiLinkedData_Interface.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FairMultiLinkedData_Interface_H_
#define FairMultiLinkedData_Interface_H_

#include "FairLink.h"   // for FairLink
#include "FairMultiLinkedData.h"

#include <Rtypes.h>    // for Int_t, Bool_t, kFALSE, etc
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString
#include <iostream>    // for operator<<, ostream, cout
#include <memory>      // for std::unique_ptr
#include <set>         // for set
#include <vector>      // for vector

class FairMultiLinkedData_Interface : public TObject
{
  public:
    FairMultiLinkedData_Interface() = default;   ///< Default constructor
    FairMultiLinkedData_Interface(FairMultiLinkedData& links, Bool_t persistanceCheck = kTRUE);   ///< Constructor
    FairMultiLinkedData_Interface(TString dataType,
                                  std::vector<Int_t> links,
                                  Int_t fileId = -1,
                                  Int_t evtId = -1,
                                  Bool_t persistanceCheck = kTRUE,
                                  Bool_t bypass = kFALSE,
                                  Float_t mult = 1.0);   ///< Constructor
    FairMultiLinkedData_Interface(Int_t dataType,
                                  std::vector<Int_t> links,
                                  Int_t fileId = -1,
                                  Int_t evtId = -1,
                                  Bool_t persistanceCheck = kTRUE,
                                  Bool_t bypass = kFALSE,
                                  Float_t mult = 1.0);   ///< Constructor
    FairMultiLinkedData_Interface(const FairMultiLinkedData_Interface& toCopy);

    ~FairMultiLinkedData_Interface() = default;

    FairMultiLinkedData_Interface& operator=(const FairMultiLinkedData_Interface& rhs);

    std::set<FairLink> GetLinks() const;                      ///< returns stored links as FairLinks
    Int_t GetNLinks() const;                                  ///< returns the number of stored links
    FairLink GetLink(Int_t pos) const;                        ///< returns the FairLink at the given position
    FairMultiLinkedData GetLinksWithType(Int_t type) const;   ///< returns all FairLinks with the corresponding type
    FairLink GetEntryNr() const;
    FairMultiLinkedData* GetPointerToLinks() const { return fLink.get(); }   ///< returns non-owning pointer

    std::vector<FairLink> GetSortedMCTracks();

    void SetLinks(FairMultiLinkedData links);   ///< Sets the links as vector of FairLink
    void SetLink(FairLink link);                ///< Sets the Links with a single FairLink
    void SetInsertHistory(Bool_t val);
    void SetEntryNr(FairLink val);
    ///< @param[in] links transfers ownership
    void SetPointerToLinks(FairMultiLinkedData* links) { fLink.reset(links); }
    void SetPointerToLinks(std::unique_ptr<FairMultiLinkedData> links) { fLink = std::move(links); }

    void AddLinks(FairMultiLinkedData links,
                  Float_t mult = 1.0);   ///< Adds a List of FairLinks (FairMultiLinkedData_Interface) to fLinks
    void AddLink(FairLink link);   ///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link is allowed
                                   ///< more than once otherwise
    void AddInterfaceData(FairMultiLinkedData_Interface* data);

    void ResetLinks();

    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const
    {
        if (GetPointerToLinks() != 0)
            GetPointerToLinks()->PrintLinkInfo(out);
        return out;
    }   ///< Output

    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData_Interface& data)
    {
        data.PrintLinkInfo(out);
        return out;
    }   ///< Output

  protected:
    std::unique_ptr<FairMultiLinkedData> fLink;
    FairMultiLinkedData* CreateFairMultiLinkedData();   ///< returns non-owning pointer

    ClassDef(FairMultiLinkedData_Interface, 6);
};

/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is
 * stored
 */

/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is
 * stored
 */

#endif /* FairMultiLinkedData_Interface_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * FairMultiLinkedData.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FAIRMULTILINKEDDATA_H_
#define FAIRMULTILINKEDDATA_H_

#include "FairLink.h"   // for FairLink

#include <Rtypes.h>    // for Int_t, Bool_t, kFALSE, etc
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString
#include <iosfwd>      // for ostream
#include <iostream>    // for operator<<, ostream, cout
#include <set>         // for set
#include <vector>      // for vector

class FairMultiLinkedData : public TObject
{
  public:
    FairMultiLinkedData();                                                                   ///< Default constructor
    FairMultiLinkedData(const std::set<FairLink>& links, Bool_t persistanceCheck = kTRUE);   ///< Constructor
    FairMultiLinkedData(TString dataType,
                        const std::vector<Int_t>& links,
                        Int_t fileId = -1,
                        Int_t evtId = -1,
                        Bool_t persistanceCheck = kTRUE,
                        Bool_t bypass = kFALSE,
                        Float_t mult = 1.0);   ///< Constructor
    FairMultiLinkedData(Int_t dataType,
                        const std::vector<Int_t>& links,
                        Int_t fileId = -1,
                        Int_t evtId = -1,
                        Bool_t persistanceCheck = kTRUE,
                        Bool_t bypass = kFALSE,
                        Float_t mult = 1.0);   ///< Constructor

    virtual ~FairMultiLinkedData(){};

    virtual std::set<FairLink> GetLinks() const { return fLinks; }   ///< returns stored links as FairLinks
    virtual FairLink GetEntryNr() const { return fEntryNr; }         ///< gives back the entryNr
    virtual Int_t GetNLinks() const { return fLinks.size(); }        ///< returns the number of stored links
    virtual FairLink GetLink(Int_t pos) const;                       ///< returns the FairLink at the given position
    virtual FairMultiLinkedData GetLinksWithType(
        Int_t type) const;   ///< Gives you a list of links which contain the given type
    virtual std::vector<FairLink>
        GetSortedMCTracks();   ///< Gives you a list of all FairLinks pointing to a "MCTrack" sorted by their weight
    TObject* GetData(FairLink& myLink);   ///< Get the TObject the Link is pointing to
    virtual Int_t GetDefaultType() { return fDefaultType; }
    Bool_t GetPersistanceCheck() { return fPersistanceCheck; }   ///< Returns the value of PersistanceCheck
    Int_t GetVerbose() { return fVerbose; }                      ///< Returns the verbosity level
    virtual void SetDefaultType(Int_t type) { fDefaultType = type; }
    virtual void SetPersistanceCheck(Bool_t check)
    {
        fPersistanceCheck = check;
    }   ///< Controls if a persistance check of a link is done or not
    virtual void SetVerbose(Int_t level) { fVerbose = level; }   ///< Sets the verbosity level
    virtual void SetInsertHistory(Bool_t val)
    {
        fInsertHistory = val;
    }   ///< Toggles if history of a link is inserted or not
    Bool_t GetInsertHistory() const { return fInsertHistory; }

    virtual void SetEntryNr(FairLink entry) { fEntryNr = entry; }
    virtual void SetLinks(FairMultiLinkedData links, Float_t mult = 1.0);   ///< Sets the links as vector of FairLink
    virtual void SetLink(FairLink link,
                         Bool_t bypass = kFALSE,
                         Float_t mult = 1.0);   ///< Sets the Links with a single FairLink

    virtual void AddLinks(FairMultiLinkedData links,
                          Float_t mult = 1.0);   ///< Adds a List of FairLinks (FairMultiLinkedData) to fLinks
    virtual void AddLink(FairLink link,
                         Bool_t bypass = kFALSE,
                         Float_t mult = 1.0);   ///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link
                                                ///< is allowed more than once otherwise it is stored only once

    virtual void InsertLink(FairLink link);   ///< Inserts a link into the list of links without persistance checking
    virtual void InsertHistory(
        FairLink link);   ///< Adds the FairLinks of the inserted link to the set of links of this object

    virtual void AddAllWeights(Double_t weight);        ///< Adds weight to all Links
    virtual void SetAllWeights(Double_t weight);        ///< Sets a common weight for Links
    virtual void MultiplyAllWeights(Double_t weight);   ///< Multiplies all Links with weight

    virtual Bool_t IsLinkInList(FairLink link)
    {
        return IsLinkInList(link.GetType(), link.GetIndex());
    }   ///< Test if a given link is in fLinks
    virtual Bool_t IsLinkInList(
        Int_t type,
        Int_t index);   ///< Same as IsLinkInList(FairLink) just with type and index given separately
    virtual Int_t LinkPosInList(FairLink link)
    {
        return LinkPosInList(link.GetType(), link.GetIndex());
    }   ///< returns position of link in fLinks. If it is not in the list -1 is returned
    virtual Int_t LinkPosInList(Int_t type, Int_t index);   ///< Same as LinkPosInList(FairLink)

    virtual void DeleteLink(FairLink link)
    {
        DeleteLink(link.GetType(), link.GetIndex());
    }                                                   ///< Deletes a link ouf of fLinks
    virtual void DeleteLink(Int_t type, Int_t index);   ///< Deletes a link ouf of fLinks

    virtual void Reset() { ResetLinks(); }
    virtual void ResetLinks() { fLinks.clear(); }   ///< Clears fLinks

    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const
    {
        out << GetEntryNr() << " -> [";
        for (Int_t i = 0; i < GetNLinks(); i++) {
            GetLink(i).PrintLinkInfo(out);
            out << " ";
        }
        out << "]";
        return out;
    }   ///< Output

    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData& data)
    {
        data.PrintLinkInfo(out);
        return out;
    }   ///< Output

  protected:
    std::set<FairLink> fLinks;
    FairLink fEntryNr;
    Bool_t fPersistanceCheck;   //!
    Bool_t fInsertHistory;      //!
    Int_t fVerbose;             //!

    virtual void SimpleAddLinks(Int_t fileId,
                                Int_t evtId,
                                Int_t dataType,
                                const std::vector<Int_t>& links,
                                Bool_t,
                                Float_t)
    {
        for (UInt_t i = 0; i < links.size(); i++) {
            fLinks.insert(FairLink(fileId, evtId, dataType, links[i]));
        }
    }
    Int_t fDefaultType;

    ClassDef(FairMultiLinkedData, 4);
};

/**\fn virtual void FairMultiLinkedData::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is
 * stored
 */

/**\fn virtual void FairMultiLinkedData::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is
 * stored
 */

#endif /* FAIRMULTILinkedData_H_ */
// -------------------------------------------------------------------------
// -----                 FairPrintFairLinks header file             -----
// -----                  Created 20/03/07  by R.Kliemt               -----
// -------------------------------------------------------------------------

/** FairPrintFairLinks.h
 *@author T.Stockmanns <t.stockmanns@fz-juelich.de>
 **
 ** Prints all FairLinks of a given branch to the screen
 **/

#ifndef FairPrintFairLinks_H
#define FairPrintFairLinks_H

// framework includes
#include "FairTask.h"
#include "TObjString.h"

#include <map>

class TClonesArray;

class FairPrintFairLinks : public FairTask
{
  public:
    /** Default constructor **/
    FairPrintFairLinks();

    /** Destructor **/
    virtual ~FairPrintFairLinks();

    virtual void AddBranchName(const TString& name) { fSelectedBranches->AddLast(new TObjString(name.Data())); }

    virtual void PrintBranchNameList(TList* branches);

    virtual InitStatus Init();

    /** Virtual method Exec **/
    virtual void Exec(Option_t* opt);

    virtual void Finish();

  protected:
    void InitBranchList(TList* branches);

  private:
    std::map<Int_t, TClonesArray*> fBranches;
    TList* fSelectedBranches;

    void Register();
    void Reset();
    void ProduceHits();

    ClassDef(FairPrintFairLinks, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenPoint header file               -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------

/**  FairRadLenPoint.h
 *@author M. Al-Turany
 *
 */

#ifndef FAIRRADLENPOINT_H
#define FAIRRADLENPOINT_H

#include "FairMCPoint.h"   // for FairMCPoint

#include <Rtypes.h>     // for Double_t, Float_t, etc
#include <TVector3.h>   // for TVector3

class FairRadLenPoint : public FairMCPoint
{
  public:
    /** Default constructor **/
    FairRadLenPoint();

    FairRadLenPoint(Int_t trackID,
                    Int_t detID,
                    TVector3 pos,
                    TVector3 mom,
                    Double_t tof,
                    Double_t length,
                    Double_t eLoss,
                    TVector3 posOut,
                    TVector3 momOut,
                    Float_t fA,
                    Float_t fZ,
                    Float_t fDensity,
                    Float_t fRadLen);

    /** Destructor **/
    virtual ~FairRadLenPoint();

    /** Accessors **/
    Float_t GetA() { return fA; }
    Float_t GetZm() { return fZmat; }
    Float_t GetRadLength() { return fRadLen; }
    Float_t GetDensity() { return fDensity; }

    /** Modifiers **/
    void SetA(Double_t A) { fA = A; }
    void SetZm(Double_t Z) { fZmat = Z; }
    void SetRadLength(Double_t length) { fRadLen = length; }
    void SetDensity(Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Double_t GetXOut() const { return fXOut; };
    Double_t GetYOut() const { return fYOut; };
    Double_t GetZOut() const { return fZOut; };

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ); }
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut); }

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut); };
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut, fPyOut, fPzOut); }

  protected:
    Float_t fA;         // A of material
    Float_t fZmat;      // Z of material
    Float_t fDensity;   // density of material
    Float_t fRadLen;    // radiation length

    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;

    ClassDef(FairRadLenPoint, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairRadMapPoint header file               -----
// -------------------------------------------------------------------------

/**  FairRadMapPoint.h
 *@author O.N. Hartmann
 *
 */

#ifndef FAIRRADMAPPOINT_H
#define FAIRRADMAPPOINT_H

#include "FairMCPoint.h"   // for FairMCPoint

#include <Rtypes.h>     // for Double_t, Float_t, Int_t, etc
#include <TVector3.h>   // for TVector3

class FairRadMapPoint : public FairMCPoint
{
  public:
    /** Default constructor **/
    FairRadMapPoint();

    FairRadMapPoint(Int_t trackID,
                    Int_t detID,
                    TVector3 pos,
                    TVector3 mom,
                    Double_t tof,
                    Double_t length,
                    Double_t eLoss,
                    TVector3 posOut,
                    TVector3 momOut,
                    Float_t fA,
                    Float_t fZ,
                    Float_t fDensity,
                    Double_t fVolMass,
                    Double_t fStep,
                    Double_t fDose,
                    Double_t fDoseSL,
                    Int_t fPdg);

    /** Destructor **/
    virtual ~FairRadMapPoint();

    /** Accessors **/
    Float_t GetA() { return fA; }
    Float_t GetZm() { return fZmat; }
    Float_t GetMass() { return fVolMass; }
    Float_t GetDensity() { return fDensity; }

    /** Modifiers **/
    void SetA(Double_t A) { fA = A; }
    void SetZm(Double_t Z) { fZmat = Z; }
    void SetMass(Double_t vmass) { fVolMass = vmass; }
    void SetDensity(Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Int_t GetPdg() const { return fPdg; };

    Double_t GetXOut() const { return fXOut; }
    Double_t GetYOut() const { return fYOut; }
    Double_t GetZOut() const { return fZOut; }

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    Double_t GetDose() const { return fDose; }
    Double_t GetDoseSL() const { return fDoseSL; }

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ); }
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut); }

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut); };
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut, fPyOut, fPzOut); }

  protected:
    // Int_t detID; // detector ID or volume ID
    Int_t fPdg;          // track PID
    Float_t fA;          // A of material
    Float_t fZmat;       // Z of material
    Float_t fDensity;    // density of material
    Double_t fVolMass;   // radiation length

    Double_t fStep, fDose, fDoseSL;
    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;

    ClassDef(FairRadMapPoint, 3);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----          FairRecoEventHeader header file                      -----
// -----          Created 20/09/13                 R.Karabowicz        -----
// -------------------------------------------------------------------------

#ifndef FAIRRECOEVENTHEADER_H
#define FAIRRECOEVENTHEADER_H

#include <TNamed.h>

/**
 *  Event Header Class
 **@author D.Bertini <d.bertini@gsi.de>
 **@author M.Al-Turany <m.al-turany@gsi.de>
 **@author R.Karabowicz <r.karabowicz@gsi.de>
 */
class FairRecoEventHeader : public TNamed
{
  public:
    /** Default constructor */
    FairRecoEventHeader();

    /** Get the run ID for this run*/
    UInt_t GetRunId() const { return fRunId; }

    /** Get the MC time for this event*/
    Double_t GetEventTime() const { return fEventTime; }

    /** Get the error of MC time for this event*/
    Double_t GetEventTimeError() const { return fEventTimeError; }

    /** Get identifier*/
    Int_t GetIdentifier() const { return fIdentifier; }

    /** Set the run ID for this run
     * @param runid : unique run id
     */
    void SetRunId(UInt_t runid) { fRunId = runid; }

    /** Set the MC time for this event
     * @param time : time in ns
     * @param terr : time error in ns
     */
    void SetEventTime(Double_t time, Double_t terr)
    {
        fEventTime = time;
        fEventTimeError = terr;
    }

    /** Set the run ID for this run
     * @param ident : identifier
     */
    void SetIdentifier(Int_t ident) { fIdentifier = ident; }

    virtual bool operator<(const FairRecoEventHeader& tempObj) const
    {
        if (fEventTime < tempObj.GetEventTime()) {
            return true;
        } else if (fEventTime > tempObj.GetEventTime()) {
            return false;
        }
        return false;
    }

    virtual bool operator>(const FairRecoEventHeader& tempObj) const
    {
        if (fEventTime > tempObj.GetEventTime()) {
            return true;
        } else if (fEventTime < tempObj.GetEventTime()) {
            return false;
        }
        return false;
    }

    virtual bool operator==(const FairRecoEventHeader& tempObj) const { return fEventTime == tempObj.GetEventTime(); }

    /**
     * Destructor
     */
    virtual ~FairRecoEventHeader();

  protected:
    /** Run Id */
    UInt_t fRunId;
    /** Identifier */
    Int_t fIdentifier;
    /** Event Time **/
    Double_t fEventTime;
    /** Event Time Error **/
    Double_t fEventTimeError;

    ClassDef(FairRecoEventHeader, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNINFO_H
#define FAIRRUNINFO_H

#include <Rtypes.h>       // for Double_t, Long_t, etc
#include <TObject.h>      // for TObject
#include <TSystem.h>      // for CpuInfo_t, MemInfo_t, etc
#include <TTimeStamp.h>   // for TTimeStamp
#include <vector>         // for vector

class TList;

class FairRunInfo : public TObject
{
  public:
    FairRunInfo();
    ~FairRunInfo();

    void StoreInfo();
    void WriteInfo();
    void Reset();

  private:
    TTimeStamp fTimeStamp;                 //!
    CpuInfo_t fCpuInfo;                    //!
    MemInfo_t fMemInfo;                    //!
    ProcInfo_t fProcInfo;                  //!
    std::vector<Double_t> fTimeDiff;       //!
    std::vector<Double_t> fTime;           //!
    std::vector<Long_t> fResidentMemory;   //!
    std::vector<Long_t> fVirtualMemory;    //!

    void CalculateTimeDifference();
    void PrintInfo();
    void GetInfo();
    void CreateAndFillHistograms(TList* histoList);
    void WriteHistosToFile(TList* histoList);

    FairRunInfo(const FairRunInfo&);
    FairRunInfo& operator=(const FairRunInfo&);

    ClassDef(FairRunInfo, 2);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRTIMESTAMP_H
#define FAIRTIMESTAMP_H

#include "FairMultiLinkedData_Interface.h"   // for FairMultiLinkedData

#include <Rtypes.h>   // for Double_t, etc
#include <iosfwd>     // for ostream
#include <iostream>   // for ostream, cout

class TObject;

/**
 * Base class for Time stamp information
 ** Aug. 2010
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairTimeStamp : public FairMultiLinkedData_Interface
{
  public:
    /** Default constructor **/
    FairTimeStamp();
    /** Constructor with time **/
    FairTimeStamp(Double_t time);
    /** Constructor with time and time error **/
    FairTimeStamp(Double_t time, Double_t timeerror);

    /** Destructor **/
    virtual ~FairTimeStamp(){};
    /** Accessors **/
    Double_t GetTimeStamp() const { return fTimeStamp; }
    Double_t GetTimeStampError() const { return fTimeStampError; }
    /** Modifiers **/
    void SetTimeStamp(Double_t t) { fTimeStamp = t; }
    void SetTimeStampError(Double_t t) { fTimeStampError = t; }
    virtual Int_t Compare(const TObject* obj) const
    {
        if (this == obj) {
            return 0;
        }
        FairTimeStamp* tsobj = static_cast<FairTimeStamp*>(const_cast<TObject*>(obj));
        Double_t ts = tsobj->GetTimeStamp();
        Double_t tserror = tsobj->GetTimeStampError();
        if (fTimeStamp < ts) {
            return -1;
        } else if (fTimeStamp == ts && fTimeStampError < tserror) {
            return -1;
        } else if (fTimeStamp == ts && fTimeStampError == tserror) {
            return 0;
        } else {
            return 1;
        }
    }

    virtual std::ostream& PrintTimeInfo(std::ostream& out = std::cout) const;
    virtual Bool_t IsSortable() const { return kTRUE; };

    virtual bool equal(FairTimeStamp* data)
    {
        return (fTimeStamp == data->GetTimeStamp() && fTimeStampError == data->GetTimeStampError());
    }

    friend std::ostream& operator<<(std::ostream& out, const FairTimeStamp& link)
    {
        link.PrintTimeInfo(out);
        return out;
    }

    virtual bool operator<(const FairTimeStamp* rValue) const { return GetTimeStamp() < rValue->GetTimeStamp(); }

  protected:
    Double_t fTimeStamp;      /** Time of digit or Hit  [ns] */
    Double_t fTimeStampError; /** Error on time stamp */

    ClassDef(FairTimeStamp, 4);
};

// -----   Default constructor   -------------------------------------------
inline FairTimeStamp::FairTimeStamp()
    : FairMultiLinkedData_Interface()
    , fTimeStamp(-1)
    , fTimeStampError(-1)
{}

// -----   Standard constructor   ------------------------------------------
inline FairTimeStamp::FairTimeStamp(Double_t time)
    : FairMultiLinkedData_Interface()
    , fTimeStamp(time)
    , fTimeStampError(-1)
{}

inline FairTimeStamp::FairTimeStamp(Double_t time, Double_t timeerror)
    : FairMultiLinkedData_Interface()
    , fTimeStamp(time)
    , fTimeStampError(timeerror)
{}

#endif   // FAIRTIMESTAMP_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairTrackParam header file                 -----
// -----                  Created 27/01/05  by V. Friese               -----
// -------------------------------------------------------------------------

/**  FairTrackParam.h
 *@author V.Friese <v.friese@gsi.de>
 **
 ** Parameters (x, y, tx, ty, q/p) of a track
 ** resulting from the track fit. The z coordinate is not a parameter.
 ** The 5x5 covariance matrix can be set and accessed by either an array
 ** of size 15, the TMatrixFSym class or elementwise. Note that TMatrixFSym
 ** should not be used when performance is an issue.
 ** The internal representation of the covariance matrix elements is
 ** an array of double.
 **/

#ifndef FAIRSTSTRACKPARAM
#define FAIRSTSTRACKPARAM 1

#include <Rtypes.h>           // for Double_t, Double32_t, Int_t, etc
#include <TMatrixFSymfwd.h>   // for TMatrixFSym
#include <TObject.h>          // for TObject
#include <TVector3.h>         // for TVector3

class FairTrackParam : public TObject
{
  public:
    /** Constructor **/
    FairTrackParam();

    /** Constructor with all variables **/
    FairTrackParam(Double_t x,
                   Double_t y,
                   Double_t z,
                   Double_t tx,
                   Double_t ty,
                   Double_t qp,
                   const TMatrixFSym& covMat);

    /** Copy constructor **/
    FairTrackParam(const FairTrackParam& param);

    /** Destructor **/
    virtual ~FairTrackParam();

    /** Output to screen **/
    void Print(Option_t* option = "") const;

    /** Accessors **/
    Double_t GetX() const { return fX; };
    Double_t GetY() const { return fY; };
    Double_t GetZ() const { return fZ; };
    Double_t GetTx() const { return fTx; };
    Double_t GetTy() const { return fTy; };
    Double_t GetQp() const { return fQp; };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); };
    void Momentum(TVector3& mom) const;
    void CovMatrix(Double_t cov[]) const;
    void CovMatrix(TMatrixFSym& covMat) const;
    Double_t GetCovariance(Int_t i, Int_t j) const;

    /** Modifiers **/
    void SetX(Double_t x) { fX = x; };
    void SetY(Double_t y) { fY = y; };
    void SetZ(Double_t z) { fZ = z; };
    void SetTx(Double_t tx) { fTx = tx; };
    void SetTy(Double_t ty) { fTy = ty; };
    void SetQp(Double_t qp) { fQp = qp; };
    void SetPosition(const TVector3& pos);
    void SetCovMatrix(Double_t cov[]);
    void SetCovMatrix(const TMatrixFSym& covMat);
    void SetCovariance(Int_t i, Int_t j, Double_t val);

    /** Assignment operator  **/
    FairTrackParam& operator=(const FairTrackParam& par);

  private:
    /** Position of track at given z [cm] **/
    Double32_t fX, fY, fZ;

    /** Direction of track tx = dx/dz; ty = dy/dz **/
    Double32_t fTx, fTy;

    /** Charge over momentum [1/GeV] **/
    Double32_t fQp;

    /** Covariance matrix for the variables x, y, tx, ty, q/p
     ** The 15 elements of the upper triangle of the symmetric matrix
     ** are stored in an array of floats. The sequence of the array is
     ** a[0,0..4], a[1,1..4], a[2,2..4], a[3,3..4], a[4,4].
     **/

    Double32_t fCovMatrix[15];

    ClassDef(FairTrackParam, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairField header file                     -----
// -----                Created 06/01/04  by M. Al-Turany              -----
// -----                Redesign 13/02/06  by V. Friese                -----
// -----                Redesign 04/08/06  by M. Al-Turany               -----
// -------------------------------------------------------------------------

/** FairField.h
 ** @author M.Al-Turany <m.al/turany@gsi.de>
 ** @author V.Friese <v.friese@gsi.de>
 ** @since 06.01.2004
 ** @version 1.0
 **
 ** Abstract base class for magnetic fields in FAIR
 ** Concrete field should implement the pure virtual methods
 ** GetBx, GetBy and GetBz and/or  GetBxyz
 **
 ** Note: Field values should be returned in kG (thanks to Geant3)
 **/

#ifndef FAIRFIELD_H
#define FAIRFIELD_H 1

#include "FairLogger.h"

#include <Rtypes.h>   // for Double_t, Bool_t, etc
#include <TVirtualMagField.h>

class FairField : public TVirtualMagField
{
  public:
    /** Default constructor **/
    FairField();

    /** Constructor with name and title **/
    FairField(const char* name, const char* title = "FAIR Magnetic Field");

    FairField& operator=(const FairField&) { return *this; }

    /** Destructor **/
    virtual ~FairField();

    /** Intialisation. E.g. read in the field map. If needed, to be
     ** implemented in the concrete class.
     **/
    virtual void Init(){};

    /** Test whether field type is Constant **/
    Bool_t IsConst();

    /** Test whether field typ is Map **/
    Bool_t IsMap();

    /** Field type ( 0=constant, 1=map, 2=map sym2, 3 = map sym3 ) **/
    Int_t GetType() const { return fType; }

    /** Get x component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBx([[maybe_unused]] Double_t x, [[maybe_unused]] Double_t y, [[maybe_unused]] Double_t z)
    {
        LOG(warn) << "FairField::GetBx Should be implemented in User class";
        return 0;
    }

    /** Get y component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBy([[maybe_unused]] Double_t x, [[maybe_unused]] Double_t y, [[maybe_unused]] Double_t z)
    {
        LOG(warn) << "FairField::GetBy Should be implemented in User class";
        return 0;
    }

    /** Get z component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBz([[maybe_unused]] Double_t x, [[maybe_unused]] Double_t y, [[maybe_unused]] Double_t z)
    {
        LOG(warn) << "FairField::GetBz Should be implemented in User class";
        return 0;
    }

    /** Get magnetic field. For use of Geant3
     ** @param point            Coordinates [cm]
     ** @param bField (return)  Field components [kG]
     **/
    virtual void GetFieldValue(const Double_t point[3], Double_t* bField);

    void Field(const Double_t point[3], Double_t* B) { GetFieldValue(point, B); }

    /** Screen output. To be implemented in the concrete class. **/
    virtual void Print(Option_t*) const { ; }
    virtual void GetBxyz(const Double_t[3], Double_t*)
    {
        LOG(warn) << "FairField::GetBxyz Should be implemented in User class";
    }

    /**Fill Paramater*/
    virtual void FillParContainer() { LOG(warn) << "FairField::FillParContainer Should be implemented in User class"; }

  protected:
    /** Field type. 1 = constant field, 2 = field map. **/
    Int_t fType;

  private:
    FairField(const FairField&);
    //    FairField& operator=(const FairField&);
    // TODO: Check why the htrack needs this

    ClassDef(FairField, 4);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairFieldFactory header file                  -----
// -----                Created 15/01/07  by M. Al-Turany              -----
// -------------------------------------------------------------------------

#ifndef FAIRFIELDFACTORY_H
#define FAIRFIELDFACTORY_H

#include <Rtypes.h>   // for FairFieldFactory::Class, etc

class FairField;

class FairFieldFactory
{
  public:
    static FairFieldFactory* Instance();
    FairFieldFactory();
    virtual ~FairFieldFactory();
    virtual FairField* createFairField() = 0;
    virtual void SetParm() {}

  protected:
    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] FairFieldFactory* fCreator;
    static FairFieldFactory* fgRinstance;

    ClassDef(FairFieldFactory, 1);

  private:
    FairFieldFactory(const FairFieldFactory& M);
    FairFieldFactory& operator=(const FairFieldFactory&) { return *this; }
};

#endif   // FAIRFIELDFACTORY_H
/********************************************************************************
 * Copyright (C) 2014-2023 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASECONTFACT_H
#define FAIRBASECONTFACT_H

#include "FairContFact.h"   // for FairContFact, etc

#include <Rtypes.h>   // for FairBaseContFact::Class, etc

class FairParSet;

class FairBaseContFact : public FairContFact
{
    /** Factory for all Base parameter containers */
  public:
    /**default ctor*/
    FairBaseContFact();
    /**default dtor*/
    ~FairBaseContFact() override {}
    /** Calls the constructor of the corresponding parameter container.
     * For an actual context, which is not an empty string and not the default context
     * of this container, the name is concatinated with the context. */
    FairParSet* createContainer(FairContainer*) override;
    ClassDefOverride(FairBaseContFact, 0);
};

#endif /* !FAIRBASECONTFACT_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASEPARSET_H
#define FAIRBASEPARSET_H

/**
 * Parameter class for run
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"   // for FairParGenericSet

#include <Rtypes.h>        // for Double_t, etc
#include <TGeoManager.h>   // IWYU pragma: keep needed by cint

class FairParamList;
class FairPrimaryGenerator;
class TObjArray;

class FairBaseParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
     * @param title:  Parameter set title
     * @param context:  Parameter set context
     */

    FairBaseParSet(const char* name = "FairBaseParSet",
                   const char* title = "Class for base parameter io",
                   const char* context = "BaseDefaultContext");
    /** dtor*/
    ~FairBaseParSet() override;
    /** clear*/
    void clear() override;
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
     */
    void putParams(FairParamList*) override;
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*) override;
    /**
     * Set the detector list used in the simulation
     * @param array: TObjArray of detector
     */
    void SetDetList(TObjArray* array) { fDetList = array; }
    /**
     * Set the Generator used in the simulation
     * @param gen: Primary generator used in simulation
     */
    void SetGen(FairPrimaryGenerator* gen) { fPriGen = gen; }
    /**
     * Set the beam momentum (if any) used in the simulation
     * @param BMom: Beam Momentum in GeV/c
     */
    void SetBeamMom(Double_t BMom) { fBeamMom = BMom; }
    /**
     * Set the list of parameter containers used in a run
     * @param array: TObjArray of containers
     */
    void SetContListStr(TObjArray* list) { fContNameList = list; }
    /**
     * Set the random seed used in a run
     * @param RndSeed: Random Seed
     */
    void SetRndSeed(UInt_t RndSeed) { fRandomSeed = RndSeed; }
    /**
     *  Get the detector list used in the simulation
     */
    TObjArray* GetDetList() { return fDetList; }
    /**
     *  Get the Primery generator used in the simulation
     */
    FairPrimaryGenerator* GetPriGen() { return fPriGen; }
    /**
     *  Get the Beam Momentum used in the simulation (GeV/c)
     */
    Double_t GetBeamMom() { return fBeamMom; }
    /**
     *  Get the parameter container list used in this run
     */
    TObjArray* GetContList() { return fContNameList; }
    /**
     *  Get the Random Seed used in this run
     */
    UInt_t GetRndSeed() { return fRandomSeed; }

  protected:
    /// Detectors used in the simulation
    TObjArray* fDetList;
    /// Generator used for simulation
    FairPrimaryGenerator* fPriGen;
    /// Beam momentum (GeV/c)
    Double_t fBeamMom;
    /// List of parameter container names in the RUN
    TObjArray* fContNameList;
    /// Random Seed from gRandom
    UInt_t fRandomSeed;

    ClassDefOverride(FairBaseParSet, 6);

  private:
    FairBaseParSet(const FairBaseParSet& L);
    FairBaseParSet& operator=(const FairBaseParSet&) { return *this; }
};

#endif /* !FAIRBASEPARSET_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETECTOR_H
#define FAIRDETECTOR_H

#include "FairModule.h"   // for FairModule

#include <Rtypes.h>   // for Int_t, Bool_t, etc

class FairLogger;
class FairVolume;
class TClonesArray;

/**
 * Base class for constructing detecors
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairDetector : public FairModule
{
  public:
    /**
      constructor
      Name :  Detector Name
      Active: kTRUE for active detectors  (ProcessHits() will be called)
              kFALSE for inactive detectors
    */
    FairDetector(const char* Name, Bool_t Active, Int_t DetId = 0);
    /**
      default constructor
    */
    FairDetector();
    /**
      destructor
    */
    virtual ~FairDetector();
    /**
      Initialization of the detector is done here
    */
    virtual void Initialize();
    /**
      this method is called for each step during simulation (see FairMCApplication::Stepping())
    */
    virtual Bool_t ProcessHits(FairVolume* v = 0) = 0;
    /**
      this is called at the end of an event after the call to tree fill in the FairRootManager
    */
    virtual void EndOfEvent() {}
    /**
      Registers the produced collections in FAIRRootManager.
    */
    virtual void Register() = 0;

    /**
     Gets the produced collections
    */
    virtual TClonesArray* GetCollection(Int_t iColl) const = 0;
    /**
      has to be called after each event to reset the containers
    */
    virtual void Reset() = 0;

    virtual void CopyClones(TClonesArray*, TClonesArray*, Int_t) {}
    /**
     User actions after finishing of a primary track
    */
    virtual void FinishPrimary() {}
    /**
     Finish MC Run
    */
    virtual void FinishRun() {}
    /**
     User actions at beginning of a primary track
    */
    virtual void BeginPrimary() {}
    /**
     User actions after finishing of each track
    */
    virtual void PostTrack() {}
    /**
     User actions at beginning of each track
    */
    virtual void PreTrack() {}
    /**
     User actions at beginning of event
    */
    virtual void BeginEvent() {}
    /**
     this is called at the end of an event before the call to tree fill in the FairRootManager
    */
    virtual void FinishEvent() {}

    void SaveGeoParams();
    Int_t GetDetId() { return fDetId; }

  protected:
    /** Copy constructor */
    FairDetector(const FairDetector&);
    /** Assignment operator */
    FairDetector& operator=(const FairDetector&);

    void DefineSensitiveVolumes();

    Int_t fDetId;          // Detector Id has to be set from ctr.
    FairLogger* fLogger;   //! /// FairLogger

    ClassDef(FairDetector, 1);
};
#endif   // FAIRDETECTOR_H
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairGeaneApplication header file                   -----
// -----            Created 10/11/10  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_GEANE_APPLICATION_H
#define FAIR_GEANE_APPLICATION_H

#include <Rtypes.h>                  // for Bool_t, etc
#include <TLorentzVector.h>          // for TLorentzVector
#include <TVirtualMCApplication.h>   // for TVirtualMCApplication

class FairField;

/**
 * The Main Application for GEANE
 * @author M. Al-Turany
 * @version 0.1
 * @since 10.11.10
 */

class FairGeaneApplication : public TVirtualMCApplication
{
  public:
    /** default constructor */
    FairGeaneApplication();
    /** Special constructor, used for initializing G3 for Geane track propagation
     *@param Debug    true to print step info*/
    FairGeaneApplication(Bool_t Debug);
    /** default destructor */
    ~FairGeaneApplication() override;
    /** Return Field used in simulation*/
    FairField* GetField() { return fxField; }
    /** Initialize MC engine */
    void InitMC(const char* setup, const char* cuts);
    /**
     * Set the magnetic field for simulation or Geane
     * @param field: magnetic field
     */
    void SetField(FairField* field);
    /** Define action at each step, dispatch the action to the corresponding detectors */
    void GeaneStepping() override;   // MC Application
    void ConstructGeometry() override;
    /**
     * Singelton instance
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] static FairGeaneApplication* Instance()
    {
        return static_cast<FairGeaneApplication*>(TVirtualMCApplication::Instance());
    }

    /**pure virtual functions that hasve to be implimented */

    void InitGeometry() override { ; }
    void GeneratePrimaries() override { ; }
    void BeginEvent() override { ; }
    void BeginPrimary() override { ; }
    void PreTrack() override { ; }
    void PostTrack() override { ; }
    void FinishPrimary() override { ; }
    void FinishEvent() override { ; }
    void Stepping() override { ; }
    void StopRun() { ; }

  private:
    // data members
    /**Magnetic Field Pointer*/
    FairField* fxField;   //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t fMcVersion;   // mc Version
    /** Debug flag*/
    Bool_t fDebug;            //!
    TLorentzVector fTrkPos;   //!

    // Interface to MonteCarlo application
    ClassDefOverride(FairGeaneApplication, 1);

  private:
    FairGeaneApplication(const FairGeaneApplication&);
    FairGeaneApplication& operator=(const FairGeaneApplication&);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairGenerator header file                   -----
// -----          Created 09/06/04  by D. Bertini / V. Friese          -----
// -------------------------------------------------------------------------

/** FairGenerator.h
 *@author D.Bertini <d.bertini@gsi.de>
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairGenerator is the abtract base class for the generators used to
generate input for the transport simulation.Each concrete generator class
derived from this one must implement the abtract method ReadEvent,
which has to use the method FairPrimaryGenerator::AddTrack.
**/

#ifndef FAIRGENERATOR_H
#define FAIRGENERATOR_H

#include <Rtypes.h>   // for Bool_t, etc
#include <TNamed.h>   // for TNamed

class FairPrimaryGenerator;

class FairGenerator : public TNamed
{
  public:
    /** Default constructor. **/
    FairGenerator();

    /** Constructor with name and title **/
    FairGenerator(const char* name, const char* title = "FAIR Generator");

    /** Destructor. **/
    virtual ~FairGenerator();

    /** Abstract method ReadEvent must be implemented by any derived class.
        It has to handle the generation of input tracks (reading from input
        file) and the handing of the tracks to the FairPrimaryGenerator. I
        t is called from FairMCApplication.
        *@param pStack The stack
        *@return kTRUE if successful, kFALSE if not
    **/
    virtual Bool_t ReadEvent(FairPrimaryGenerator* primGen) = 0;

    /**Initialize the generator if needed */
    virtual Bool_t Init() { return kTRUE; }

    /**Finalize the generator if needed */
    virtual void Finish() { return; }

    /** Clone this object (used in MT mode only) */
    virtual FairGenerator* CloneGenerator() const;

  protected:
    /** Copy constructor */
    FairGenerator(const FairGenerator&);
    /** Assignment operator */
    FairGenerator& operator=(const FairGenerator&);

    ClassDef(FairGenerator, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairGenericStack header file            -----
// -----           Created 10/08/04  by D. Bertini                     -----
// -------------------------------------------------------------------------

/** FairGenericStack.h
 *@author D.Bertini <d.bertini@gsi.de>
 * Generic MC stack class
 **/

#ifndef FAIRGENERICSTACK_H
#define FAIRGENERICSTACK_H

#include <Rtypes.h>   // for Double_t, Int_t, etc
#include <TClonesArray.h>
#include <TMCProcess.h>        // for TMCProcess
#include <TVirtualMCStack.h>   // for TVirtualMCStack
#include <map>
#include <tuple>

class FairLogger;
class TParticle;
class TRefArray;
class TIterator;

class FairGenericStack : public TVirtualMCStack
{
  public:
    /** Default constructor  **/
    FairGenericStack();

    /** Destructor with estimated array size  **/
    FairGenericStack(Int_t size);

    /** Destructor  **/
    virtual ~FairGenericStack();

    /** Virtual method PushTrack.
     ** Add a TParticle to the stack.
     ** This function has an extra argument wrt to the function defined in the base class.
     *@param toBeDone         Flag for tracking
     *@param parentID         Index of mother particle
     *@param pdgCode          Particle type (PDG encoding)
     *@param px,py,pz         Momentum components at start vertex [GeV]
     *@param e                Total energy at start vertex [GeV]
     *@param vx,vy,vz         Coordinates of start vertex [cm]
     *@param time             Start time of track [s]
     *@param polx,poly,polz   Polarisation vector
     *@param proc             Production mechanism (VMC encoding)
     *@param ntr              Track number (filled by the stack)
     *@param weight           Particle weight
     *@param is               Generation status code (whatever that means)
     *@param secondparentID   used fot the index of mother of primery in the list
     **/
    virtual void PushTrack(Int_t toBeDone,
                           Int_t parentID,
                           Int_t pdgCode,
                           Double_t px,
                           Double_t py,
                           Double_t pz,
                           Double_t e,
                           Double_t vx,
                           Double_t vy,
                           Double_t vz,
                           Double_t time,
                           Double_t polx,
                           Double_t poly,
                           Double_t polz,
                           TMCProcess proc,
                           Int_t& ntr,
                           Double_t weight,
                           Int_t is,
                           Int_t secondparentID) = 0;

    /** Fill the MCTrack output array, applying filter criteria **/
    virtual void FillTrackArray() {}

    /** Update the track index in the MCTracks and MCPoints **/
    virtual void UpdateTrackIndex(TRefArray* /* detArray=0 */) {}

    /** Set the list of detectors to be used for filltering the stack*/
    void SetDetArrayList(TRefArray* detArray);

    /** Allow a stack to perform a clean-up after a primary particle is finished **/
    virtual void FinishPrimary() {}

    /** Resets arrays and stack and deletes particles and tracks **/
    virtual void Reset() {}

    /** Register the MCTrack array to the Root Manager  **/
    virtual void Register() {}

    virtual TClonesArray* GetListOfParticles() { return 0; }
    virtual void SetParticleArray(__attribute__((unused)) TClonesArray* partArray) {}
    virtual void SetParticleArray(__attribute__((unused)) TClonesArray* partArray,
                                  __attribute__((unused)) Int_t partFrom,
                                  __attribute__((unused)) Int_t partTo)
    {}

    /** Clone this object (used in MT mode only) */
    virtual FairGenericStack* CloneStack() const;

    /** Fast simulation function to move particle to different position.
        In Geant3 it stops the current trajectory, and starts it again in the position given by the user.
        In Geant4 the FastSimulationModel with take over.
        Later, the points are reindexed and the thus created tracks are not stored in the output.
     *@param xx,yy,zz    new position    of the particle
     *@param tt          new proper time of the particle
     *@param px,py,pz    new momentum    of the particle
     *@param en          new energy      of the particle
     **/
    virtual void FastSimMoveParticleTo(Double_t xx,
                                       Double_t yy,
                                       Double_t zz,
                                       Double_t tt,
                                       Double_t px,
                                       Double_t py,
                                       Double_t pz,
                                       Double_t en);
    /** Fast simulation function to stop original particle. **/
    virtual void FastSimStopParticle();
    /** Fast simulation function to generate secondaries.
     *@param xx,yy,zz    position    of the particle
     *@param tt          proper time of the particle
     *@param px,py,pz    momentum    of the particle
     *@param en          energy      of the particle
     **/
    virtual void FastSimPushSecondary(Int_t parentID,
                                      Int_t pdgCode,
                                      Double_t xx,
                                      Double_t yy,
                                      Double_t zz,
                                      Double_t tt,
                                      Double_t px,
                                      Double_t py,
                                      Double_t pz,
                                      Double_t en,
                                      Double_t polx,
                                      Double_t poly,
                                      Double_t polz,
                                      TMCProcess proc,
                                      Double_t weight,
                                      Int_t is);
    /** Allow FairFastSim the retrieval of moved particle position, p1 and p2 to get secondaries **/
    virtual std::tuple<Int_t, Int_t, Int_t> FastSimGetMovedIndex()
    {
        return std::make_tuple(fFSMovedIndex, fFSFirstSecondary, fFSNofSecondaries);
    }
    virtual void FastSimClearMovedIndex()
    {
        fFSMovedIndex = -2;
        fFSFirstSecondary = -2;
        fFSNofSecondaries = 0;
    }

    template<typename T>
    void FastSimUpdateTrackIndex(T* point, Int_t& iTrack);

  protected:
    /** Copy constructor */
    FairGenericStack(const FairGenericStack&);
    /** Assignment operator */
    FairGenericStack& operator=(const FairGenericStack&);

    /** Fair Logger */
    FairLogger* fLogger;   //!

    /** List of detectors registering hits in the simulation */
    TRefArray* fDetList;   //!

    /** Iterator for the detector list*/
    TIterator* fDetIter;

    /**Verbosity level*/
    Int_t fVerbose;

    /** FastSimulation: STL map from new track index to original track index  **/
    std::map<Int_t, Int_t> fFSTrackMap;              //!
    std::map<Int_t, Int_t>::iterator fFSTrackIter;   //!
    Int_t fFSMovedIndex;                             //!
    Int_t fFSFirstSecondary;                         //!
    Int_t fFSNofSecondaries;                         //!

    ClassDef(FairGenericStack, 1);
};

template<typename T>
void FairGenericStack::FastSimUpdateTrackIndex(T* point, Int_t& iTrack)
{
    fFSTrackIter = fFSTrackMap.find(iTrack);   // check if point created by FastSimulation
    if (fFSTrackIter != fFSTrackMap.end()) {   // indeed the point has been created by the FastSimulation mechanism
        iTrack = fFSTrackIter->second;
        point->SetTrackID(iTrack);   // set proper TrackID
    }
}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairGenericVMCConfig header file                -----
// -----            Created 2019.02.19 by R. Karabowicz                -----
// -------------------------------------------------------------------------

#include <string>   // for string

#ifndef FAIR_GENERIC_VMC_CONFIG_H
#define FAIR_GENERIC_VMC_CONFIG_H

class FairGenericVMCConfig
{
  public:
    FairGenericVMCConfig();
    virtual ~FairGenericVMCConfig();

    virtual void Setup(const char* mcEngine);
    virtual void SetupPostInit(const char* mcEngine);

    virtual void UsePostInitConfig(bool useC = true, const char* stringC = "g4ConfigPostInit.C")
    {
        fPostInitFlag = useC;
        fPostInitName = stringC;
    }

  protected:
    bool fPostInitFlag;
    std::string fPostInitName;
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairGeoParSet_H
#define FairGeoParSet_H

/**
 * Parameter class for Geometry stuff
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"   // for FairParGenericSet

#include <Rtypes.h>        // for Double_t, etc
#include <TGeoManager.h>   // IWYU pragma: keep needed by cint

class FairParamList;
class TObjArray;

class FairGeoParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
     * @param title:  Parameter set title
     * @param context:  Parameter set context
     */

    FairGeoParSet(const char* name = "FairGeoParSet",
                  const char* title = "Class for base parameter io",
                  const char* context = "BaseDefaultContext");
    /** dtor*/
    ~FairGeoParSet() override;
    /** clear*/
    void clear() override;
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
     */
    void putParams(FairParamList*) override;
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*) override;
    /**
     * Set the Geometry node list used in the simulation
     * @param array: TObjArray of Geometry nodes
     */
    void SetGeoNodes(TObjArray* array) { fGeoNodes = array; }
    /**
     * Set the Geometry (TGeoManager) used in the simulation
     * @param Geom: TGeoManager of the full geometry
     */
    void SetGeometry(TGeoManager* Geom) { fGeom = Geom; }
    /**
     *  Get the Geometry Nodes list used in the simulation
     */
    TObjArray* GetGeoNodes() { return fGeoNodes; }
    /**
     *  Get the geometry (TGeoManager) used in the simulation
     */
    TGeoManager* GetGeometry() { return fGeom; }

  protected:
    /// List of FairGeoNodes for sensitive volumes
    TObjArray* fGeoNodes;   //!
    /// Full Geometry
    TGeoManager* fGeom;
    ClassDefOverride(FairGeoParSet, 1);

  private:
    FairGeoParSet(const FairGeoParSet& L);
    FairGeoParSet& operator=(const FairGeoParSet&) { return *this; }
};

#endif /* !FairGeoParSet_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairIon header file                      -----
// -----          Created 27/08/04  by V. Friese / D.Bertini           -----
// -------------------------------------------------------------------------

/** FairIon.h
 *@author V.Friese <v.friese@gsi.de>
 *@author D.Bertini <d.bertini@gsi.de>
 **
 ** A class for the user definition of an ion. It will be instantiated
 ** from the constructor of the FairIonGenerator.
 **/

#ifndef FAIRION_H
#define FAIRION_H

#include <Rtypes.h>   // for Int_t, Double_t, etc
#include <TNamed.h>   // for TNamed

class FairLogger;

class FairIon : public TNamed
{
  public:
    /** Default constructor **/
    FairIon();

    /** Standard constructor
     *@param name  name
     *@param z     atomic number
     *@param a     atomic mass
     *@param q     electric charge
     *@param e     excitation energy
     *@param m     mass [GeV]
     ** If mass is not given, it will be set to a times the proton mass.
     **/

    FairIon(const char* name, Int_t z, Int_t a, Int_t q, Double_t e = 0., Double_t m = 0.);
    void SetParams(const char* name, Int_t z, Int_t a, Int_t q, Double_t e = 0., Double_t m = 0.)
    {
        SetName(name);
        fZ = z;
        fA = a;
        fQ = q;
        fExcEnergy = e;
        fMass = m;
    }
    /** Destructor **/
    virtual ~FairIon();

    /** Accessors **/
    /**
     * Return the atomic number
     */
    Int_t GetZ() const { return fZ; }
    /**
     * Return the atomic mass
     */
    Int_t GetA() const { return fA; }
    /**
     * Return the charge
     */
    Int_t GetQ() const { return fQ; }
    /**
     * Return the  excitation energy
     */
    Double_t GetExcEnergy() const { return fExcEnergy; }
    /**
     * Return the mass in GeV
     */
    Double_t GetMass() const { return fMass; }

    /** Modifiers **/
    /**
     * Set the  excitation energy
     */
    void SetExcEnergy(Double_t eExc) { fExcEnergy = eExc; }
    /**
     * Set the atomic mass, use SetMass to set the mass of the ion
     */
    void SetA(Int_t a) { fA = a; }
    /**
     * Set the mass in GeV
     */
    void SetMass(Double_t mass) { fMass = mass; }

  private:
    static Int_t fgNIon;         //! /// Number of ions instantiated. One per generator.
    Int_t fZ;                    /// Atomic number
    Int_t fA;                    /// Atomic mass
    Int_t fQ;                    /// Electric charge
    Double_t fExcEnergy;         /// Excitation energy [GeV]
    Double_t fMass;              /// Mass [GeV]
    FairLogger* fLogger;         //! /// FairLogger

    FairIon(const FairIon&);
    FairIon& operator=(const FairIon&);

    ClassDef(FairIon, 2);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairMCApplication header file                   -----
// -----            Created 06/01/04  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_MC_APPLICATION_H
#define FAIR_MC_APPLICATION_H

#include "FairRadGridManager.h"
#include "FairRunInfo.h"   // for FairRunInfo

#include <Rtypes.h>                  // for Int_t, Bool_t, Double_t, etc
#include <TLorentzVector.h>          // for TLorentzVector
#include <TString.h>                 // for TString
#include <TVirtualMCApplication.h>   // for TVirtualMCApplication
#include <list>                      // for list
#include <map>                       // for map, multimap, etc
#include <memory>                    // for std::unique_ptr

class FairDetector;
class FairEventHeader;
class FairField;
class FairGenericStack;
class FairMCEventHeader;
class FairPrimaryGenerator;
class FairRadLenManager;
class FairRadMapManager;
class FairRootManager;
class FairTask;
class FairTrajFilter;
class FairVolume;
class FairRunSim;
class TChain;
class TIterator;
class TObjArray;
class TRefArray;
class TTask;
class TVirtualMC;

enum class FairMCApplicationState { kUnknownState, kConstructGeometry, kInitGeometry };

/**
 * The Main Application ( Interface to MonteCarlo application )
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairMCApplication : public TVirtualMCApplication
{
  public:
    /** Standard constructor
     *@param name      name
     *@param title     title
     *@param ModList  a TObjArray containing all detectors and modules used in this simulation
     *@param MatName  material file name
     */
    FairMCApplication(const char* name, const char* title, TObjArray* ModList, const char* MatName);
    /** default constructor
     */
    FairMCApplication();

    FairMCApplication(const FairMCApplication&) = delete;
    FairMCApplication& operator=(const FairMCApplication&) = delete;
    FairMCApplication(FairMCApplication&&) = delete;
    FairMCApplication& operator=(FairMCApplication&&) = delete;

    /** default destructor
     */
    ~FairMCApplication() override;
    /** Singelton instance
     */
    static FairMCApplication* Instance();
    virtual void AddDecayModes();
    /**  Add user defined particles (optional) */
    void AddParticles() override;   // MC Application
    /** Add user defined ions (optional)
        Called by TVirtualMC.
        TGeant3 calls AddIons() first, then InitGeometry().
        TGeant4 calls InitGeometry() first, then AddIons().
        This function also initializes event generators.*/
    void AddIons() override;   // MC Application
    /**
     *Add user defined Tasks to be executed after each event (optional)
     * @param fTask: Task that has to be excuted during simulation
     */
    void AddTask(TTask* fTask);
    /** Define actions at the beginning of the event */
    void BeginEvent() override;   // MC Application
    /** Define actions at the beginning of primary track */
    void BeginPrimary() override;   // MC Application
    /** Construct user geometry */
    void ConstructGeometry() override;   // MC Application
    /** Align or misalign geometry before actual run       */
    Bool_t MisalignGeometry() override;
    /** Define parameters for optical processes (optional) */
    void ConstructOpGeometry() override;   // MC Application
    /** Define actions at the end of event */
    void FinishEvent() override;   // MC Application
    /** Define actions at the end of primary track */
    void FinishPrimary() override;   // MC Application
    /** Define actions at the end of run */
    void FinishRun();
    /** Generate primary particles */
    void GeneratePrimaries() override;   // MC Application
    /** Return detector by name  */
    FairDetector* GetDetector(const char* DetName);
    /** Return Field used in simulation*/
    FairField* GetField() { return fxField; }
    /**Return primary generator*/
    FairPrimaryGenerator* GetGenerator();
    /**Return list of tasks*/
    TTask* GetListOfTasks();
    FairGenericStack* GetStack();
    TChain* GetChain();
    /** Initialize geometry
        Called by TVirtualMC.
        TGeant3 calls AddIons() first, then InitGeometry().
        TGeant4 calls InitGeometry() first, then AddIons().
        This function also registers detectors.*/
    void InitGeometry() override;   // MC Application
    /** Initialize MC engine */
    void InitMC(const char* setup, const char* cuts);
    /** Initialize Tasks if any*/
    void InitTasks();
    /**Define actions at the end of each track */
    void PostTrack() override;   // MC Application
    /** Define actions at the beginning of each track*/
    void PreTrack() override;   // MC Application

    /** Clone for worker (used in MT mode only) */
    TVirtualMCApplication* CloneForWorker() const override;

    /** Init application on worker (used in MT mode only) */
    void InitOnWorker() override;

    /** Finish run on worker (used in MT mode only) */
    void FinishRunOnWorker() override;

    /** Run the MC engine
     * @param nofEvents : number of events to simulate
     */
    void RunMC(Int_t nofEvents);
    /**
     * Set the magnetic field for simulation
     * @param field: magnetic field
     */
    void SetField(FairField* field);
    /**
     * Set the event generator  for simulation
     * @param fxGenerator: Event generator(s)
     */
    void SetGenerator(FairPrimaryGenerator* fxGenerator);
    /**
     * Set the parameter containers needed by Tasks(if any)
     */
    void SetParTask();
    /**
     * Switch for using Pythia as external decayer
     * @param decayer: if TRUE pythia will decay particles specifid in the Decay Config macro (see
     * SetPythiaDecayerConfig)
     */
    void SetPythiaDecayer(Bool_t decayer) { fPythiaDecayer = decayer; }
    /**
     * set the decay configuration macro to be used by Pythia
     */
    void SetPythiaDecayerConfig(const TString decayerConf) { fPythiaDecayerConfig = decayerConf; }
    /**
     * Switch for using the radiation length manager
     */
    void SetRadiationLengthReg(Bool_t RadLen);
    /**
     * Switch for using the radiation map manager
     */
    void SetRadiationMapReg(Bool_t RadMap);
    /**
     * Switch for debuging the tracking
     */
    void SetTrackingDebugMode(Bool_t set) { fDebug = set; }
    /**
     * Switch for using 2 or 3 body phase-space decay
     * @param  decay: if TRUE 2/3 body phase space decay will be used for particle specified in the User Decay Config
     * macro (see SetUserDecayConfig)
     */
    void SetUserDecay(Bool_t decay) { fUserDecay = decay; }
    /**
     * set the decay configuration macro to be used by user decay
     */
    void SetUserDecayConfig(const TString decayerConf) { fUserDecayConfig = decayerConf; }
    /** Define action at each step, dispatch the action to the corresponding detectors */
    void Stepping() override;   // MC Application
    /** Stop the run*/
    virtual void StopRun();
    /** Stop the run*/
    virtual void StopMCRun();
    /**Define maximum radius for tracking (optional) */
    Double_t TrackingRmax() const override;   // MC Application
    /** Define maximum z for tracking (optional) */
    Double_t TrackingZmax() const override;   // MC Application

    void AddMeshList(TObjArray* meshList);

    /**
     * Set if the current event should be written to the output file.
     * The default value which is set back after each event is to store
     * the event.
     */
    void SetSaveCurrentEvent(Bool_t set) { fSaveCurrentEvent = set; }

    /**
     * Get the current application state.
     */
    FairMCApplicationState GetState() const { return fState; }

    /**
     * Return non-owning pointer to FairRadGridManager
     */
    auto GetRadGridMan() { return fRadGridMan.get(); }

  private:
    // methods
    Int_t GetIonPdg(Int_t z, Int_t a) const;

    void UndoGeometryModifications();

  protected:
    // data members
    /**
     * \brief Main instance
     *
     * Only set for instances created by \ref CloneForWorker
     * and points to the instance from which the clone was
     * created
     */
    const FairMCApplication* fParent{nullptr};   //!
    /**List of active detector */
    TRefArray* fActiveDetectors;
    /**List of FairTask*/
    FairTask* fFairTaskList;   //!
    /**detector list (Passive and Active)*/
    TRefArray* fDetectors;
    /**Iterator for Module list*/
    TIterator* fModIter;   //!
    /**Module list in simulation*/
    TObjArray* fModules;
    /**Number of sensetive volumes in simulation session*/
    Int_t fNoSenVolumes;   //!
    /**flag for using Pythia as external decayer */
    Bool_t fPythiaDecayer;
    /** Pythia decay config macro*/
    TString fPythiaDecayerConfig;   //!
    /** Simulation Stack  */
    FairGenericStack* fStack;   //!
    /**Pointer to thr I/O Manager */
    FairRootManager* fRootManager;   //!
    /**List of sensetive volumes in all detectors*/
    TRefArray* fSenVolumes;   //!
    /**Magnetic Field Pointer*/
    FairField* fxField;   //
    /**Primary generator*/
    FairPrimaryGenerator* fEvGen;   //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t fMcVersion;   // mc Version
    /** Track visualization manager */
    FairTrajFilter* fTrajFilter;   //!
    /**Flag for accepted tracks for visualization*/
    Bool_t fTrajAccepted;   //!
    /**Flag for using user decay*/
    Bool_t fUserDecay;
    /**User decay config macro*/
    TString fUserDecayConfig;   //!
    /** Debug flag*/
    Bool_t fDebug;   //!
    /**dispatcher internal use */
    std::multimap<Int_t, FairVolume*> fVolMap;   //!
    /** Track position*/
    /**dispatcher internal use RadLeng*/
    std::map<Int_t, Int_t> fModVolMap;   //!
    TLorentzVector fTrkPos;              //!
    /** Flag for Radiation length register mode  */
    Bool_t fRadLength;   //!

    /**Radiation length Manager*/
    FairRadLenManager* fRadLenMan;   //!
    /** Flag for Radiation map register mode  */
    Bool_t fRadMap;   //!
    /**Radiation Map Manager*/
    FairRadMapManager* fRadMapMan;   //!
    /**Radiation map Grid Manager*/
    std::unique_ptr<FairRadGridManager> fRadGridMan{};   //!

    FairEventHeader* fEventHeader;   //!

    FairMCEventHeader* fMCEventHeader;   //!
    /** list of senstive detectors used in the simuation session*/
    std::list<FairDetector*> listActiveDetectors;   //!
    /** list of all detectors used in the simuation session*/
    std::list<FairDetector*> listDetectors;   //!
    /** Pointer to the current MC engine //!
     */
    TVirtualMC* fMC;

    FairRunSim* fRun{nullptr};   //!

    /** Flag if the current event should be saved */
    Bool_t fSaveCurrentEvent;

    /** Current state */
    FairMCApplicationState fState;   //!

    ClassDefOverride(FairMCApplication, 5);

  private:
    /** Private special copy constructor, needed for CloneForWorker */
    FairMCApplication(const FairMCApplication&, std::unique_ptr<FairRunSim>);

    FairRunInfo fRunInfo;   //!
    Bool_t fGeometryIsInitialized;

    /**
     * Clean up the FairRunSim created in CloneForWorker
     */
    std::unique_ptr<FairRunSim> fWorkerRunSim;   //!
};

// inline functions

inline FairMCApplication* FairMCApplication::Instance()
{
    return static_cast<FairMCApplication*>(TVirtualMCApplication::Instance());
}

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRMODULE_H
#define FAIRMODULE_H

#include "FairGeoInterface.h"   // for FairGeoInterface
#include "FairGeoLoader.h"      // for FairGeoLoader
#include "FairGeoNode.h"        // for FairGeoNode
#include "FairGeoVolume.h"      // for FairGeoVolume
#include "FairLogger.h"
#include "FairRun.h"         // for FairRun
#include "FairRuntimeDb.h"   // for FairRuntimeDb

#include <Rtypes.h>      // for Bool_t, Int_t, etc
#include <TList.h>       // for TList (ptr only), TListIter
#include <TNamed.h>      // for TNamed
#include <TObjArray.h>   // for TObjArray
#include <TString.h>     // for TString, operator!=
#include <string>        // for string

class FairVolumeList;
class FairVolume;
class TArrayI;
class TGeoMatrix;
class TGeoNode;
class TGeoVolume;
class TRefArray;
class TVirtualMC;

/**
 * Base class for constructing all detecors and passive volumes
 * @author M. Al-Turany, Denis Bertini
 * @version 1.0
 * @since 01.04.08 M.Al-Turany
 * Add methods to construct geometry via ROOT files
 * Add some documentation
 *
 * Changelog: 29.02.2012 [O.Merle] Fixed missing material assignment for top volume.
 *                                 ... and please - add some documentation to your code.
 */
class FairModule : public TNamed
{
  public:
    /**default ctor*/
    FairModule();
    /**Standard ctor*/
    FairModule(const char* Name, const char* title, Bool_t Active = kFALSE);
    /**default dtor*/
    ~FairModule() override;
    /**Print method should be implemented in detector or module*/
    void Print(Option_t*) const override { ; }
    /**Set the geometry file name o be used*/
    virtual void SetGeometryFileName(TString fname, TString geoVer = "0");
    /**Get the Geometry file name*/
    virtual TString GetGeometryFileName() { return fgeoName; }
    /**Get the geometry file version if used*/
    virtual TString GetGeometryFileVer() { return fgeoVer; }
    /**method called from the MC application to construct the geometry, has to be implimented by user*/
    virtual void ConstructGeometry();
    /**method called from the MC application to set optical geometry properties*/
    virtual void ConstructOpGeometry();
    /**construct geometry from root files (TGeo)*/
    virtual void ConstructRootGeometry(TGeoMatrix* shiftM = nullptr);
    /**construct geometry from standard ASSCII files (Hades Format)*/
    virtual void ConstructASCIIGeometry();
    /**
     * Modify the geometry for the simulation run using methods of the Root geometry package
     * \deprecated Deprecated pre-v18.8, will be removed in v20.
     */
    [[deprecated("Use FairAlignmentHandler instead, see Tutorial4 for examples")]] virtual void ModifyGeometry()
    {
        LOG(warn) << "This function is deprecated. Use FairAlignmentHandler instead, see Tutorial4 for examples.";
    }
    virtual void RegisterAlignmentMatrices() { ; }

    /**construct geometry from GDML files*/
    virtual void ConstructGDMLGeometry(__attribute__((unused)) TGeoMatrix* posrot);
    /** custom settings of processes and cuts for media to be forwarded to the
     ** detector simulation */
    virtual void SetSpecialPhysicsCuts() { ; }
    /** Clone this object (used in MT mode only)*/
    virtual FairModule* CloneModule() const;
    /** Init worker run (used in MT mode only) */
    virtual void BeginWorkerRun() const { ; }
    /** Finish worker run (used in MT mode only) */
    virtual void FinishWorkerRun() const { ; }

    /** @deprecated template function to construct geometry. to be used in derived classes.
     * The first and the third argument are meaningless, just pass nullptr */
    template<class T, class U>
    [[deprecated("Broken signature, use ConstructASCIIGeometry(TString) instead")]] void
        ConstructASCIIGeometry(T*, TString containerName = "", U* = nullptr);
    /** Helper function to construct geometry. */
    template<class T, class U>
    void ConstructASCIIGeometry(TString containerName = "");

    /**Set the sensitivity flag for volumes, called from ConstructASCIIRootGeometry(), and has to be implimented for
     * detectors which use ConstructASCIIRootGeometry() to build the geometry */
    virtual Bool_t IsSensitive(const std::string& name);
    /**The function below is depracated, please change to the new method above */
    virtual Bool_t CheckIfSensitive(__attribute__((unused)) std::string name) __attribute__((
        deprecated("The method CheckIfSensitive is deprecated. Implement IsSensitive in the detector classes.")))
    {
        return kFALSE;
    }
    /**called from ConstructRootGeometry()*/
    virtual void ExpandNode(TGeoNode* Node);
    /**called from ConstructGDMLGeometry()*/
    virtual void ExpandNodeForGDML(__attribute__((unused)) TGeoNode* curNode);
    /**return the MC id of a volume named vname*/
    virtual Int_t getVolId(const TString&) const { return 0; }
    /**return the detector/Module id (which was set in the sim macro for the detector)*/
    Int_t GetModId() { return fModId; }
    /**Set the verbose level in this detector*/
    void SetVerboseLevel(Int_t level) { fVerboseLevel = level; }
    /**return the detector status */
    Bool_t IsActive() { return fActive; }
    /**set the detector/module id*/
    void SetModId(Int_t id) { fModId = id; }
    /** Set the name of the mother volume to which a new geometry is added.
     ** This function is needed for geometries which are defined as ROOT geometry manager.
     **/
    void SetMotherVolume(TString volName) { fMotherVolumeName = volName; }
    /**called from ConstuctASCIIGeometry*/
    void ProcessNodes(TList* aList);
    /**Set the parameter containers*/
    virtual void SetParContainers() { ; }
    /** Initialize everything which has to be done before the construction and modification
     ** of the geometry. Mostly this is needed to read data from the parameter containers.*/
    virtual void InitParContainers() { ; }
    /**return the geo parameter of this detector/module*/
    TList* GetListOfGeoPar() { return flGeoPar; }

    /**list of volumes in a simulation session*/
    static thread_local FairVolumeList* vList;   //!
    /**total number of volumes in a simulaion session*/
    static thread_local Int_t fNbOfVolumes;   //!
    /**list of all sensitive volumes in  a simulaion session*/
    static thread_local TRefArray* svList;   //!

    static thread_local TArrayI* volNumber;   //!
    TString fMotherVolumeName;                //!
    FairVolume* getFairVolume(FairGeoNode* fNode);
    void AddSensitiveVolume(TGeoVolume* v);

  private:
    /** Re-implimented from ROOT:  TGeoMatrix::SetDefaultName()  */
    void SetDefaultMatrixName(TGeoMatrix* matrix);
    void AssignMediumAtImport(TGeoVolume* v);   // O.Merle, 29.02.2012 - see impl.

    /**called from ConstructGDMLGeometry. Changes default ID created by TGDMLParse*/
    void ReAssignMediaId();
    void swap(FairModule& other) throw();

  protected:
    FairModule(const FairModule&);
    FairModule& operator=(const FairModule&);
    TString fgeoVer;
    TString fgeoName;
    Int_t fModId;
    Bool_t fActive;
    Int_t fNbOfSensitiveVol;   //!
    Int_t fVerboseLevel;
    TList* flGeoPar;    //!  list of Detector Geometry parameters
    Bool_t fGeoSaved;   //! flag for initialisation
    TVirtualMC* fMC;    //! cahed pointer to MC (available only after initialization)

    ClassDefOverride(FairModule, 4);
};

template<class T, class U>
void FairModule::ConstructASCIIGeometry(TString containerName)
{
    FairGeoLoader* loader = FairGeoLoader::Instance();
    FairGeoInterface* GeoInterface = loader->getGeoInterface();
    T* MGeo = new T();
    MGeo->print();
    MGeo->setGeomFile(GetGeometryFileName());
    GeoInterface->addGeoModule(MGeo);   // takes ownership!
    Bool_t rc = GeoInterface->readSet(MGeo);
    if (rc) {
        MGeo->create(loader->getGeoBuilder());
    }

    TList* volList = MGeo->getListOfVolumes();
    // store geo parameter
    FairRun* fRun = FairRun::Instance();
    FairRuntimeDb* rtdb = FairRun::Instance()->GetRuntimeDb();

    if ("" != containerName) {
        LOG(info) << "Add GeoNodes for " << MGeo->getDescription() << " to container " << containerName;

        //    U par=(U)(rtdb->getContainer(containerName));
        U* par = static_cast<U*>(rtdb->getContainer(containerName));
        TObjArray* fSensNodes = par->GetGeoSensitiveNodes();
        TObjArray* fPassNodes = par->GetGeoPassiveNodes();

        TListIter iter(volList);
        FairGeoNode* node = nullptr;
        FairGeoVolume* aVol = nullptr;

        while ((node = static_cast<FairGeoNode*>(iter.Next()))) {
            aVol = dynamic_cast<FairGeoVolume*>(node);
            if (node->isSensitive()) {
                fSensNodes->AddLast(aVol);
            } else {
                fPassNodes->AddLast(aVol);
            }
        }
        ProcessNodes(volList);
        par->setChanged();
        par->setInputVersion(fRun->GetRunId(), 1);
    }
}

template<class T, class U>
void FairModule::ConstructASCIIGeometry(T*, TString containerName, U*)
{
    ConstructASCIIGeometry<T, U>(containerName);
}

#endif   // FAIRMODULE_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/// Class FAIRParticle
/// ------------------
/// Extended TParticle with persistent pointers to mother and daughters
/// particles  (Ivana Hrivnacova, 5.4.2002)
/// Used to define particles which will be added to Geant3/4 (M. Al-Turany)

#ifndef FAIR_PARTICLE_H
#define FAIR_PARTICLE_H

#include <Rtypes.h>            // for Int_t, Double_t, Bool_t, etc
#include <TMCParticleType.h>   // for TMCParticleType
#include <TObject.h>           // for TObject
#include <TRef.h>              // for TRef
#include <TRefArray.h>         // for TRefArray
#include <TString.h>           // for TString

class TParticle;

class FairParticle : public TObject
{
  public:
    FairParticle(Int_t id, TParticle* particle);
    FairParticle(Int_t id, TParticle* particle, FairParticle* mother);
    FairParticle(const char* name,
                 Int_t z,
                 Int_t a,
                 Int_t s,
                 Double_t mass,
                 Int_t q,
                 Bool_t stable,
                 Double_t decaytime);
    FairParticle(const char* name, Int_t z, Int_t a, Double_t mass, Int_t q, Bool_t stable, Double_t decaytime);
    FairParticle(Int_t pdg,
                 const TString name,
                 TMCParticleType mcType,
                 Double_t mass,
                 Double_t charge,
                 Double_t lifetime,
                 const TString pType = "Ion",
                 Double_t width = 0,
                 Int_t iSpin = 0,
                 Int_t iParity = 0,
                 Int_t iConjugation = 0,
                 Int_t iIsospin = 0,
                 Int_t iIsospinZ = 0,
                 Int_t gParity = 0,
                 Int_t lepton = 0,
                 Int_t baryon = 0,
                 Bool_t stable = kFALSE);

    FairParticle();

    ~FairParticle() override;

    // methods
    void SetMother(FairParticle* particle);
    void AddDaughter(FairParticle* particle);
    void Print(Option_t* option = "") const override;
    void PrintDaughters() const;

    // get methods
    Int_t GetPDG() const;
    TParticle* GetParticle() const;
    FairParticle* GetMother() const;
    Int_t GetNofDaughters() const;
    FairParticle* GetDaughter(Int_t i) const;
    const char* GetName() const override { return fname.Data(); }
    TMCParticleType GetMCType() { return fmcType; }
    Double_t GetMass() { return fmass; }
    Double_t GetCharge() { return fcharge; }
    Double_t GetDecayTime() { return fDecayTime; }
    const TString& GetPType() { return fpType; }
    Double_t GetWidth() { return fwidth; }
    Int_t GetSpin() { return fiSpin; }
    Int_t GetiParity() { return fiParity; }
    Int_t GetConjugation() { return fiConjugation; }
    Int_t GetIsospin() { return fiIsospin; }
    Int_t GetIsospinZ() { return fiIsospinZ; }
    Int_t GetgParity() { return fgParity; }
    Int_t GetLepton() { return flepton; }
    Int_t GetBaryon() { return fbaryon; }
    Bool_t IsStable() { return fstable; }

  private:
    FairParticle(const FairParticle& P);
    FairParticle& operator=(const FairParticle&) { return *this; }
    // data members
    Int_t fpdg;
    TParticle* fParticle;
    TRef fMother;
    TRefArray fDaughters;
    const TString fname;
    TMCParticleType fmcType;
    Double_t fmass;
    Double_t fcharge;
    Double_t fDecayTime;
    const TString fpType;
    Double_t fwidth;
    Int_t fiSpin;
    Int_t fiParity;
    Int_t fiConjugation;
    Int_t fiIsospin;
    Int_t fiIsospinZ;
    Int_t fgParity;
    Int_t flepton;
    Int_t fbaryon;
    Bool_t fstable;

    ClassDefOverride(FairParticle, 3);
};

#endif   // FAIR_PARTICLE_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH *
 *                                                                              *
 *              This software is distributed under the terms of the *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE" *
 ********************************************************************************/

/** FairPrimaryGenerator.h
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairPrimaryGenerator is responsible for the handling of the MC input.
Several input generators can be registered to it; these have to be
derived from the FairGenerator class. The FairPrimaryGenerator defines
position and (optionally) smearing of the primary vertex.
This class should be instantised only once.

Modified 05.06.07:  add a method DoTracking(Bool_t) to be able to switch on/off
the tracking from the macro (M. Al-Turany)

**/

#ifndef FAIRPRIMARYGENERATOR_H
#define FAIRPRIMARYGENERATOR_H

#include "FairGenerator.h"   // for FairGenerator

#include <Rtypes.h>   // for Double_t, Bool_t, Int_t, etc
#include <TMCProcess.h>
#include <TNamed.h>      // for TNamed
#include <TObjArray.h>   // for TObjArray
#include <TVector3.h>    // for TVector3
#include <iostream>      // for cout

class FairGenericStack;
class FairMCEventHeader;
class TIterator;

class FairPrimaryGenerator : public TNamed
{

  public:
    /** Default constructor. **/
    FairPrimaryGenerator();

    /** Constructor with name and title **/
    FairPrimaryGenerator(const char *name, const char *title = "FAIR Generator");

    /** Destructor. **/
    virtual ~FairPrimaryGenerator();

    /** Initialize the generater (if needed!)*/
    virtual Bool_t Init();

    /** Finalize the generater (if needed!)*/
    virtual void Finish();

    /** Register a generator derived from FairGenerator.  **/
    void AddGenerator(FairGenerator *generator)
    {
        if (!fGenList) {
            std::cout << "Empty fGenList pointer ! " << std::endl;
            return;
        }
        fGenList->Add(generator);
    }

    void SetEventNr(Int_t evtNr) { fEventNr = evtNr; }

    /** Public method GenerateEvent
      To be called at the beginning of each event from FairMCApplication.
      Generates an event vertex and calls the ReadEvent methods from the
      registered generators.
      *@param pStack The particle stack
      *@return kTRUE if successful, kFALSE if not
      **/
    virtual Bool_t GenerateEvent(FairGenericStack *pStack);

    /** Public method AddTrack
      Adding a track to the MC stack. To be called within the ReadEvent
      methods of the registered generators.
      *@param pdgid Particle ID (PDG code)
      *@param px,py,pz Momentum coordinates [GeV]
      *@param vx,vy,vz Track origin relative to event vertex
      **/
    virtual void AddTrack(Int_t pdgid,
                          Double_t px,
                          Double_t py,
                          Double_t pz,
                          Double_t vx,
                          Double_t vy,
                          Double_t vz,
                          Int_t parent = -1,
                          Bool_t wanttracking = true,
                          Double_t e = -9e9,
                          Double_t tof = 0.,
                          Double_t weight = 0.,
                          TMCProcess proc = kPPrimary);

    /** Clone this object (used in MT mode only) */
    virtual FairPrimaryGenerator *ClonePrimaryGenerator() const;

    /** Set beam position and widths.
     *@param beamX0      mean x position of beam at target
     *@param beamY0      mean y position of beam at target
     *@param beamSigmaX  Gaussian beam width in x
     *@param beamSigmaY  Gaussian beam width in y
     **/
    void SetBeam(Double_t beamX0, Double_t beamY0, Double_t beamSigmaX, Double_t beamSigmaY);

    /** Set nominal beam angle and angle widths.
     *@param beamAngleX0      mean x angle of beam at target
     *@param beamAngleY0      mean y angle of beam at target
     *@param beamAngleSigmaX  Gaussian beam angle width in x
     *@param beamAngleSigmaY  Gaussian beam angle width in y
     **/
    void SetBeamAngle(Double_t beamAngleX0, Double_t beamAngleY0, Double_t beamAngleSigmaX, Double_t beamAngleSigmaY);

    /** Public method SetEventPlane
     **@param phiMin   Lower limit for event plane angle [rad]
     **@param phiMax   Upper limit for event plane angle [rad]
     **If set, an event plane angle will be generated with flat
     **distrtibution between phiMin and phiMax.
     **/
    void SetEventPlane(Double_t phiMin, Double_t phiMax);

    /** Set target position and thickness.
     *@param targetZ   z position of target center
     *@param targetDz  full target thickness
     **/
    void SetTarget(Double_t targetZ, Double_t targetDz);

    /** Set target position for multiple tagets. The thickness
     * is the same for all targets.
     *@param nroftargets   number of targets
     *@param *targetZ      z positions of target center
     *@param targetDz      full target thickness
     **/
    void SetMultTarget(Int_t nroftargets, Double_t *targetZ, Double_t targetDz);

    /** Enable vertex smearing in z and/or xy direction **/
    void SmearVertexZ(Bool_t flag);
    void SmearGausVertexZ(Bool_t flag);
    void SmearVertexXY(Bool_t flag);
    void SmearGausVertexXY(Bool_t flag);

    TObjArray *GetListOfGenerators() { return fGenList; }

    /** Set the pointer to the MCEvent **/
    void SetEvent(FairMCEventHeader *event) { fEvent = event; };

    /** Accessor to the MCEvent **/
    FairMCEventHeader *GetEvent() { return fEvent; };

    /** Swich on/off the tracking of a particle*/

    void DoTracking(Bool_t doTracking = kTRUE) { fdoTracking = doTracking; }

    Int_t GetTotPrimary() { return fTotPrim; }

  protected:
    /**  Copy constructor */
    FairPrimaryGenerator(const FairPrimaryGenerator &);
    /**  Assignment operator */
    FairPrimaryGenerator &operator=(const FairPrimaryGenerator &);

    /**  Nominal beam position at target in x [cm] */
    Double_t fBeamX0;
    /** Nominal beam position at target in y [cm]*/
    Double_t fBeamY0;
    /** Beam width (Gaussian) in x [cm]*/
    Double_t fBeamSigmaX;
    /**  Beam width (Gaussian) in y [cm]*/
    Double_t fBeamSigmaY;

    /**  Nominal beam angle at target in x [rad] */
    Double_t fBeamAngleX0;
    /**  Nominal beam angle at target in y [rad] */
    Double_t fBeamAngleY0;
    /**  Actual beam angle at target in x [rad] */
    Double_t fBeamAngleX;
    /**  Actual beam angle at target in y [rad] */
    Double_t fBeamAngleY;
    /** Beam angle width (Gaussian) in x [rad]*/
    Double_t fBeamAngleSigmaX;
    /** Beam angle width (Gaussian) in y [rad]*/
    Double_t fBeamAngleSigmaY;
    /** Actual beam direction at the vertex */
    TVector3 fBeamDirection;

    /** Lower limit for the event plane rotation angle [rad] */
    Double_t fPhiMin;
    /** Upper limit for the event plane rotation angle [rad] */
    Double_t fPhiMax;
    /** Actual event plane rotation angle [rad] */
    Double_t fPhi;

    /**  Nominal z position of center of targets [cm]*/
    Double_t *fTargetZ;   //!
    /**  Number of targets;*/
    Int_t fNrTargets;
    /**  Full target thickness [cm]*/
    Double_t fTargetDz;

    /** Vertex position of current event [cm]*/
    TVector3 fVertex;

    /** Number of primary tracks in current event*/
    Int_t fNTracks;

    /**  Flag for uniform vertex smearing in z*/
    Bool_t fSmearVertexZ;
    /**  Flag for gaus vertex smearing in z*/
    Bool_t fSmearGausVertexZ;
    /**  Flag for vertex smearing in xy*/
    Bool_t fSmearVertexXY;
    /**  Flag for gaus vertex smearing in xy*/
    Bool_t fSmearGausVertexXY;
    /**  Flag for beam gradient calculation*/
    Bool_t fBeamAngle;
    /**  Flag for event plane rotation*/
    Bool_t fEventPlane;

    /**  Pointer to MC stack*/
    FairGenericStack *fStack;   //!
    /**  List of registered generators */
    TObjArray *fGenList;
    /**  Iterator over generator list */
    TIterator *fListIter;   //!
    /**  Pointer to MCEventHeader */
    FairMCEventHeader *fEvent;   //!
    /** go to tracking  */
    Bool_t fdoTracking;   //!
    /** Number of MC tracks before a Generator is called, needed for MC index
     * update */
    Int_t fMCIndexOffset;   //!
    /** Number of all primaries of this run*/
    static Int_t fTotPrim;   //!
    /** Event number (Set by the primary generator if not set already by one of
      the specific generators
   **/
    Int_t fEventNr;

    /** Private method MakeVertex. If vertex smearing in xy is switched on,
      the event vertex is smeared Gaussianlike in x and y direction
      according to the mean beam positions and widths set by the
      SetBeam method. If vertex smearing in z is switched on, the z
      coordinate of the event vertex is flatly distributed over the
      extension of the target.
      To be called at the beginning of the event from the
      GenerateEvent method.
  **/
    virtual void MakeVertex();

    /** Private method MakeBeamAngle. If beam angle smearing in xy
  is switched on, all tracks in an event are rotated by a Gaussianlike
  angle distribution around the x and y axis according to the mean
  beam angle and angle widths set by the SetBeamAngle method.
  To be called at the beginning of the event from the GenerateEvent
  method.
  **/
    virtual void MakeBeamAngle();

    /** Private method MakeEventPlane. If the rotation of the event around the
      z-axis by a random angle is switched on, the complete event is rotated
      by the chosen angle. This function is called at the beginning of the
      event from the GenerateEvent method. The function pick a random
      rotation angle between fPhiMin and fPhiMax which are set using the
      function SetEventPlane.
  **/
    void MakeEventPlane();

    ClassDef(FairPrimaryGenerator, 5);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNIDGENERATOR_H
#define FAIRRUNIDGENERATOR_H

#include <time.h>   // IWYU pragma: keep for timespec
// IWYU pragma: no_include <sys/_structs.h>

typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
typedef unsigned char uuid_t[16];

class FairRunIdGenerator
{
    struct uuid
    {
        uint32_t time_low;
        uint16_t time_mid;
        uint16_t time_hi_and_version;
        uint16_t clock_seq;
        uint8_t node[6];
    };

    struct timespec fTimeSpec;

    int get_random_fd(void);
    void get_random_bytes(void*, int);
    int get_node_id(unsigned char*);
    int get_clock(uint32_t*, uint32_t*, uint16_t*);
    void uuid_generate_time(uuid_t);
    void uuid_generate_random(uuid_t);
    void uuid_generate(uuid_t);
    void uuid_pack(const struct uuid*, uuid_t);
    void uuid_unpack(const uuid_t, struct uuid*);

  public:
    struct timespec getTimeSpec() { return fTimeSpec; }
    struct timespec getTimeSpecFromTID(unsigned int ms);
    unsigned int getTID();

  public:
    FairRunIdGenerator()
        : fTimeSpec()
    {}
    ~FairRunIdGenerator() {}
    unsigned int generateId(void);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUME_H
#define FAIR_VOLUME_H

#include "FairModule.h"

#include <Rtypes.h>    // for Int_t, FairVolume::Class, etc
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString

class FairDetector;
class FairGeoNode;

/**
 * This Object is only used for internal book keeping!
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairVolume : public TNamed
{
  public:
    FairVolume();
    FairVolume(const TString& name, Int_t id = 0, Int_t modId = 0, FairModule* fMod = nullptr);
    ~FairVolume() override;

    void setRealName(TString name) { fRealName = name; }
    const char* getRealName() const { return fRealName.Data(); }
    Int_t getVolumeId() const { return fVolumeId; }
    Int_t getModId() const { return fModId; }
    void setModId(Int_t id) { fModId = id; }
    void setCopyNo(Int_t id) { fCopyNo = id; }
    void setVolumeId(Int_t id) { fVolumeId = id; }
    void setGeoNode(FairGeoNode* d) { fNode = d; }
    void setMotherId(Int_t fM) { fMotherId = fM; }
    void setMotherCopyNo(Int_t copyNo) { fMotherCopyNo = copyNo; }

    FairModule* GetModule() const { return fModule; }
    FairDetector* GetDetector() const { return fDetector; }
    void SetModule(FairModule* mod);

    Int_t getMCid() const { return fMCid; }
    Int_t getCopyNo() const { return fCopyNo; }
    void setMCid(Int_t id) { fMCid = id; }
    FairGeoNode* getGeoNode() const { return fNode; }
    Int_t getMotherId() const { return fMotherId; }
    Int_t getMotherCopyNo() const { return fMotherCopyNo; }

  private:
    FairVolume(const FairVolume&);
    FairVolume& operator=(const FairVolume&);

    TString fRealName{""};            /**Volume Name in ASCII file*/
    Int_t fVolumeId{-1};              /**Volume Id in GeoManager*/
    Int_t fModId{-1};                 /**Module Id in which this volume exist*/
    Int_t fMCid{-1};                  /**Volume Id in MC*/
    Int_t fCopyNo{-1};                /**Volume Copy No*/
    Int_t fMotherId{-1};              /**Mother Volume Id*/
    Int_t fMotherCopyNo{-1};          /**Mother Volume Copy No*/
    FairDetector* fDetector{nullptr}; /** The Detector which will proccess the hits for this volume*/
    FairModule* fModule{nullptr};     /**The Module in which the volume is */
    FairGeoNode* fNode{nullptr};      /**Node corresponding to this volume*/

    ClassDefOverride(FairVolume, 2);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUMELIST_H
#define FAIR_VOLUMELIST_H

#include "FairVolume.h"

#include <Rtypes.h>      // for Int_t, etc
#include <TObjArray.h>   // for TObjArray
#include <TObject.h>     // for TObject
#include <TString.h>     // for TString

// class FairVolume;

/**
 * This Object is only used for internal book keeping!
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairVolumeList : public TObject
{
  private:
    TObjArray* fData;
    FairVolumeList(const FairVolumeList&);
    FairVolumeList& operator=(const FairVolumeList&);

  public:
    FairVolumeList();
    virtual ~FairVolumeList();

    FairVolume* getVolume(TString* name);
    Int_t getVolumeId(TString* name);

    FairVolume* findObject(TString name);
    void addVolume(FairVolume* elem);

    Int_t getEntries() { return fData->GetEntries(); }
    FairVolume* At(Int_t pos) { return (dynamic_cast<FairVolume*>(fData->At(pos))); }

    ClassDef(FairVolumeList, 1);
};

#endif   // FAIR_VOLUMELIST_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairRootFileSink                      -----
// -----                    Created 22.12.2017 by R. Karabowicz            -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef __FAIRROOT__FairRootFileSink__
#define __FAIRROOT__FairRootFileSink__

#include "FairSink.h"

#include <Rtypes.h>
#include <TFile.h>
#include <TString.h>
#include <typeinfo>

class FairEventHeader;
class FairFileHeader;
class TBranch;
class TObjArray;
class TObject;
class TTree;
class TFolder;

class FairRootFileSink : public FairSink
{
  public:
    FairRootFileSink(TFile* f, const char* Title = "OutputRootFile");
    FairRootFileSink(const TString* RootFileName, const char* Title = "OutputRootFile");
    FairRootFileSink(const TString RootFileName, const char* Title = "OutputRootFile");
    //  FairRootFileSink(const FairRootFileSink& file);
    virtual ~FairRootFileSink();

    virtual Bool_t InitSink();
    virtual void Close();
    virtual void Reset();

    virtual Sink_Type GetSinkType() { return kFILESINK; }

    virtual void FillEventHeader(FairEventHeader* feh);

    virtual TFile* OpenRootFile(TString fileName = "");
    TFile* GetRootFile() { return fRootFile; }
    virtual TString GetFileName() { return (fRootFile ? fRootFile->GetName() : ""); }

    virtual void SetOutTree(TTree* fTree) { fOutTree = fTree; }
    TTree* GetOutTree() { return fOutTree; }

    virtual void Fill();

    virtual Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0);

    virtual void RegisterImpl(const char*, const char*, void*);
    virtual void RegisterAny(const char* brname, const std::type_info& oi, const std::type_info& pi, void* obj);

    virtual void WriteFolder();
    virtual bool CreatePersistentBranchesAny();

    virtual void WriteObject(TObject* f, const char*, Int_t option = 0);
    virtual void WriteGeometry();

    virtual FairSink* CloneSink();

  private:
    /** Title of input sink, could be input, background or signal*/
    TString fOutputTitle;
    /** ROOT file */
    TFile* fRootFile;
    /** Output Tree  */
    TTree* fOutTree;
    /**  list of folders from all input (and friends) files */
    TObjArray* fListFolder;   //!
    /** folder structure of output */
    TFolder* fCbmout;
    /** Initialization flag, true if initialized */
    Bool_t fIsInitialized;

    FairRootFileSink(const FairRootFileSink&);
    FairRootFileSink operator=(const FairRootFileSink&);

    void TruncateBranchNames();
    void TruncateBranchNames(TBranch* b, TString ffn);
    // bool CreatePersistentBranchesAny();

    /**File Header*/
    FairFileHeader* fFileHeader;   //!

    bool fPersistentBranchesDone{false};   //!

    ClassDef(FairRootFileSink, 1);
};

#endif /* defined(__FAIRROOT__FairRootFileSink__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairSink                              -----
// -----                    Created 22.12.2017 by R. Karabowicz            -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRSINK_H
#define FAIRSINK_H

#include <Rtypes.h>
#include <TString.h>
#include <map>        // map
#include <memory>     // unique_ptr
#include <string>     // string
#include <typeinfo>   // type_info

class TObject;
class TFolder;
class TTree;

enum Sink_Type
{
    kONLINESINK,
    kFILESINK
};

class FairSink
{
  public:
    FairSink();
    FairSink(const FairSink& sink);
    virtual ~FairSink();

    virtual Bool_t InitSink() = 0;
    virtual void Close() = 0;
    virtual void Reset() = 0;

    virtual Sink_Type GetSinkType() = 0;
    virtual TString GetFileName() { return ""; }

    void SetRunId(Int_t runId) { fRunId = runId; }
    Int_t GetRunId() const { return fRunId; }

    virtual void SetOutTree(TTree* fTree) = 0;

    virtual void Fill() = 0;

    virtual Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) = 0;

    virtual void RegisterImpl(const char*, const char*, void*) = 0;
    virtual void RegisterAny(const char* brname, const std::type_info& oi, const std::type_info& pi, void* obj) = 0;

    virtual void WriteFolder() = 0;
    virtual bool CreatePersistentBranchesAny() = 0;

    virtual void WriteObject(TObject* f, const char*, Int_t option = 0) = 0;
    virtual void WriteGeometry() = 0;

    virtual FairSink* CloneSink() = 0;

  protected:
    struct TypeAddressPair
    {
        TypeAddressPair(const std::type_info& oi, const std::type_info& pi, void* a)
            : origtypeinfo(oi)
            , persistenttypeinfo(pi)
            , ptraddr(a)
        {}
        const std::type_info& origtypeinfo;         // type_info of type addr points to
        const std::type_info& persistenttypeinfo;   // type_info of ROOT persistent branch (drops pointers)
        void* ptraddr;                              // address of a pointer (pointing to origtypeinfo);
    };

    Int_t fRunId;

    /**folder structure of output*/
    TFolder* fOutFolder;
    /// A map of branchnames to typeinformation + memory address;
    /// used for branches registered to bes stored; use of ptr here
    /// since type_info cannot be copied
    std::map<std::string, std::unique_ptr<TypeAddressPair const>> fPersistentBranchesMap;   //!

  public:
    ClassDef(FairSink, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

#ifndef __FAIRROOT__FairFileSourceBase__
#define __FAIRROOT__FairFileSourceBase__

#include "FairSource.h"

#include <TFile.h>
#include <list>
#include <map>

/**
 * \brief Internal base class for FairFileSource and FairMixedSource
 */
class FairFileSourceBase : public FairSource
{
  public:
    ~FairFileSourceBase() override;
    void Reset() override {}
    Source_Type GetSourceType() override { return kFILE; }
    void SetParUnpackers() override {}
    Bool_t InitUnpackers() override { return kTRUE; }
    Bool_t ReInitUnpackers() override { return kTRUE; }

    Bool_t CompareBranchList(TFile* fileHandle, TString inputLevel);

  protected:
    FairFileSourceBase()
        : FairSource(){};

    std::map<TString, std::list<TString>> fCheckInputBranches{};   //!

    ClassDefOverride(FairFileSourceBase, 0);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairFileSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairFileSource__
#define __FAIRROOT__FairFileSource__

#include "FairFileSourceBase.h"

#include <TArrayI.h>
#include <TChain.h>
#include <TF1.h>
#include <TFile.h>
#include <TFolder.h>
#include <TString.h>
#include <list>
#include <map>
#include <memory>

class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TTree;

class FairFileSource : public FairFileSourceBase
{
  public:
    FairFileSource(TFile* f, const char* Title = "InputRootFile", UInt_t identifier = 0);
    FairFileSource(const TString* RootFileName, const char* Title = "InputRootFile", UInt_t identifier = 0);
    FairFileSource(const TString RootFileName, const char* Title = "InputRootFile", UInt_t identifier = 0);
    // FairFileSource(const FairFileSource& file);
    ~FairFileSource() override;

    Bool_t Init() override;
    Int_t ReadEvent(UInt_t i = 0) override;
    void Close() override;

    /**Check the maximum event number we can run to*/
    Int_t CheckMaxEventNo(Int_t EvtEnd = 0) override;
    /**Read the tree entry on one branch**/
    void ReadBranchEvent(const char* BrName) override;
    /**Read specific tree entry on one branch**/
    void ReadBranchEvent(const char* BrName, Int_t Entry) override;
    void FillEventHeader(FairEventHeader* feh) override;

    const TFile* GetRootFile() { return fRootFile; }
    /** Add a friend file (input) by name)*/
    void AddFriend(TString FileName);
    /**Add ROOT file to input, the file will be chained to already added files*/
    void AddFile(TString FileName);
    void AddFriendsToChain();
    void PrintFriendList();
    void CheckFriendChains();
    void CreateNewFriendChain(TString inputFile, TString inputLevel);
    TTree* GetInTree() { return fInChain->GetTree(); }
    TChain* GetInChain() { return fInChain; }
    TFile* GetInFile() { return fRootFile; }
    void CloseInFile()
    {
        if (fRootFile) {
            fRootFile->Close();
        }
    }
    void SetInTree(TTree* tempTree);
    TObjArray* GetListOfFolders() { return fListFolder; }
    TFolder* GetBranchDescriptionFolder() { return fCbmroot; }
    UInt_t GetEntries() { return fNoOfEntries; }

    //    TList*              GetBranchNameList() {return fBranchNameList;}

    void SetInputFile(TString name);

    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime).
     * The total repetition time is beamTime + gapTime */
    void SetBeamTime(Double_t beamTime, Double_t gapTime);
    /** Set the min and max limit for event time in ns */
    void SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void SetEventMeanTime(Double_t mean);
    void SetEventTime();
    Double_t GetDeltaEventTime();
    void SetFileHeader(FairFileHeader* f) { fFileHeader = f; }
    Double_t GetEventTime();

    Bool_t ActivateObject(TObject** obj, const char* BrName) override;
    Bool_t ActivateObjectAny(void**, const std::type_info&, const char*) override;

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void SetEvtHeaderNew(Bool_t Status) { fEvtHeaderIsNew = Status; }
    Bool_t IsEvtHeaderNew() { return fEvtHeaderIsNew; }

    /** Allow to disable the testing the file layout when adding files to a chain.
     */
    void SetCheckFileLayout(Bool_t enable) { fCheckFileLayout = enable; }

    /**Read one event from source to find out which RunId to use*/
    Bool_t SpecifyRunId() override;

  private:
    /** Title of input source, could be input, background or signal*/
    TString fInputTitle;
    /**ROOT file*/
    TFile* fRootFile;
    /** Current Entry number */
    Int_t fCurrentEntryNr;   //!
    /** List of all files added with AddFriend */
    std::list<TString> fFriendFileList;                                 //!
    std::list<TString> fInputChainList;                                 //!
    std::map<TString, TChain*> fFriendTypeList;                         //!
    std::list<TString> fInputLevel;                                     //!
    std::map<TString, std::multimap<TString, TArrayI>> fRunIdInfoAll;   //!
    /**Input Chain */
    TChain* fInChain;
    /**Input Tree */
    TTree* fInTree;
    /** list of folders from all input (and friends) files*/
    TObjArray* fListFolder;   //!
    /**folder structure of output*/
    TFolder* fCbmout;
    /**folder structure of input*/
    TFolder* fCbmroot;
    /***/
    UInt_t fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t IsInitialized;

    FairFileSource(const FairFileSource&);
    FairFileSource operator=(const FairFileSource&);

    /** MC Event header */
    FairMCEventHeader* fMCHeader;   //!

    /**Event Header*/
    FairEventHeader* fEvtHeader;   //!

    /**File Header*/
    FairFileHeader* fFileHeader;   //!

    /** This is true if the event time used, came from simulation*/
    Bool_t fEventTimeInMCHeader;   //!
    /**This flag is true if the event header was created in this session
     * otherwise it is false which means the header was created in a previous data
     * level and used here (e.g. in the digi)
     */
    Bool_t fEvtHeaderIsNew;   //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t fCurrentEntryNo;   //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t fTimeforEntryNo;   //!

    /** min time for one event (ns) */
    Double_t fEventTimeMin;   //!
    /** max time for one Event (ns) */
    Double_t fEventTimeMax;   //!
    /** Time of event since th start (ns) */
    Double_t fEventTime;   //!
    /** Time of particles in beam (ns) */
    Double_t fBeamTime;   //!
    /** Time without particles in beam (gap) (ns) */
    Double_t fGapTime;   //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t fEventMeanTime;   //!
    /** used to generate random numbers for event time; */
    std::unique_ptr<TF1> fTimeProb;   //!
    /** True if the file layout should be checked when adding files to a chain.
     *  Default value is true.
     */
    Bool_t fCheckFileLayout;   //!

    ClassDefOverride(FairFileSource, 3);
};

#endif /* defined(__FAIRROOT__FairFileSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairMixedSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairMixedSource__
#define __FAIRROOT__FairMixedSource__

#include "FairFileSourceBase.h"

#include <TArrayI.h>
#include <TChain.h>
#include <TF1.h>
#include <TFile.h>
#include <list>
#include <map>
#include <memory>

class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TString;
class TFolder;
class TObject;

class FairRootManager;

class FairMixedSource : public FairFileSourceBase
{
  public:
    FairMixedSource(TFile* f, const char* Title = "InputRootFile", UInt_t identifier = 0);
    FairMixedSource(const TString* RootFileName, const char* Title = "InputRootFile", UInt_t identifier = 0);
    FairMixedSource(const TString RootFileName,
                    const Int_t signalId,
                    const char* Title = "InputRootFile",
                    UInt_t identifier = 0);
    //  FairMixedSource(const FairMixedSource& file);
    ~FairMixedSource() override;

    Bool_t Init() override;
    Int_t ReadEvent(UInt_t i = 0) override;
    void Close() override;

    /**Check the maximum event number we can run to*/
    Int_t CheckMaxEventNo(Int_t EvtEnd = 0) override;
    /**Read the tree entry on one branch**/
    void ReadBranchEvent(const char* BrName) override;
    /** Read specific tree entry on one branch**/
    void ReadBranchEvent(const char* BrName, Int_t Entry) override;

    void FillEventHeader(FairEventHeader* feh) override;

    const TFile* GetRootFile() { return fRootFile; }
    /** Add a friend file (input) by name)*/

    Bool_t ActivateObject(TObject** obj, const char* BrName) override;
    Bool_t ActivateObjectAny(void**, const std::type_info&, const char*) override;

    void ReadBKEvent(UInt_t i = 0);

    /**Set the input signal file
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file
     */
    void SetSignalFile(TString name, UInt_t identifier);
    /**Set the input background file by name*/
    void SetBackgroundFile(TString name);
    /**Add signal file to input
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file to which this signal should be added
     */
    void AddSignalFile(TString name, UInt_t identifier);
    void AddBackgroundFile(TString name);

    TChain* GetBGChain() { return fBackgroundChain; }
    TChain* GetSignalChainNo(UInt_t i);

    Bool_t OpenBackgroundChain();
    Bool_t OpenSignalChain();

    /**Set the signal to background ratio in event units
     *@param background :  Number of background Events for one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     */
    void BGWindowWidthNo(UInt_t background, UInt_t Signalid);
    /**Set the signal to background rate in time units
     *@param background :  Time of background Events before one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     */
    void BGWindowWidthTime(Double_t background, UInt_t Signalid);

    /** Set the min and max limit for event time in ns */
    void SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void SetEventMeanTime(Double_t mean);
    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime).
     * The total repetition time is beamTime + gapTime */
    void SetBeamTime(Double_t beamTime, Double_t gapTime);
    void SetEventTime();
    Double_t GetDeltaEventTime();
    void SetFileHeader(FairFileHeader* f) { fFileHeader = f; }
    Double_t GetEventTime();

    TObjArray* GetListOfFolders() { return fListFolder; }
    TFolder* GetBranchDescriptionFolder() { return fCbmroot; }
    UInt_t GetEntries() { return fNoOfEntries; }

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void SetEvtHeaderNew(Bool_t Status) { fEvtHeaderIsNew = Status; }
    Bool_t IsEvtHeaderNew() { return fEvtHeaderIsNew; }

    /** Use the Backgraund RunID to initialize the parameter for the run */
    void UseRunIdFromBG();
    /** Use the Backgraund RunID to initialize the parameter for the run
     *@param identifier: Signal file identifier to be used by default we take the first Signal
     */
    void UseRunIdfromSG(UInt_t identifier = 1);

  private:
    /**IO manager */
    FairRootManager* fRootManager;

    /** Title of input source, could be input, background or signal*/
    TString fInputTitle;
    /**ROOT file*/
    TFile* fRootFile;
    /** List of all files added with AddFriend */
    std::list<TString> fFriendFileList;                                 //!
    std::list<TString> fInputChainList;                                 //!
    std::map<TString, TChain*> fFriendTypeList;                         //!
    std::list<TString> fInputLevel;                                     //!
    std::map<TString, std::multimap<TString, TArrayI>> fRunIdInfoAll;   //!
    /** list of folders from all input (and friends) files*/
    TObjArray* fListFolder;   //!
    /**folder structure of output*/
    TFolder* fCbmout;
    /**folder structure of input*/
    TFolder* fCbmroot;
    /***/
    UInt_t fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t IsInitialized;

    /** MC Event header */
    FairMCEventHeader* fMCHeader;   //!

    /**Event Header*/
    FairEventHeader* fEvtHeader;   //!

    /**Output Event Header*/
    FairEventHeader* fOutHeader;   //!

    /**File Header*/
    FairFileHeader* fFileHeader;   //!

    /** This is true if the event time used, came from simulation*/
    Bool_t fEventTimeInMCHeader;   //!
    /**This flag is true if the event header was created in this session
     * otherwise it is false which means the header was created in a previous data
     * level and used here (e.g. in the digi)
     */
    Bool_t fEvtHeaderIsNew;   //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t fCurrentEntryNo;   //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t fTimeforEntryNo;   //!
    /* /\**No of entries in BG Chain*\/ */
    UInt_t fNoOfBGEntries;   //!
    /* /\**Hold the current entry for each input chain*\/ */
    std::map<UInt_t, UInt_t> fCurrentEntry;   //!

    /** min time for one event (ns) */
    Double_t fEventTimeMin;   //!
    /** max time for one Event (ns) */
    Double_t fEventTimeMax;   //!
    /** Time of event since th start (ns) */
    Double_t fEventTime;   //!
    /** Time of particles in beam (ns) */
    Double_t fBeamTime;   //!
    /** Time without particles in beam (gap) (ns) */
    Double_t fGapTime;   //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t fEventMeanTime;   //!
    /** used to generate random numbers for event time; */
    std::unique_ptr<TF1> fTimeProb;   //!

    /**holds the SB ratio by number*/
    std::map<UInt_t, Double_t> fSignalBGN;   //!
    /* /\**True for background window in entry units*\/ */
    Bool_t fSBRatiobyN;   //!
    /* /\**True for background window in time units (ns) *\/ */
    Bool_t fSBRatiobyT;   //!

    /**Actual identifier of the added signals, this is used to identify how many signals are added*/
    UInt_t fActualSignalIdentifier;   //!
    /** Total number of signals added (Types and not files!)*/
    UInt_t fNoOfSignals;   //!
    /** list of chains which has to be created for the different signals*/
    std::list<TString>* fSignalChainList;   //!
    /**Chain containing the background*/
    TChain* fBackgroundChain;                    //!
    std::map<UInt_t, TChain*> fSignalTypeList;   //!

    /**True if RunId is taken from Backgraund*/
    Bool_t fRunIdFromBG;   //!
    /**True if RunId is taken from Signal */
    Bool_t fRunIdFromSG;   //!
    /** Identifier of signal file for RunID
     * Zero if RunId is taken from BG.
     */
    UInt_t fRunIdFromSG_identifier;   //!

    /**Read one event from source to find out which RunId to use*/
    Bool_t SpecifyRunId() override;

    FairMixedSource(const FairMixedSource&);
    FairMixedSource& operator=(const FairMixedSource&);

  public:
    ClassDefOverride(FairMixedSource, 0);
};

#endif /* defined(__FAIRROOT__FairMixedSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairSource                            -----
// -----                    Created 01.11.2013 by F. Uhlig                 -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRSOURCE_H
#define FAIRSOURCE_H

#include "FairLogger.h"
#include "TClass.h"

#include <Rtypes.h>
#include <TObject.h>

class FairEventHeader;

enum Source_Type
{
    kONLINE,
    kFILE
};

class FairSource : public TObject
{
  public:
    FairSource();
    FairSource(const FairSource& source);
    virtual ~FairSource();
    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t = 0) = 0;
    virtual Bool_t SpecifyRunId() = 0;
    virtual void Close() = 0;
    virtual void Reset() = 0;
    virtual Bool_t ActivateObject(TObject**, const char*) { return kFALSE; }
    virtual Bool_t ActivateObjectAny(void**, const std::type_info&, const char*) { return kFALSE; }
    virtual Source_Type GetSourceType() = 0;
    virtual void SetParUnpackers() = 0;
    virtual Bool_t InitUnpackers() = 0;
    virtual Bool_t ReInitUnpackers() = 0;
    /**Check the maximum event number we can run to*/
    virtual Int_t CheckMaxEventNo(Int_t = 0) { return -1; }
    /**Read the tree entry on one branch**/
    virtual void ReadBranchEvent(const char*) { return; }
    virtual void ReadBranchEvent(const char*, Int_t) { return; }
    virtual void FillEventHeader(FairEventHeader* feh);
    void SetRunId(Int_t runId) { fRunId = runId; }
    Int_t GetRunId() const { return fRunId; }

  protected:
    Int_t fRunId;

  public:
    ClassDef(FairSource, 2);
};

namespace {

template<typename S>
bool ActivateObjectAnyImpl(S* source, void** obj, const std::type_info& info, const char* brname)
{
    // we check if the types match at all
    auto br = source->GetBranch(brname);
    if (!br) {
        // branch not found in source
        return false;
    }

    // look up the TClass and resulting typeid stored in this branch
    auto cl = TClass::GetClass(br->GetClassName());
    if (!cl) {
        // class not found
        return false;
    }

    auto storedtype = cl->GetTypeInfo();

    // check consistency of types
    if (info.hash_code() != storedtype->hash_code()) {
        LOG(info) << "Trying to read from branch " << brname << " with wrong type " << info.name()
                  << " (expected: " << storedtype->name() << ")\n";
        return false;
    }
    source->SetBranchStatus(brname, 1);
    // force to use the (void*) interface which is non-checking
    source->SetBranchAddress(brname, (void*)obj);
    return true;
}

}   // namespace

#endif
#ifndef FAIR_LINK_MANAGER_H
#define FAIR_LINK_MANAGER_H

#include <Rtypes.h>    // for Bool_t, Int_t, UInt_t, etc
#include <TMCtls.h>    // for multi-threading
#include <TObject.h>   // for TObject
#include <set>         // for set of branch types to ignore

class FairLogger;

class FairLinkManager : public TObject
{
  public:
    /**ctor*/
    FairLinkManager();
    /**dtor*/
    virtual ~FairLinkManager();

    /** static access method */
    static FairLinkManager* Instance();
    virtual void AddIgnoreType(Int_t type);   ///< Adds a BranchId (Type) to which links are not included in the link
                                              ///< list. Either ignore types or include types can be given.
    virtual Bool_t IsIgnoreType(Int_t type) const;

    virtual void AddIncludeType(Int_t type);   ///< Adds a BranchId (Type) to which links are included in the link list.
                                               ///< Either ignore types or include types can be given (XOR).

    std::set<Int_t> GetIgnoreTypes() const { return fIgnoreTypes; }

  private:
    /**private methods*/
    FairLinkManager(const FairLinkManager&);
    FairLinkManager& operator=(const FairLinkManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/

    std::set<Int_t> fIgnoreTypes;   //!
    Bool_t fIgnoreSetting;

    /**Singleton instance*/
    static TMCThreadLocal FairLinkManager* fgInstance;

    FairLogger* fLogger;   //!

    ClassDef(FairLinkManager, 1);
};

#endif   // FAIR_ROOT_MANAGER_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairRadGridManager source file             -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------
#ifndef FAIRRADGRIDMANAGER_H
#define FAIRRADGRIDMANAGER_H 1

#include <Rtypes.h>           // for Float_t, Double_t, Int_t, etc
#include <TLorentzVector.h>   // for TLorentzVector
#include <TObjArray.h>        // for TObjArray
#include <TString.h>          // for TString
#include <iostream>           // for basic_ostream::operator<<, etc

class FairMesh;
class TClonesArray;

/**
 * @class FairRadGridManager
 */

class FairRadGridManager
{
  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadGridManager class.
     */
    FairRadGridManager();
    /**
     * Destructor.
     */
    virtual ~FairRadGridManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadGridManager, 1);

  private:
    FairRadGridManager(const FairRadGridManager&);
    FairRadGridManager& operator=(const FairRadGridManager&);

    static FairRadGridManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray* fPointCollection;
    /**track index */
    Int_t fTrackID;   //!
    /**volume id */
    Int_t fVolumeID;   //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;   //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;   //!
    /**  momentum in*/
    TLorentzVector fMomIn;   //!
    /**  momentum out*/
    TLorentzVector fMomOut;   //!
    /**track time */
    Double_t fTime;   //!
    /**track length */
    Double_t fLength;   //!
    /** energy loss */
    Double_t fELoss;   //!
    /** mass umber*/
    Float_t fA;
    /** atomic number*/
    Float_t fZmat;
    /**  density */
    Float_t fDensity;
    /**radition length */
    Float_t fRadl;
    /**absorption length */
    Float_t fAbsl;
    /**estimator*/
    Int_t fEstimator;
    /** the mesh */
    TObjArray* fMeshList;
    /** output file name */
    TString fOutputFileName;

  public:
    TObjArray* GetMeshList() { return fMeshList; }
    void AddMeshList(TObjArray* list)
    {
        std::cout << " grid manag " << list->GetEntriesFast() << std::endl;
        fMeshList = list;
    }
    Bool_t IsTrackInside(TLorentzVector& vec, FairMesh* aMesh);
    Bool_t IsTrackEntering(TLorentzVector& vec1, TLorentzVector& vec2);
    /** fill the 2D mesh */
    void FillMeshList();
    /**initialize the manager*/
    void Init();
    /**reset*/
    void Reset();
    /**set output file name*/
    void SetOutputFileName(TString tempString) { fOutputFileName = tempString; }
    TString GetOutputFileName() { return fOutputFileName; }
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadGridManager object, created
     * with FairRadGridManager::FairRadGridManager().
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated("Maybe use FairMCApplcation::GetRadGridMan()")]] static FairRadGridManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenManager source file             -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADLENMANAGER_H
#define FAIRRADLENMANAGER_H 1

#include <Rtypes.h>           // for Float_t, Double_t, Int_t, etc
#include <TLorentzVector.h>   // for TLorentzVector

class TClonesArray;
class TVirtualMC;

/**
 * @class FairRadLenManager
 */

class FairRadLenManager
{
  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadLenManager class.
     */
    FairRadLenManager();

    /**
     * Destructor.
     */
    virtual ~FairRadLenManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadLenManager, 1);

  private:
    FairRadLenManager(const FairRadLenManager&);
    FairRadLenManager& operator=(const FairRadLenManager&);

    static FairRadLenManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray* fPointCollection;
    /**track index */
    Int_t fTrackID;   //!
    /**volume id */
    Int_t fVolumeID;   //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;   //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;   //!
    /**  momentum in*/
    TLorentzVector fMomIn;   //!
    /**  momentum out*/
    TLorentzVector fMomOut;   //!
    /**track time */
    Double_t fTime;   //!
    /**track length */
    Double_t fLength;   //!
    /** energy loss */
    Double_t fELoss;   //!
    /** mass umber*/
    Float_t fA;
    /** atomic number*/
    Float_t fZmat;
    /**  density */
    Float_t fDensity;
    /**radition length */
    Float_t fRadl;
    /**absorption length */
    Float_t fAbsl;

  public:
    /**Add point to collection*/
    void AddPoint(TVirtualMC* aMC, const Int_t ModuleId);
    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated("Use AddPoint(TVirtualMC*, ...)")]] void AddPoint(const Int_t ModuleId);
    /**initialize the manager*/
    void Init();
    /**reset*/
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadLenManager object, created
     * with FairRadLenManager::FairRadLenManager().
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] static FairRadLenManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadMapManager source file            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADMAPMANAGER_H
#define FAIRRADMAPMANAGER_H 1

#include <Rtypes.h>           // for Double_t, Float_t, Int_t, etc
#include <TLorentzVector.h>   // for TLorentzVector

class TClonesArray;
class TMap;
class TVirtualMC;

/**
 * @class FairRadMapManager
 */

class FairRadMapManager
{
  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadMapManager class.
     */
    FairRadMapManager();

    /**
     * Destructor.
     */
    virtual ~FairRadMapManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadMapManager, 1);

  private:
    FairRadMapManager(const FairRadMapManager&);
    FairRadMapManager& operator=(const FairRadMapManager&);

    static FairRadMapManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray* fPointCollection;
    /**track index */
    Int_t fTrackID;   //!
    /**volume id */
    Int_t fVolumeID;   //!
    /** pid */
    Int_t fPdg;   //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;   //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;   //!
    /**  momentum in*/
    TLorentzVector fMomIn;   //!
    /**  momentum out*/
    TLorentzVector fMomOut;   //!
    /**track time */
    Double_t fTime;   //!
    /**track length */
    Double_t fLength;   //!
    /**track setp */
    Double_t fStep;
    /** energy loss */
    Double_t fELoss;   //!
    /**dose */
    Double_t fDose;
    Double_t fDoseSL;
    /** mass umber*/
    Float_t fA;
    /** atomic number*/
    Float_t fZmat;
    /** radiation length*/
    Float_t fRadl;
    /**  density */
    Float_t fDensity;
    /**absorption length */
    Float_t fAbsl;
    //**volume, mass */
    Double_t fActVol;
    Double_t fActMass;

    TMap* fMassMap;

  public:
    /**Add point to collection*/
    void AddPoint(TVirtualMC* aMC, const Int_t);
    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated("Use AddPoint(TVirtualMC*, ...)")]] void AddPoint(const Int_t ModuleId);
    /**initialize the manager*/
    void Init();
    /**reset*/
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadMapManager object, created
     * with FairRadMapManager::FairRadMapManager().
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] static FairRadMapManager* Instance();
    //  void GetGeoManager();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairRingSorter.h
 *
 *  Created on: Jul 15, 2010
 *      Author: stockman
 */

#ifndef FairRingSorter_H_
#define FairRingSorter_H_

#include <Rtypes.h>    // for FairRingSorter::Class, etc
#include <TObject.h>   // for TObject
#include <iostream>    // for operator<<, ostream, etc
#include <map>         // for multimap
#include <utility>     // for pair
#include <vector>      // for vector

class FairTimeStamp;

class FairRingSorter : public TObject
{
  public:
    FairRingSorter(int size = 100, double width = 10)
        : TObject()
        , fRingBuffer(size)
        , fOutputData()
        , fLowerBoundPointer(0, 0)
        , fCellWidth(width)
        , fVerbose(0)
    {}

    virtual ~FairRingSorter(){};

    virtual FairTimeStamp* CreateElement(FairTimeStamp* data);

    virtual void AddElement(FairTimeStamp* digi, double timestamp);
    virtual void WriteOutElements(int index);   ///< writes out the entries from LowerBoundPointer up to index
    virtual void WriteOutElement(int index);    ///< writes out the entry at the index and clears it
    virtual void WriteOutAll() { WriteOutElements(fLowerBoundPointer.first); }
    virtual double GetBufferSize() { return fCellWidth * fRingBuffer.size(); }
    virtual std::vector<FairTimeStamp*> GetOutputData() { return fOutputData; }

    virtual void DeleteOutputData() { fOutputData.clear(); }
    virtual void SetLowerBound(double timestampOfHitToWrite);

    virtual void print(std::ostream& out = std::cout)
    {
        out << "RingSorter: Size " << fRingBuffer.size() << " CellWidth: " << fCellWidth << "\n";
        out << "LowerBoundPointer at index: " << fLowerBoundPointer.first << " Time: " << fLowerBoundPointer.second
            << "\n";
        out << "| ";
        for (unsigned int i = 0; i < fRingBuffer.size(); i++) {
            out << fRingBuffer[i].size() << " |";
        }
        out << std::endl;
    }

  private:
    int CalcIndex(double val);
    std::vector<std::multimap<double, FairTimeStamp*>> fRingBuffer;
    std::vector<FairTimeStamp*> fOutputData;
    std::pair<int, double> fLowerBoundPointer;
    double fCellWidth;
    int fVerbose;

    ClassDef(FairRingSorter, 1);
};

#endif /* FairRingSorter_H_ */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

/** FairRingSorterTask.h
 **
 **/

#ifndef FairRingSorterTask_H
#define FairRingSorterTask_H

#include "FairRingSorter.h"   // for FairRingSorter
#include "FairTask.h"         // for FairTask, InitStatus

#include <Rtypes.h>    // for Bool_t, Int_t, kTRUE, etc
#include <TString.h>   // for TString

class FairTimeStamp;
class TClonesArray;

class FairRingSorterTask : public FairTask
{
  public:
    /** Default constructor **/
    FairRingSorterTask()
        : FairTask("SorterTask")
        , fSorter(0)
        , fPersistance(kTRUE)
        , fDigiPixelMCInfo(kFALSE)
        , fNumberOfCells(1000)
        , fWidthOfCells(10)
        , fInputBranch()
        , fInputArray(0)
        , fOutputBranch()
        , fFolder()
        , fOutputArray(0)
        , fEntryNr(0)
    {
        SetVerbose(0);
    }

    /** Named constructor **/
    FairRingSorterTask(const char* name)
        : FairTask(name)
        , fSorter(0)
        , fPersistance(kTRUE)
        , fDigiPixelMCInfo(kFALSE)
        , fNumberOfCells(1000)
        , fWidthOfCells(10)
        , fInputBranch()
        , fInputArray(0)
        , fOutputBranch()
        , fFolder()
        , fOutputArray(0)
        , fEntryNr(0)
    {
        SetVerbose(0);
    }

    FairRingSorterTask(Int_t numberOfCells,
                       Double_t widthOfCells,
                       TString inputBranch,
                       TString outputBranch,
                       TString folderName)
        : FairTask("Sorter")
        , fSorter(0)
        , fPersistance(kTRUE)
        , fDigiPixelMCInfo(kFALSE)
        , fNumberOfCells(numberOfCells)
        , fWidthOfCells(widthOfCells)
        , fInputBranch(inputBranch)
        , fInputArray(0)
        , fOutputBranch(outputBranch)
        , fFolder(folderName)
        , fOutputArray(0)
        , fEntryNr(0)
    {
        SetVerbose(0);
    }

    /** Destructor **/
    ~FairRingSorterTask() override { delete fSorter; }

    /** Virtual method Init **/
    InitStatus Init() override;
    InitStatus ReInit() override;

    /** Virtual method Exec **/
    void Exec(Option_t* opt) override;
    void FinishEvent() override;
    void FinishTask() override;

    void SetPersistance(Bool_t p = kTRUE) { fPersistance = p; };
    Bool_t GetPersistance() { return fPersistance; };

    virtual void AddNewDataToTClonesArray(FairTimeStamp* data);
    virtual FairRingSorter* InitSorter(Int_t numberOfCells, Double_t widthOfCells) const;

  protected:
    FairRingSorter* fSorter;
    /** switch to turn on/off storing the arrays to a file*/
    Bool_t fPersistance;
    /** switch to turn on/off storing additional MC Info of Digis*/
    Bool_t fDigiPixelMCInfo;
    Int_t fNumberOfCells;
    Double_t fWidthOfCells;   // in ns
    /** Input array of PndSdsPixelDigis **/
    TString fInputBranch;
    TClonesArray* fInputArray;
    /** Output array of sorted PndSdsDigis **/
    TString fOutputBranch;
    TString fFolder;
    TClonesArray* fOutputArray;
    Int_t fEntryNr;
    FairRingSorterTask(const FairRingSorterTask&);
    FairRingSorterTask& operator=(const FairRingSorterTask&);

    ClassDefOverride(FairRingSorterTask, 2);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_ROOT_MANAGER_H
#define FAIR_ROOT_MANAGER_H

#include "FairLogger.h"
#include "FairSink.h"
#include "FairSource.h"

#include <Rtypes.h>      // for Bool_t, Int_t, UInt_t, etc
#include <TChain.h>      // for TChain
#include <TObject.h>     // for TObject
#include <TRefArray.h>   // for TRefArray
#include <TString.h>     // for TString, operator<
#include <map>           // for map, multimap, etc
#include <memory>
#include <string>
#include <type_traits>   // is_pointer, remove_pointer, is_const, remove...
#include <typeinfo>
#include <vector>

class BinaryFunctor;
class FairEventHeader;
class FairFileHeader;
class FairLink;
class FairTSBufferFunctional;
class FairWriteoutBuffer;
class TBranch;
class TClonesArray;
class TObjArray;
class TCollection;
class TFile;
class TFolder;
class TList;
class TNamed;
class TTree;

/**
 * I/O Manager class
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairRootManager : public TObject
{
  public:
    /**dtor*/
    ~FairRootManager() override;
    Bool_t AllDataProcessed();
    /** Add a branch name to the Branchlist and give it an id*/
    Int_t AddBranchToList(const char* name);
    /**
    Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist   */
    Int_t CheckBranch(const char* BrName);

    void CloseSink()
    {
        if (fSink) {
            fSink->Close();
        }
    }
    /**Create a new file and save the current TGeoManager object to it*/
    void CreateGeometryFile(const char* geofile);
    void Fill();
    void LastFill();
    TClonesArray* GetEmptyTClonesArray(TString branchName);
    TClonesArray* GetTClonesArray(TString branchName);
    /**Update the list of Memory branches from the source used*/
    void UpdateBranches();

    /**Return branch name by Id*/
    TString GetBranchName(Int_t id);
    /**Return Id of a branch named */
    Int_t GetBranchId(TString const& BrName);

    /**The MCTrack branch stands out since it is required by the framework algorithms**/
    Int_t GetMCTrackBranchId() const { return fMCTrackBranchId; }

    /**Return a TList of TObjString of branch names available in this session*/
    TList* GetBranchNameList() { return fBranchNameList; }

    /**  Get the Object (container) for the given branch name,
         this method can be used to access the data of
         a branch that was created from a different
         analysis task, and not written in the tree yet.
         the user have to cast this pointer to the right type.
         Return a pointer to the object (collection) saved in the fInChain branch named BrName*/
    TObject* GetObject(const char* BrName);

    /// Initializes and returns a default object for a branch or looks it up when it exists already.
    /// Returns nullptr when the branch does not exist or looking up with wrong type.
    /// The name Init indicates that this functions should be called only in Init sections of FairTasks.
    /// The returned default object will be filled with data by the framework.
    template<typename T>
    T InitObjectAs(const char* BrName);

    /** Return a pointer to the object (collection) saved in the fInTree branch named BrName*/
    Double_t GetEventTime();
    /** Returns a clone of the data object the link is pointing to. The clone has to be deleted in the calling code! */
    TObject* GetCloneOfLinkData(const FairLink link);
    /** Get the data of the given branch name,
     *  this method runs over multiple entries
     *  of the tree and selects the data according
     *  to the function and the parameter given.
     */

    TClonesArray* GetCloneOfTClonesArray(const FairLink link);

    void InitTSBuffer(TString branchName, BinaryFunctor* function);
    TClonesArray* GetData(TString branchName, BinaryFunctor* function, Double_t parameter);
    TClonesArray* GetData(TString branchName,
                          BinaryFunctor* startFunction,
                          Double_t startParameter,
                          BinaryFunctor* stopFunction,
                          Double_t stopParameter);
    void RegisterTSBuffer(TString branchName, FairTSBufferFunctional* functionalBuffer)
    {
        fTSBufferMap[branchName] = functionalBuffer;
    }
    void TerminateTSBuffer(TString branchName);
    void TerminateAllTSBuffer();
    FairTSBufferFunctional* GetTSBuffer(TString branchName) { return fTSBufferMap[branchName]; }

    /** static access method */
    static FairRootManager* Instance();

    /**Read a single entry from background chain*/
    Int_t ReadEvent(Int_t i = 0);
    /** Read a single entry from each branch that is not read via TSBuffers*/
    Int_t ReadNonTimeBasedEventFromBranches(Int_t i = 0);
    /**Read the tree entry on one branch**/
    void ReadBranchEvent(const char* BrName);
    /**Read the tree entry on one branch for a specific entry**/
    void ReadBranchEvent(const char* BrName, Int_t entry);

    /**Read all entries from input tree(s) with time stamp from current time to dt (time in ns)*/

    Int_t GetRunId();

    Bool_t ReadNextEvent(Double_t dt);
    /**create a new branch in the output tree
     *@param name            Name of the branch to create
     *@param Foldername      Folder name containing this branch (e.g Detector name)
     *@param obj             Pointer of type TNamed (e.g. MCStack object)
     *@param toFile          if kTRUE, branch will be saved to the tree*/
    void Register(const char* name, const char* Foldername, TNamed* obj, Bool_t toFile);
    /**create a new branch in the output tree
     *@param name            Name of the branch to create
     *@param Foldername      Folder name containing this branch (e.g Detector name)
     *@param obj             Pointer of type TCollection (e.g. TClonesArray of hits, points)
     *@param toFile          if kTRUE, branch will be saved to the tree*/
    void Register(const char* name, const char* Foldername, TCollection* obj, Bool_t toFile);

    /** create a new branch based on an arbitrary type T (for which a dictionary must exist) **/
    template<typename T>
    void RegisterAny(const char* name, T*& obj, Bool_t toFile);

    void RegisterInputObject(const char* name, TObject* obj);

    TClonesArray* Register(TString branchName, TString className, TString folderName, Bool_t toFile);
    /** Register a new FairWriteoutBuffer to the map. If a Buffer with the same map key already exists the given buffer
     * will be deleted and the old will be returned!*/
    FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer);
    /**Update the list of time based branches in the output file*/
    void UpdateListOfTimebasedBranches();
    /**Use time stamps to read data and not tree entries
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] void RunWithTimeStamps() {}

    /**Set the branch name list*/
    void SetBranchNameList(TList* list);
    /** Replace the time based branch name list*/
    void SetTimeBasedBranchNameList(TList* list);

    /** \deprecated Deprecated in v18.8, will be removed in v20. */
    [[deprecated]] void FillEventHeader(FairEventHeader* feh)
    {
        if (fSource)
            fSource->FillEventHeader(feh);
    }

    /**Enables a last Fill command after all events are processed to store any data which is still in Buffers*/
    void SetLastFill(Bool_t val = kTRUE) { fFillLastData = val; }
    /**When creating TTree from TFolder the fullpath of the objects is used as branch names
     * this method truncate the full path from the branch names
     */

    Int_t Write(const char* name = nullptr, Int_t option = 0, Int_t bufsize = 0) override;
    /** Write the current TGeoManager to file*/
    void WriteGeometry();
    /**Write the file header object to the output file*/
    void WriteFileHeader(FairFileHeader* f);
    /**Write the folder structure used to create the tree to the output file */
    void WriteFolder();

    /**Check the maximum event number we can run to*/
    Int_t CheckMaxEventNo(Int_t EvtEnd = 0);

    void StoreWriteoutBufferData(Double_t eventTime);
    void StoreAllWriteoutBufferData();
    void DeleteOldWriteoutBufferData();

    Int_t GetEntryNr() { return fEntryNr; }
    void SetEntryNr(Int_t val) { fEntryNr = val; }

    void SetUseFairLinks(Bool_t val) { fUseFairLinks = val; };
    Bool_t GetUseFairLinks() const { return fUseFairLinks; };

    /**
     * @param Status : if  true all inputs are mixed, i.e: each read event will take one entry from each input and put
     * them in one big event and send it to the next step
     */
    /* void SetMixAllInputs(Bool_t Status) { */
    /*    fMixAllInputs=kTRUE; */
    /* } */

    /** These methods have been moved to the FairFileSource */
    void SetSource(FairSource* tempSource) { fSource = tempSource; }
    FairSource* GetSource() { return fSource; }
    Bool_t InitSource();

    void SetSink(FairSink* tempSink) { fSink = tempSink; }
    FairSink* GetSink() { return fSink; }
    Bool_t InitSink();

    void SetListOfFolders(TObjArray* ta) { fListFolder = ta; }
    TChain* GetInChain() { return fSourceChain; }
    TChain* GetSignalChainNo(UInt_t i) { return fSignalChainList[i]; }
    TTree* GetInTree()
    {
        if (fSourceChain)
            return fSourceChain->GetTree();
        return 0;
    }
    const TFile* GetRootFile()
    {
        if (fSourceChain)
            return fSourceChain->GetFile();
        return 0;
    }
    TFile* GetInFile()
    {
        if (fSourceChain)
            return fSourceChain->GetFile();
        return 0;
    }
    void SetInChain(TChain* tempChain, Int_t ident = -1);
    /* /\**Set the input tree when running on PROOF worker*\/ */

    void SetFinishRun(Bool_t val = kTRUE) { fFinishRun = val; }
    Bool_t FinishRun() { return fFinishRun; }

    static void SetTreeName(const std::string& tname) { fTreeName = tname; }
    static void SetFolderName(const std::string& tname) { fFolderName = tname; }

    const static char* GetTreeName();
    const static char* GetFolderName();

    /**public Members for multi-threading */
    Int_t GetInstanceId() const { return fId; }
    void UpdateFileName(TString& fileName);

    /** Return a pointer to the output File of type TFile */
    TFile* GetOutFile();
    /** Return a pointer to the output tree of type TTree */
    TTree* GetOutTree();

    /**Read one event from source to find out which RunId to use*/
    Bool_t SpecifyRunId();

  private:
    // helper struct since std::pair has problems with type_info
    struct TypeAddressPair
    {
        TypeAddressPair(const std::type_info& oi, const std::type_info& pi, void* a)
            : origtypeinfo(oi)
            , persistenttypeinfo(pi)
            , ptraddr(a)
        {}
        const std::type_info& origtypeinfo;         // type_info of type addr points to
        const std::type_info& persistenttypeinfo;   // type_info of ROOT persistent branch (drops pointers)
        void* ptraddr;                              // address of a pointer (pointing to origtypeinfo);
    };

    /**private methods*/
    /**ctor*/
    FairRootManager();
    FairRootManager(const FairRootManager&);
    FairRootManager& operator=(const FairRootManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/
    TObject* ActivateBranch(const char* BrName);
    void AddFriends();
    /**Add a branch to memory, it will not be written to the output files*/
    void AddMemoryBranch(const char*, TObject*);

    template<typename T>
    void AddMemoryBranchAny(const char* name, T** obj);
    template<typename T>
    T GetMemoryBranchAny(const char* name) const;

    template<typename T>
    void RegisterImpl(const char* name, const char* Foldername, T* obj, Bool_t toFile);

    /** Internal Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist
    */
    Int_t CheckBranchSt(const char* BrName);
    /**Create the Map for the branch persistency status  */
    void CreatePerMap();
    TObject* GetMemoryBranch(const char*);
    //   void                GetRunIdInfo(TString fileName, TString inputLevel);

    FairWriteoutBuffer* GetWriteoutBuffer(TString branchName);

    // private helper function to emit a warning
    void EmitMemoryBranchWrongTypeWarning(const char* brname, const char* typen1, const char* typen2) const;

    /**private Members*/
    Int_t fOldEntryNr;
    /**folder structure of output*/
    TFolder* fOutFolder;
    /**folder structure of input*/
    TFolder* fRootFolder;
    /** current time in ns*/
    Double_t fCurrentTime;
    TObject** fObj2;   //!
    /** Counter for the number of branches activiated */
    Int_t fNObj;   //!
    /** A list which hold the pointer to the branch
     * and the name of the branch in memory, it contains all branches (TClonesArrays)
     * persistance and Memory only branches
     */
    std::map<TString, TObject*> fMap;   //!

    /**folder name variable*/
    static std::string fFolderName;   //!
    /**tree name variable*/
    static std::string fTreeName;   //!
    static std::string GetNameFromFile(const char* namekind);

    /// A map of branchnames to typeinformation + memory address;
    /// used for branches registered with RegisterAny; use of ptr here
    /// since type_info cannot be copied
    std::map<std::string, std::unique_ptr<TypeAddressPair const>> fAnyBranchMap;   //!

    /**Branch id for this run */
    Int_t fBranchSeqId;
    /**List of branch names as TObjString*/
    TList* fBranchNameList;   //!

    /**The branch ID for the special (required) MCTrack branch**/
    Int_t fMCTrackBranchId;   //!

    /**List of Time based branchs names as TObjString*/
    TList* fTimeBasedBranchNameList;   //!
    /** Internally used to compress empty slots in data buffer*/
    std::map<TString, TClonesArray*> fActiveContainer;
    /** Internally used to read time ordered data from branches*/
    std::map<TString, FairTSBufferFunctional*> fTSBufferMap;     //!
    std::map<TString, FairWriteoutBuffer*> fWriteoutBufferMap;   //!
    std::map<Int_t, TBranch*> fInputBranchMap;                   //!    //Map of input branch ID with TBranch pointer
    /**Flag for creation of Map for branch persistency list  */
    Bool_t fBranchPerMap;
    /** Map for branch persistency list */
    std::map<TString, Int_t> fBrPerMap;   //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t fCurrentEntryNo;   //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t fTimeforEntryNo;   //!
    Bool_t fFillLastData;     //!
    Int_t fEntryNr;           //!

    TObjArray* fListFolder;   //!

    FairSource* fSource;

    TChain* fSourceChain = nullptr;
    std::map<UInt_t, TChain*> fSignalChainList;   //!

    FairEventHeader* fEventHeader;

    FairSink* fSink;

    Bool_t fUseFairLinks;   //!
    Bool_t fFinishRun;      //!
    /** List of branches used with no-time stamp in time-based session */
    TRefArray fListOfNonTimebasedBranches{};   //!

    /**private Members for multi-threading */
    // global static data members
    static Int_t fgCounter;   // The counter of instances
    // data members
    Int_t fId;   // This manager ID

    ClassDefOverride(FairRootManager, 14);
};

// FIXME: move to source since we can make it non-template dependent
template<typename T>
void FairRootManager::AddMemoryBranchAny(const char* brname, T** obj)
{
    if (fAnyBranchMap.find(brname) == fAnyBranchMap.end()) {
        auto& ot = typeid(T*);
        auto& pt = typeid(T);
        fAnyBranchMap[brname] = std::unique_ptr<TypeAddressPair const>(new TypeAddressPair(ot, pt, (void*)obj));
    }
}

// try to retrieve an object address from the registered branches/names
template<typename T>
T FairRootManager::GetMemoryBranchAny(const char* brname) const
{
    static_assert(std::is_pointer<T>::value, "Return type of GetMemoryBranchAny has to be a pointer");
    using P = typename std::remove_pointer<T>::type;
    auto iter = fAnyBranchMap.find(brname);
    if (iter != fAnyBranchMap.end()) {
        // verify type consistency
        if (typeid(P).hash_code() != iter->second->origtypeinfo.hash_code()) {
            EmitMemoryBranchWrongTypeWarning(brname, typeid(P).name(), iter->second->origtypeinfo.name());
            return nullptr;
        }
        return static_cast<T>(iter->second->ptraddr);
    }
    return nullptr;
}

template<typename T>
void FairRootManager::RegisterAny(const char* brname, T*& obj, bool persistence)
{
    AddBranchToList(brname);
    // we are taking the address of the passed pointer
    AddMemoryBranchAny<T>(brname, &obj);
    if (persistence) {
        auto& ot = typeid(T*);
        auto& pt = typeid(T);
        if (fSink)
            fSink->RegisterAny(brname, ot, pt, &obj);
        else
            LOG(fatal) << "The sink does not exist to store persistent branches.";
    }
}

// this function serves as a factory (or lookup) for memory managed
// instances associated to branches
// it returns a pointer to unmodifiable instance of T
template<typename TPtr>
TPtr FairRootManager::InitObjectAs(const char* brname)
{
    static_assert(std::is_pointer<TPtr>::value, "Return type of GetObjectAs has to be a pointer");
    using X = typename std::remove_pointer<TPtr>::type;
    static_assert(std::is_const<X>::value, "Return type of GetObjectAs has to be pointer to const class");
    using T = typename std::remove_const<X>::type;

    // is there already an object associated to the branch in memory??
    // then just return
    T** obj = GetMemoryBranchAny<T**>(brname);
    // obj is some address/instance holding TPtr instances
    if (obj != nullptr)
        return *obj;

    if (!fSource) {
        return nullptr;
    }

    // it does not seem to be the case, let us create the pointer which will be initialized
    // with the data (pointer to T)
    T** addr = new T*;
    // init the pointee to a default obj which we can return
    (*addr) = new T;
    // try to find and activate in the source
    auto succeeded = fSource->ActivateObjectAny((void**)addr, typeid(T), brname);

    if (!succeeded) {
        delete (*addr);
        delete addr;
        return nullptr;
    }
    // add into branch list
    AddMemoryBranchAny<T>(brname, addr);

    // NOTE: ideally we would do proper resource management for addr and *addr
    // since the FairRootManager becomes owner of these pointers/instances; Unfortunately this
    // is quite a difficult task since we would have to store something like std::unique_ptr<T> in a member
    // container which we cannot know a priori; Some solutions we could think of in the future are
    // a) use the Destructor mechanism of ROOT::TClass since we still have the type info.
    // b) investigate if boost::any could be of help here
    // In any case, this problem is not very critical in the sense that FairRootManager is a singleton and hence
    // cannot really leak memory (Assuming that the destructors of T are not doing something non-trivial).
    return *addr;
}

#endif   // FAIR_ROOT_MANAGER_H
/********************************************************************************
 * Copyright (C) 2014-2023 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUN_H
#define FAIRRUN_H

#include "FairAlignmentHandler.h"
#include "FairEventHeader.h"
#include "FairSink.h"
#include "FairSource.h"

#include <Rtypes.h>   // for Int_t, Bool_t, etc
#include <TMCtls.h>   // for multi-threading
#include <TNamed.h>   // for TNamed
#include <TString.h>
#include <map>
#include <memory>
#include <string>

class FairEventHeader;
class FairFileHeader;
class FairRootManager;
class FairRuntimeDb;
class FairSink;
class FairTask;
class TFile;
class FairField;
class TGeoHMatrix;

/**
 * Configure the Simuation or Analysis
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairRun : public TNamed
{
    friend class FairMCApplication;

  public:
    /**
     * default ctor
     */
    FairRun(Bool_t isMaster = kTRUE);
    /**
     * default dtor
     */
    ~FairRun() override;
    /**
     * static instance
     */
    static FairRun* Instance();
    /**
     * Add a FAIRTask to the simulation or analysis
     */
    virtual void AddTask(FairTask* t);
    virtual void StoreTaskNames(const FairTask* t);
    virtual void SetTask(FairTask* t);
    /**
     * Initialize the Simulation or analysis
     */
    virtual void Init() = 0;
    /*
     * Get the magnetic field *
     */
    virtual FairField* GetField() = 0;
    /**
     * run the analysis or simulation
     */
    virtual void Run(Int_t NStart = 0, Int_t NStop = 0) = 0;
    /**
     *       Set the experiment dependent run header
     *       for each run
     */
    void SetEventHeader(FairEventHeader* EvHeader) { fEvtHeader = EvHeader; }
    /**
     * return a pointer to the RuntimeDB
     */
    FairRuntimeDb* GetRuntimeDb() { return fRtdb; }
    /**
     * Set the sink
     */
    void SetSink(std::unique_ptr<FairSink> newsink);
    void SetSink(FairSink* tempSink);
    /**
     * return a non-owning pointer to the sink
     */
    FairSink* GetSink() { return fSink.get(); }
    /**
     * return the run ID for the actul run
     */
    Int_t GetRunId() { return (static_cast<Int_t>(fRunId)); }

    /**
     * Set the Run ID
     */
    void SetRunId(UInt_t runId) { fRunId = runId; }

    /**Get the detector specific run header*/
    FairEventHeader* GetEventHeader();
    /**
     * return true for Anaylsis session
     */
    Bool_t IsAna() { return fAna; }
    /**
     *Get task by name
     */

    FairTask* GetTask(const char* taskName);
    /**
     *Get Main Task
     */
    FairTask* GetMainTask() { return fTask; }
    /**
     * Return the number of Tasks added to this Run
     */
    Int_t GetNTasks() { return fNTasks; }

    /**Create a new file and save the TGeoManager to it*/
    void CreateGeometryFile(const char* geofile);

    /**
     * Set if RunInfo file should be written
     * \deprecated Use SetGenerateRunInfo() instead.
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] void SetWriteRunInfoFile(Bool_t write);

    //** Set if RunInfo should be generated */
    void SetGenerateRunInfo(Bool_t write) { fGenerateRunInfo = write; }

    /**
     * Get info if RunInfo file is written
     * \deprecated Use \ref IsRunInfoGenerated() instead.
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] Bool_t GetWriteRunInfoFile();

    //** Get info if RunInfo file is written */
    Bool_t IsRunInfoGenerated() { return fGenerateRunInfo; }

    //** Switches the use of FairLinks */
    void SetUseFairLinks(Bool_t val);

    //** Get info if run on master */
    Bool_t GetIsMaster() const { return fIsMaster; }

    //** Mark/Unmark event to be filled into output. Default is TRUE. */
    void MarkFill(Bool_t flag) { fMarkFill = flag; }

    //** Get option string */
    TString GetOptions() { return fOptions; };

    //** Set option string */
    void SetOptions(const TString& s) { fOptions = s; };

    /**
     * Set the output file name for analysis or simulation
     * \deprecated Use \ref FairSink and \ref SetSink().
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] virtual void SetOutputFile(const char* fname);
    /**
     * Set the output file for analysis or simulation
     * \deprecated Use \ref FairSink and \ref SetSink().
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] virtual void SetOutputFile(TFile* f);
    /**
     * Set the  output file name without creating the file
     * \deprecated Use \ref FairSink and \ref SetSink().
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] void SetOutputFileName(const TString& name);
    /**
     * \deprecated Use \ref FairSink and \ref SetSink().
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] TFile* GetOutputFile();

    /**
     * New functions which allow to postpone creating a new Sink in MT
     * to be kept after clean-up of deprecated functions above
     */
    void SetUserOutputFileName(const TString& name);
    TString GetUserOutputFileName() const;

    void AddAlignmentMatrices(const std::map<std::string, TGeoHMatrix>& alignmentMatrices, bool invertMatrices = false);

    /**
     * \brief Set the input signal file
     *
     * Takes an owning pointer!
     */
    virtual void SetSource(FairSource* tempSource);
    /** Return non-owning pointer to source **/
    FairSource* GetSource() { return fSource.get(); }
    FairRootManager& GetRootManager() { return *fRootManager; }
    FairRootManager const& GetRootManager() const { return *fRootManager; }

  private:
    FairRun(const FairRun& M);
    FairRun& operator=(const FairRun&) { return *this; }
    /** Number of Tasks added*/
    Int_t fNTasks;

  protected:
    /** static pointer to this run*/
    static TMCThreadLocal FairRun* fRunInstance;
    /** RuntimeDb*/
    FairRuntimeDb* fRtdb;
    /** Tasks used*/
    FairTask* fTask;
    /**IO manager */
    FairRootManager* fRootManager;
    /**Output sink*/
    std::unique_ptr<FairSink> fSink{};   //!
    /**Output file name set by user*/
    TString fUserOutputFileName;
    /**Options for derived classes, to be set & parsed by user*/
    TString fOptions;
    /**Run Id*/
    UInt_t fRunId;   //!
    /** true for Anaylsis session*/
    Bool_t fAna;   //!
    /** MC Event Header */
    FairEventHeader* fEvtHeader;   //!
    /** File  Header */
    FairFileHeader* fFileHeader;
    /** true if RunInfo file should be written*/
    Bool_t fGenerateRunInfo;   //!
    /** true if on master*/
    Bool_t fIsMaster;   //!

    Bool_t fMarkFill;   //!

    FairAlignmentHandler fAlignmentHandler;

    std::unique_ptr<FairSource> fSource{};   //!

    void AlignGeometry() const;
    /**
     * Call FillEventHeader on the source
     */
    void FillEventHeader()
    {
        if (fSource)
            fSource->FillEventHeader(fEvtHeader);
    }

    /**
     * Get the RunId of the Event Header
     */
    UInt_t GetEvtHeaderRunId() const { return fEvtHeader->GetRunId(); }

    ClassDefOverride(FairRun, 5);
};
#endif   // FAIRRUN_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANA_H
#define FAIRRUNANA_H

/**
 * Configure and manage the  Analysis
 * @author M. Al-Turany D. Bertini
 * @version 0.1
 * @since 28.02.05
 */

#include "FairRootManager.h"   // for FairRootManager
#include "FairRun.h"           // for FairRun
#include "FairRunInfo.h"       // for FairRunInfo

#include <Rtypes.h>    // for Bool_t, Double_t, UInt_t, etc
#include <TString.h>   // for TString

class FairField;
class TF1;
class TFile;

class FairSource;
class FairFileSource;
class FairMixedSource;

class FairRunAna : public FairRun
{

  public:
    static FairRunAna* Instance();
    virtual ~FairRunAna();
    FairRunAna();
    /**initialize the run manager*/
    void Init() override;
    /**Run from event number NStart to event number NStop */
    void Run(Int_t NStart = 0, Int_t NStop = 0) override;
    /**Run over the whole input file with timpe window delta_t as unit (entry)*/
    void Run(Double_t delta_t);
    /**Run for the given single entry*/
    void Run(Long64_t entry);
    /**Run event reconstruction from event number NStart to event number NStop */
    void RunEventReco(Int_t NStart, Int_t NStop);
    /**Run over all TSBuffers until the data is processed*/
    void RunTSBuffers();
    /** the dummy run does not check the evt header or the parameters!! */
    void DummyRun(Int_t NStart, Int_t NStop);
    /** This methode is only needed and used with ZeroMQ
     * it read a certain event and call the task exec, but no output is written
     * @param entry : entry number in the tree
     */
    void RunMQ(Long64_t entry);
    /** Run on a list of lmd files*/
    void RunOnLmdFiles(UInt_t NStart = 0, UInt_t NStop = 0);

    void RunOnTBData();
    /** finish tasks, write output*/
    void TerminateRun();

    /** Switch On/Off the storing of FairEventHeader in output file*/
    void SetEventHeaderPersistence(Bool_t flag) { fStoreEventHeader = flag; }

    void Reinit(UInt_t runId);
    UInt_t getRunId() { return fRunId; }
    /** Get the magnetic field **/
    FairField* GetField() override { return fField; }
    /** Set the magnetic Field */
    void SetField(FairField* ffield) { fField = ffield; }
    /** Set external geometry file */
    void SetGeomFile(const char* GeoFileName);
    /** Return a pointer to the geometry file */
    TFile* GetGeoFile() { return fInputGeoFile; }
    /** Initialization of parameter container is set to static, i.e: the run id is
     *  is not checked anymore after initialization
     */

    void SetContainerStatic(Bool_t tempBool = kTRUE);
    Bool_t GetContainerStatic() { return fStatic; };
    void RunWithTimeStamps();
    Bool_t IsTimeStamp() { return fTimeStamps; }

    /** Set the flag for proccessing lmd files */
    void StopProcessingLMD(void) { fFinishProcessingLMDFile = kTRUE; }
    /** Get the status of lmd file proccessing */
    Bool_t GetLMDProcessingStatus(void) { return fFinishProcessingLMDFile; }

  protected:
    /**
     * Virtual function which calls the Fill function of the IOManager.
     * Allows to override the function with an experiment specific version.
     **/
    virtual void Fill();

  private:
    FairRunAna(const FairRunAna& M);
    FairRunAna& operator=(const FairRunAna&) { return *this; }

    FairRunInfo fRunInfo;   //!

  protected:
    /** This variable became true after Init is called*/
    Bool_t fIsInitialized;
    TFile* fInputGeoFile;
    static FairRunAna* fgRinstance;
    Bool_t fLoadGeo;
    /** true for static initialisation of parameters */
    Bool_t fStatic;   //!
    FairField* fField;
    Bool_t fTimeStamps;
    Bool_t fInFileIsOpen;   //!
    /** min time for one event (ns) */
    Double_t fEventTimeMin;   //!
    /** max time for one Event (ns) */
    Double_t fEventTimeMax;   //!
    /** Time of event since th start (ns) */
    Double_t fEventTime;   //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t fEventMeanTime;   //!
    /** used to generate random numbers for event time; */
    TF1* fTimeProb;   //!
    /** Flag for proccessing lmd-files*/
    Bool_t fFinishProcessingLMDFile;   //!

    /** Temporary member to preserve old functionality without setting source in macro */
    FairFileSource* fFileSource;   //!
    /** Temporary member to preserve old functionality without setting source in macro */
    FairMixedSource* fMixedSource;   //!
    /** Flag for Event Header Persistency */
    Bool_t fStoreEventHeader;   //!

    ClassDefOverride(FairRunAna, 6);
};

#endif   // FAIRRUNANA_H
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNSIM_H
#define FAIRRUNSIM_H

#include "FairGenericVMCConfig.h"
#include "FairIon.h"             // for FairIon
#include "FairMCApplication.h"   // for FairMCApplication
#include "FairParticle.h"        // for FairParticle
#include "FairRun.h"             // for FairRun

#include <Rtypes.h>      // for Bool_t, Double_t, Int_t, etc
#include <TMCtls.h>      // for multi-threading
#include <TObjArray.h>   // for TObjArray
#include <TString.h>     // for TString
#include <functional>
#include <memory>
#include <utility>

class FairField;
class FairMCEventHeader;
class FairMesh;
class FairModule;
class FairPrimaryGenerator;

/**
 * \brief Configure the Simulation session
 * \ingroup base_steer
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairRunSim : public FairRun
{
  public:
    /** default ctor*/
    FairRunSim(Bool_t isMaster = kTRUE);
    /** default dtor*/
    ~FairRunSim() override;
    /** Singelton instance*/
    static FairRunSim* Instance();
    /**
     *       Add a module to the simulation (e.g. PIPE, Magnet, ..etc)
     */
    void AddModule(FairModule* Mod);
    /**
     *       Add a user defined ion to the simulation
     */
    void AddNewIon(FairIon* ion) { fIons->Add(ion); }
    /**
     *       Add a user defined ion to the simulation
     */
    void AddNewParticle(FairParticle* Particle) { fParticles->Add(Particle); }
    /**
     *       this method is used by the FAIRMCApplication
     */
    TObjArray* GetUserDefIons();
    /**
     *       this method is used by the FAIRMCApplication
     */
    TObjArray* GetUserDefParticles();

    /**
     *       Initialize the Simulation
     */
    void Init() override;
    /**
     *       run the  simulation
     */
    void Run(Int_t NEvents = 0, Int_t NotUsed = 0) override;
    /**
     *       Set the magnetic that has to be used for simulation field
     */
    void SetField(FairField* field);
    /**
     *       Set the event generator that has to be used for simulation field
     */
    void SetGenerator(FairPrimaryGenerator* Gen);

    /**
     *       Set the experiment dependent event header
     *       for each Monte Carlo Event
     */
    void SetMCEventHeader(FairMCEventHeader* McHeader) { fMCEvHead = McHeader; }

    /** Set the material file name to be used */
    void SetMaterials(const char* MatFileName);

    /**switch On/Off the track visualisation */
    void SetStoreTraj(Bool_t storeTraj = kTRUE) { fStoreTraj = storeTraj; }

    /**Return the switch for the track visualisation */
    Bool_t GetStoreTraj() const { return fStoreTraj; }

    /**switch On/Off the debug mode */
    void SetTrackingDebugMode(Bool_t set)
    {
        if (fApp) {
            fApp->SetTrackingDebugMode(set);
        }
    }

    /**Set geometry builder*/
    void SetGeoModel(const char* name);

    /**return the geometry loader used in this session*/
    TString* GetGeoModel() { return &fLoaderName; }

    /**Get the field used in simulation*/
    FairField* GetField() override { return fField; }

    /**Get the detector specific event header*/
    FairMCEventHeader* GetMCEventHeader();

    /**return the full list of modules used in simulation*/
    TObjArray* GetListOfModules() { return ListOfModules; }

    /**Get the used primary generator*/
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    FairPrimaryGenerator* GetPrimaryGenerator() { return fGen; }
#pragma GCC diagnostic pop

    /**switch On/Off external decayer (Pythia) */
    void SetPythiaDecayer(Bool_t decayer) { fPythiaDecayer = decayer; }

    /**switch On external decayer (Pythia). Config macro will be used */
    void SetPythiaDecayer(const TString& Config);

    /**switch On user defined decay, Config  macro will be called  */
    void SetUserDecay(const TString& Config);

    /**switch On/Off user defined decay if true gconfig/UserDecay.C macro will be called  */
    void SetUserDecay(Bool_t decay) { fUserDecay = decay; }

    /**Flag for external decayer*/
    Bool_t IsExtDecayer() { return fPythiaDecayer; }

    /**Flag for User decay*/
    Bool_t IsUserDecay() { return fUserDecay; }

    /**Switch on/off Radiation length register */
    void SetRadLenRegister(Bool_t value) { fRadLength = value; }

    void SetRadMapRegister(Bool_t value) { fRadMap = value; }

    void SetRadGridRegister(Bool_t value) { fRadGrid = value; }

    void AddMesh(FairMesh* Mesh);

    void SetUserConfig(const TString& Config) { fUserConfig = Config; }
    TString GetUserConfig() { return fUserConfig; }

    void SetUserCuts(const TString& Cuts) { fUserCuts = Cuts; }
    TString GetUserCuts() { return fUserCuts; }

    /** Set Beam energy in GeV/c */
    void SetBeamMom(Double_t BeamMom)
    {
        fBeamMom = BeamMom;
        fUseBeamMom = kTRUE;
    }

    /** Get the Beam energy */
    Double_t GetBeamMom() { return fBeamMom; }

    /**Get beam energy flag */
    Bool_t UseBeamMom() { return fUseBeamMom; }
    void SetFieldContainer();

    void SetSimSetup(std::function<void()> f)
    {
        fSimSetup = f;
        fUseSimSetupFunction = true;
    }
    void SetSimSetupPostInit(std::function<void()> f)
    {
        fSimSetupPostInit = f;
        fUseSimSetupPostInitFunction = true;
    }

    void SetSimulationConfig(std::unique_ptr<FairGenericVMCConfig> tconf) { fSimulationConfig = std::move(tconf); }
    /**
     * Get non-owning pointer
     */
    FairGenericVMCConfig* GetSimulationConfig() { return fSimulationConfig.get(); }

    void SetIsMT(Bool_t isMT) { fIsMT = isMT; }
    Bool_t IsMT() const { return fIsMT; }

    void SetImportTGeoToVMC(Bool_t v) { fImportTGeoToVMC = v; }
    Bool_t IsImportTGeoToVMC() const { return fImportTGeoToVMC; }

    void StopMCRun() { fApp->StopMCRun(); }

    /**
     * Get non-owning pointer to FairMCApplication
     */
    auto GetMCApplication() { return fApp; }

  private:
    FairRunSim(const FairRunSim& M);
    FairRunSim& operator=(const FairRunSim&) { return *this; }
    void SetMCConfig();
    void CheckFlukaExec();

  protected:
    Int_t count{0};                     //!< Internal counter
    FairMCApplication* fApp{nullptr};   //!< Main VMC application
    Double_t fBeamMom{0};               //!< Beam Energy in GeV/c
    Bool_t fUseBeamMom{kFALSE};         //!< flag for use Beam Energy
    /**
     * Primary Event Generator
     *
     * \deprecated Use \ref GetPrimaryGenerator() / \ref SetGenerator()
     * \deprecated Deprecated in v18.8, will be removed in v19.2.
     */
    [[deprecated("Use Setter/Getter")]] FairPrimaryGenerator* fGen{nullptr};   //!

    FairMCEventHeader* fMCEvHead;                   //!                          /** MC Event Header */
    static TMCThreadLocal FairRunSim* fginstance;   //!              /** Singleton Instance */
    FairField* fField;                              /** Magnetic Field */
    TObjArray* fIons;                               //!                              /** Array of user defined ions */
    TObjArray* fParticles;                          //!                         /** Array of user defined particles*/
    TObjArray* ListOfModules;                       //!                       /** Array of used modules */
    TString MatFname;                               //!                           /** Material file name */
    Bool_t fStoreTraj;                              //!                       /** Trajectory store flags */
    TString fLoaderName{"TGeo"};                    //!< Geometry Model (TGeo or G3)
    Bool_t fPythiaDecayer;                          //!                    /** flag for using Pythia decayer*/
    TString fPythiaDecayerConfig;                   //!               /** Macro for Pythia decay configuration*/
    Bool_t fUserDecay;                              /** flag for setting user decay */
    TString fUserDecayConfig;                       //!                   /** Macro for decay configuration*/
    Bool_t fRadLength;                              //!                       /** flag for registring radiation length*/
    Bool_t fRadMap;                                 //!                            /** flag for RadiationMapManager
    Bool_t fRadGrid;                                //!
    TObjArray* fMeshList;                           //!                          /** radiation grid scoring
    TString fUserConfig;                            //!                        /** Macro for geant configuration*/
    TString fUserCuts;                              //!                          /** Macro for geant cuts*/
    Bool_t fIsMT;                                   //!                              /** MT mode option (Geant4 only)*/
    Bool_t fImportTGeoToVMC;                        //!                   /** Allow importing TGeometry to VMC */
    std::function<void()> fSimSetup;   //!                          /** A user provided function to do sim setup /
                                       //!                          instead of using macros **/
    bool fUseSimSetupFunction = false;
    std::function<void()> fSimSetupPostInit;   //!                          /** A user provided function to do sim setup
                                               //!                          / instead of using macros **/
    bool fUseSimSetupPostInitFunction = false;
    std::unique_ptr<FairGenericVMCConfig> fSimulationConfig{};   //!                 /** Simulation configuration */

    ClassDefOverride(FairRunSim, 2);
};

#endif   // FAIRRUNSIM_H
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairTask header file                      -----
// -----          Created 12/01/04  by M. Al-Turany / D. Bertini       -----
// -------------------------------------------------------------------------

/** FairTask
 * @author M. Al-Turany, Denis Bertini
 * @since 12.01.04
 **
 ** Base class for tasks in the cbmroot framework.
 ** Derived classes should implement the Exec method.
 **/

#ifndef FAIRTASK_H
#define FAIRTASK_H

#include <Rtypes.h>    // for Int_t, FairTask::Class, etc
#include <TString.h>   // for TString
#include <TTask.h>     // for TTask
#include <map>

class FairLogger;

enum InitStatus
{
    kSUCCESS,
    kERROR,
    kFATAL
};

/**
 * \ingroup base_steer
 */
class FairTask : public TTask
{
  public:
    /** Default constructor **/
    FairTask();

    /** Standard constructor
     *@param name        Name of task
     *@param iVerbose    Verbosity level
     **/
    FairTask(const char* name, Int_t iVerbose = 1);

    FairTask(const FairTask&) = delete;
    FairTask& operator=(const FairTask&) = delete;
    FairTask(FairTask&&) = delete;
    FairTask& operator=(FairTask&&) = delete;

    /** Destructor **/
    ~FairTask() override;

    /** Initialisation at begin of run. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void InitTask();

    /** Reinitialisation. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void ReInitTask();

    /** Set parameters. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void SetParTask();

    /** Action at end of run. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    virtual void FinishTask();

    /** Action at end of event. For this task and all of the subtasks. **/
    virtual void FinishEvent();

    /** Set verbosity level. For this task and all of the subtasks. **/
    void SetVerbose(Int_t iVerbose);

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] void SetInputPersistance(Bool_t val) { fInputPersistance = val; }
#pragma GCC diagnostic pop

    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] void CheckInputPersistance(TString branchName);

    void ExecuteTask(Option_t* option = "0") override;   // *MENU*

    /** Set persistency of branch with given name true or false
     *  In case is is set to false the branch will not be written to the output.
     **/
    void SetOutputBranchPersistent(TString, Bool_t);

    /** Check if the branch with the given name is persistent.
     *  If the branch is not in the map, the default return value is true.
     **/
    Bool_t IsOutputBranchPersistent(TString);

    void SetStreamProcessing(Bool_t val = kTRUE) { fStreamProcessing = val; }

  protected:
    Int_t fVerbose;                           //  Verbosity level
    [[deprecated]] Int_t fInputPersistance;   ///< \deprecated Deprecated in v18.8, will be removed in v20.
    FairLogger* fLogger;                      //!
    Bool_t fStreamProcessing;

    /** Intialisation at begin of run. To be implemented in the derived class.
     * \retval  kSUCCESS   If not kSUCCESS, task will be set inactive.
     **/
    virtual InitStatus Init() { return kSUCCESS; };

    /** Reinitialisation. To be implemented in the derived class.
     * \retval  kSUCCESS   If not kSUCCESS, task will be set inactive.
     **/
    virtual InitStatus ReInit() { return kSUCCESS; };

    /** Intialise parameter containers.
        To be implemented in the derived class.
    **/
    virtual void SetParContainers(){};

    /** Action at end of run. For this task and all of the subtasks.
        To be implemented in the derived class.
    **/
    virtual void Finish(){};

    /** Recursive intialisation of subtasks at begin of run **/
    void InitTasks();

    /** Recursive reinitialisation of subtasks **/
    void ReInitTasks();

    void ExecuteTasks(Option_t* option) override;

    /** Recursive parameter initialisation for subtasks **/
    void SetParTasks();

    /** Recursive finish of subtasks **/
    void FinishTasks();

    /** Recursive FinishEvent of subtasks **/
    void FinishEvents();

  private:
    std::map<TString, Bool_t> fOutputPersistance;

    ClassDefOverride(FairTask, 4);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// ********************************************* //
// ***        D. Kresan   2004-Sep-14        *** //
// ***        D.Kresan@gsi.de                *** //
// ********************************************* //

#ifndef FAIR_TRAJ_FILTER_H
#define FAIR_TRAJ_FILTER_H 1

#include <Rtypes.h>      // for Double_t, Bool_t, Int_t, etc
#include <TGeoTrack.h>   // IWYU pragma: keep needed by cint // TODO: is this still relevant for CINT?
#include <TMCtls.h>      // for multi-threading
#include <TMath.h>       // for Pi, TwoPi
#include <TString.h>     // for TString

class TClonesArray;
class TParticle;

/**
 * @class FairTrajFilter
 * The filter for storing of the trajectories.
 * This singleton class controls storing of trajectories
 * in the gGeoManager list during the simulation.
 * It is created, if FairRun::SetStoreTraj(kTRUE) was called
 * in the run macro
 * before the initialisation. The cuts should be applied
 * after initialisation and before run via
 * FairTrajFilter::Instance()->Set...Cut(...) methods.
 * Three modes of momentum cut (phase space, polar and decart reference systems),
 * are self-excluded. The last that was set, is applied in the simulation.
 * All other cuts are combined together.
 * @author D. Kresan
 * @version 0.1
 * @since 2004-Sep-15
 */

class FairTrajFilter
{
  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairTrajFilter class.
     * The pointer to this object can be reached via FairTrajFilter::Instance().
     */
    FairTrajFilter();

    /**
     * Destructor.
     */
    virtual ~FairTrajFilter();

    /**
     * Class definition.
     */
    ClassDef(FairTrajFilter, 1);

  private:
    FairTrajFilter(const FairTrajFilter&);
    FairTrajFilter& operator=(const FairTrajFilter&);

    static TMCThreadLocal FairTrajFilter* fgInstance;

    Double_t fVxMin;
    Double_t fVxMax;
    Double_t fVyMin;
    Double_t fVyMax;
    Double_t fVzMin;
    Double_t fVzMax;

    Double_t fPMin;
    Double_t fPMax;
    Double_t fThetaMin;
    Double_t fThetaMax;
    Double_t fPhiMin;
    Double_t fPhiMax;

    Double_t fPxMin;
    Double_t fPxMax;
    Double_t fPyMin;
    Double_t fPyMax;
    Double_t fPzMin;
    Double_t fPzMax;

    Double_t fPtMin;
    Double_t fPtMax;
    Double_t fRapidityMin;
    Double_t fRapidityMax;

    Int_t fKinCutType;

    Double_t fEtotMin;
    Double_t fEtotMax;

    Bool_t fStorePrim;
    Bool_t fStoreSec;

    Double_t fStepSizeMin;

    /**
     * collection of tracks
     */
    TClonesArray* fTrackCollection;

    TGeoTrack* fCurrentTrk;

  public:
    TGeoTrack* AddTrack(Int_t trackId, Int_t pdgCode);
    TGeoTrack* AddTrack(TParticle* p);
    TGeoTrack* CheckAddTrack(Int_t trackId, TParticle* p);
    TGeoTrack* GetCurrentTrk() { return fCurrentTrk; }

    void Init(TString brName = "GeoTracks", TString folderName = "MCGeoTrack");
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairTrajFilter object, created
     * with FairTrajFilter::FairTrajFilter().
     */
    static FairTrajFilter* Instance();

    /**
     * This function applies all availible cuts on different variables.
     * @param p - pointer to the TParticle object.
     * @return kTRUE - if particle survives the cuts. Otherwise - kFALSE.
     */
    Bool_t IsAccepted(const TParticle* p) const;

    /**
     * This function enables the vertex cut.
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param Box in coordinate space. Only trajectories, created inside this box
     * will be stored. Default values - the cave dimensions.
     */
    void SetVertexCut(Double_t vxMin = -2000.,
                      Double_t vyMin = -2000.,
                      Double_t vzMin = -2000.,
                      Double_t vxMax = 2000.,
                      Double_t vyMax = 2000.,
                      Double_t vzMax = 2000.);

    /**
     * This function enables the momentum cut (polar reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (polar reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutP(Double_t pMin = 0.,
                         Double_t thetaMin = 0.,
                         Double_t phiMin = 0.,
                         Double_t pMax = 1e10,
                         Double_t thetaMax = TMath::Pi(),
                         Double_t phiMax = TMath::TwoPi());

    /**
     * This function enables the momentum cut (decart reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (decart reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutD(Double_t pxMin = -1e10,
                         Double_t pyMin = -1e10,
                         Double_t pzMin = -1e10,
                         Double_t pxMax = 1e10,
                         Double_t pyMax = 1e10,
                         Double_t pzMax = 1e10);

    /**
     * This function enables the cut in phase space (pt-rapidity).
     * @param The region in phase space (pt-rapidity). Only particles
     * inside this region will be stored.
     * Default values - whole pt-rapidity range.
     */
    void SetPtRapidityCut(Double_t ptMin = 0.,
                          Double_t ptMax = 1e10,
                          Double_t rapidityMin = -1e10,
                          Double_t rapidityMax = 1e10);

    /**
     * This function enables the cut on total energy.
     * @param Total energy range. Only particles with total energy value
     * inside this range will be stored. Deafult values - whole energy range.
     */
    void SetEnergyCut(Double_t etotMin = 0., Double_t etotMax = 1e10);

    /**
     * This function controls the storing of primaries.
     * @param storePrim - boolean flag to control the storing of primaries.
     */
    inline void SetStorePrimaries(Bool_t storePrim = kTRUE) { fStorePrim = storePrim; };

    /**
     * This function controls the storing of secondaries.
     * @param storeSec - boolean flag to control the storing of secondaries.
     */
    inline void SetStoreSecondaries(Bool_t storeSec = kTRUE) { fStoreSec = storeSec; };

    /**
     * This function controls the process of adding the points to the trajectory.
     * @param stepSizeMin - minimum value of step size, wich will be added to
     * the trajectory.
     */
    void SetStepSizeCut(Double_t stepSizeMin = 0.);

    /**
     * This is the getter for the vertex cut.
     * @param References to the variables where return values should be stored.
     */
    void GetVertexCut(Double_t& vxMin,
                      Double_t& vyMin,
                      Double_t& vzMin,
                      Double_t& vxMax,
                      Double_t& vyMax,
                      Double_t& vzMax) const;

    /**
     * This is the getter for the momentum cut (polar reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutP(Double_t& pMin,
                         Double_t& thetaMin,
                         Double_t& phiMin,
                         Double_t& pMax,
                         Double_t& thetaMax,
                         Double_t& phiMax) const;

    /**
     * This is the getter for the momentum cut (decart reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutD(Double_t& pxMin,
                         Double_t& pyMin,
                         Double_t& pzMin,
                         Double_t& pxMax,
                         Double_t& pyMax,
                         Double_t& pzMax) const;

    /**
     * This is the getter for the space phase cut.
     * @param References to the variables where return values should be stored.
     */
    void GetPtRapidityCut(Double_t& ptMin, Double_t& ptMax, Double_t& rapidityMin, Double_t& rapidityMax) const;

    /**
     * This is the getter for the total energy cut.
     * @param References to the variables where return values should be stored.
     */
    void GetEnergyCut(Double_t& etotMin, Double_t& etotMax) const;

    /**
     * This is the getter for flag of storing of primaries.
     * @return kTRUE if primaries should be stored.
     */
    inline Bool_t IsPrimariesStored() const { return fStorePrim; };

    /**
     * This is the getter for flag of storing of secondaries.
     * @return kTRUE if secondaries should be stored.
     */
    inline Bool_t IsSecondariesStored() const { return fStoreSec; };

    /**
     * This is the getter for the step size cut.
     * @return The minimum value of the step size wich still should be
     * added to the trajectory.
     */
    inline Double_t GetStepSizeCut() const { return fStepSizeMin; };

    TGeoTrack* GetTrack(Int_t trackId);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairTSBufferFunctionalFunctional_H_
#define FairTSBufferFunctionalFunctional_H_

#include "FairTimeStamp.h"   // for FairTimeStamp

#include <Rtypes.h>     // for Int_t, Bool_t, Double_t, etc
#include <TObject.h>    // for TObject
#include <TString.h>    // for TString
#include <functional>   // for binary_function
#include <iostream>     // for operator<<, basic_ostream, etc

class TBranch;
class TClonesArray;
class TTree;

/**
 * \class BinaryFunctor
 * \brief Base class for all functors which are used in the FairTSBufferFunctional
 * \see FairTSBufferFunctional
 *
 * The class is a base class to control which data is extracted by the FairTSBufferFunctional class for processing.
 * The important method to overwrite is Call. It gets the actual data which is read in from the tree and a parameter.
 * If the actual data is not anymore part of the data you want to have Call returns true to stop the reading of data.
 * Otherwise it should return false.
 * The method TimeOut is used to break the processing if for example always the same data is requested.
 */

class BinaryFunctor
{
  public:
    using first_argument_type = FairTimeStamp*;
    using second_argument_type = double;
    using result_type = bool;

    virtual bool operator()(FairTimeStamp* a, double b) { return Call(a, b); };
    virtual bool Call(FairTimeStamp* a, double b) = 0;
    virtual bool TimeOut() { return false; }
    virtual void ResetTimeOut(){};

    virtual ~BinaryFunctor(){};
};

/**
 * \class StopTime
 * Gives you all the data which is older than the given parameter StopTime.
 * It does not return the data requested before.
 */

class StopTime : public BinaryFunctor
{
  public:
    StopTime()
        : fRequestTime(-1)
        , fOldTime(-1)
        , fSameTimeRequestCounter(0){};

    /**
     * \parameter b: StopTime: All data older than StopTime is returned
     */
    bool Call(FairTimeStamp* a, double b) override
    {
        fRequestTime = b;
        // std::cout << "StopTime: " << a->GetTimeStamp() << " > " <<  b << std::endl;
        return a->GetTimeStamp() > b;
    };

    bool TimeOut() override
    {
        if (fRequestTime != fOldTime) {
            fOldTime = fRequestTime;
            fSameTimeRequestCounter = 0;
            // std::cout << "RequestedTime: " << fRequestTime << std::endl;
            return false;
        } else if (fRequestTime == fOldTime) {
            std::cout << "-I- FairTSBufferFunctional StopTime has requested the same data as before: " << fRequestTime
                      << std::endl;
            fSameTimeRequestCounter++;
        } else {
            std::cout << "-E- FairTSBufferFunctional StopTime Functor has requested time " << fRequestTime
                      << " smaller than old time " << fOldTime << std::endl;
            return true;
        }
        return fSameTimeRequestCounter > 9;
    }

    void ResetTimeOut() override { fSameTimeRequestCounter = 0; }

  private:
    double fRequestTime;
    double fOldTime;
    int fSameTimeRequestCounter;
};

/**
 * \class TimeGap
 * Returns you all the data between two time gaps of a given length.
 */

class TimeGap : public BinaryFunctor
{
  public:
    TimeGap()
        : fOldTime(-1.){};

    /**
     * \parameter b : TimeGap: All data between two time gaps which are larger than TimeGap are returned
     */
    bool Call(FairTimeStamp* a, double b) override
    {
        double aTime = a->GetTimeStamp();

        if (fOldTime < 0) {
            fOldTime = aTime;
            return false;
        }
        if (aTime - fOldTime > b) {
            fOldTime = aTime;
            return true;
        } else {
            fOldTime = aTime;
            return false;
        }
    };

  private:
    double fOldTime;
};

/**
 * \class FairTSBufferFunctional
 * \brief A class to access time ordered data in a root branch
 *
 * In the constructor of the class one has to give the branch name of the data, the tree the data is stored in
 * and a BinaryFunctor which contains the method how the data should be extracted. Several example functors already
 * exists. To extract the data one has to call GetData with a parameter which fits to the selected functor. GetData
 * returns a TClonesArray which contains the data.
 *
 *
 * Be careful! The buffer runs through the time ordered data in one time direction only. This means that you cannot
 * request data which is older than the data you have requested before.
 *
 * Addition: This is not true anymore. GetData(Double_t, Double_t) is able to get also data which is older but this only
 * works if you request a fixed time via StopTime functor. For other functors the behavior is unpredictable.
 *
 *  Created on: Feb 18, 201
 *      Author: stockman
 */

class FairTSBufferFunctional : public TObject
{
  public:
    FairTSBufferFunctional(TString branchName,
                           TTree* sourceTree,
                           BinaryFunctor* stopFunction,
                           BinaryFunctor* startFunction = 0);

    ~FairTSBufferFunctional() override {}
    TClonesArray* GetData(Double_t stopParameter);
    TClonesArray* GetData(Double_t startParameter, Double_t stopParameter);
    Int_t GetBranchIndex() { return fBranchIndex; }

    void SetBranchIndex(const Int_t val) { fBranchIndex = val; }
    void SetStartFunction(BinaryFunctor* function) { fStartFunction = function; }
    void SetStopFunction(BinaryFunctor* function) { fStopFunction = function; }
    Bool_t AllDataProcessed();
    void Terminate() { fTerminate = kTRUE; }

    Bool_t TimeOut()
    {
        Bool_t stopTimeOut = fStopFunction->TimeOut();
        Bool_t startTimeOut = kTRUE;
        if (fStartFunction != 0) {
            startTimeOut = fStartFunction->TimeOut();
            //        if (startTimeOut == kTRUE && stopTimeOut == kFALSE){
            //          fStartFunction->ResetTimeOut();
            //        }
            //        else if (startTimeOut == kFALSE && stopTimeOut == kTRUE){
            //          fStopFunction->ResetTimeOut();
            //        }
        }
        return (stopTimeOut && startTimeOut);
    }

    Int_t FindStartIndex(Double_t startParameter);

  private:
    void ReadInNextFilledEntry();
    Int_t ReadInPreviousFilledEntry(Int_t startEntry);
    void ReadInNextEntry();   //** used only if no function is given and input data is directly passed through to the
                              // OutputArray
    void ReadInEntry(Int_t number);
    void AbsorbDataBufferArray();   //< Absorbs the complete data from fInputArray to fBufferArray

    TClonesArray* fOutputArray;
    TClonesArray* fBufferArray;
    TClonesArray* fInputArray;

    BinaryFunctor* fStartFunction;
    BinaryFunctor* fStopFunction;

    TBranch* fBranch;
    Int_t fBranchIndex;

    Bool_t fTerminate;

    Int_t fVerbose;

    FairTSBufferFunctional(const FairTSBufferFunctional&);
    FairTSBufferFunctional& operator=(const FairTSBufferFunctional&);

    ClassDefOverride(FairTSBufferFunctional, 0);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * @class FairWriteoutBuffer
 *
 * @author Tobias Stockmanns
 * @brief A container class to store digi data during events
 *
 * The FairWriteoutBuffer class provides a container which handles the storage of data between
 * events. The data has to be given with an active time, the absolute time the data is active in the
 * detector and can influence the output of the data.
 * FillNewData is used to put new data into the container.
 * WriteOutData with a given actual time stores the data which has an active time older than the given time
 * in the corresponding TClonesArray of the FairRootManager.
 * At the end of the task WriteOutAllData has to be called to store the data which is still in the buffer.
 * If one adds data via FillNewData into the buffer which is already present in the buffer, Modify is called.
 * The standard behavior of Modify is that the new data is ignored to simulate pile-up. If a different behavior
 * is wanted one has to overwrite Modify in a derived class.
 *
 * The data which should be stored in the buffer has to be derived from FairTimeStamp.
 * It needs an operator< and a method equal if the same detector element is hit.
 *
 * To use this buffer one has to derive his own buffer class from FairWriteoutBuffer and overwrite the pure virtual
 * functions.
 */

#ifndef FairWriteoutBuffer_H_
#define FairWriteoutBuffer_H_

#include "FairLogger.h"        // for FairLogger
#include "FairRootManager.h"   // for FairRootManager
#include "FairTimeStamp.h"     // for FairTimeStamp

#include <Rtypes.h>         // for Bool_t, Int_t, etc
#include <TClonesArray.h>   // for TClonesArray
#include <TObject.h>        // for TObject
#include <TString.h>        // for TString
#include <iostream>         // for cout, ostream
#include <map>              // for multimap
#include <utility>          // for pair
#include <vector>           // for vector

class FairWriteoutBuffer : public TObject
{
  public:
    FairWriteoutBuffer()
        : TObject()
        , fStartTime_map()
        , fDeadTime_map()
        , fBranchName()
        , fClassName()
        , fTreeSave(false)
        , fActivateBuffering(kFALSE)
        , fVerbose(0)
        , fLogger(FairLogger::GetLogger()){};
    FairWriteoutBuffer(TString branchName, TString className, TString folderName, Bool_t persistance);
    ~FairWriteoutBuffer() override {}

    virtual void SaveDataToTree(Bool_t val = kTRUE)
    {
        fTreeSave = val;   ///< If SaveDataToTree is set the data is stored at the end of the buffering into the given
                           ///< TClonesArray.
    }
    virtual void ActivateBuffering(Bool_t val = kTRUE)
    {
        fActivateBuffering = val;   ///< fActivateBuffering has to be set to kTRUE to use the buffering. Otherwise the
                                    ///< data is directly stored in the given TClonesArray.
    }

    Bool_t IsBufferingActivated() { return fActivateBuffering; }

    /// Fills a pointer to a data object into the buffer. StartTime gives the time when the data can influence later
    /// data, activeTime gives the time how long the data can influence later data. Both time data has to be given as an
    /// absolute time!
    virtual void FillNewData(FairTimeStamp* data, double startTime, double activeTime);

    virtual Int_t GetNData() { return fDeadTime_map.size(); }
    virtual std::vector<FairTimeStamp*> GetRemoveOldData(double time);
    virtual std::vector<FairTimeStamp*> GetAllData();

    virtual void SetVerbose(Int_t val) { fVerbose = val; }

    virtual void DeleteOldData()
    {
        if (fBranchName.Length() > 0) {
            TClonesArray* myArray = FairRootManager::Instance()->GetTClonesArray(fBranchName);
            myArray->Delete();
        }
    }

    virtual void WriteOutData(double time);
    virtual void WriteOutAllData();

  protected:
    virtual void AddNewDataToTClonesArray(
        FairTimeStamp* data) = 0;   ///< store the data from the FairTimeStamp pointer in a TClonesArray (you have to
                                    ///< cast it to your type of data)
    virtual double FindTimeForData(
        FairTimeStamp* data) = 0;   ///< if the same data object (like a pad or a pixel) is already present in the
                                    ///< buffer, the time of this object has to be returned otherwise -1
    virtual void FillDataMap(FairTimeStamp* data, double activeTime) = 0;   ///< add a new element in the search buffer
    virtual void EraseDataFromDataMap(
        FairTimeStamp* data) = 0;   ///< delete the element from the search buffer (see PndSdsDigiPixelWriteoutBuffer)

    /// Modify defines the behavior of the buffer if data should be stored which is already in the buffer. Parameters
    /// are the old data with the active time, the new data with an active time. Modify returns than a vector with the
    /// new data which should be stored.
    virtual std::vector<std::pair<double, FairTimeStamp*>> Modify(std::pair<double, FairTimeStamp*> oldData,
                                                                  std::pair<double, FairTimeStamp*>)
    {
        std::vector<std::pair<double, FairTimeStamp*>> result;
        result.push_back(oldData);
        return result;
    }

    virtual void WriteOutDataDeadTimeMap(double time);
    virtual void MoveDataFromStartTimeMapToDeadTimeMap(double time);
    virtual void FillDataToDeadTimeMap(FairTimeStamp* data, double activeTime, double startTime);

    virtual void PrintData(FairTimeStamp* data)
    {
        std::cout << data->GetTimeStamp();
    };   ///< Method should be overwritten in derived classes to print the data of an object stored in the buffer
    virtual void PrintDeadTimeMap();
    virtual void PrintStartTimeMap();

    std::multimap<double, std::pair<double, FairTimeStamp*>> fStartTime_map;
    std::multimap<double, FairTimeStamp*> fDeadTime_map;

    TString fBranchName;
    TString fClassName;
    Bool_t fTreeSave;
    Bool_t fActivateBuffering;
    Int_t fVerbose;
    FairLogger* fLogger;   //! /// FairLogger

  private:
    FairWriteoutBuffer(const FairWriteoutBuffer&);
    FairWriteoutBuffer& operator=(const FairWriteoutBuffer&);

    ClassDefOverride(FairWriteoutBuffer, 1);
};

#endif /* FairWriteoutBuffer_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----            FairAnaSelector header file                        -----
// -----            Created 14/10/11  by R. Karabowicz                 -----
// -----            Updated 01/02/12  by R. Karabowicz                 -----
// -------------------------------------------------------------------------

#ifndef FAIRANASELECTOR_H
#define FAIRANASELECTOR_H

#include "FairLogger.h"   // for FairLogger, MESSAGE_ORIGIN

#include <Rtypes.h>          // for Int_t, Bool_t, etc
#include <TSelector.h>       // for TSelector
#include <TSelectorList.h>   // for TSelectorList
#include <TString.h>         // for TString
#include <TTree.h>           // for TTree

class FairFileSource;
class FairRunAnaProof;

class TFile;
class TList;
class TObject;
class TProofOutputFile;

class FairAnaSelector : public TSelector
{
  public:
    TProofOutputFile* fProofFile;
    TFile* fFile;
    TTree* fChain;   //! pointer to the analyzed TTree or TChain
    FairRunAnaProof* fRunAna;

    FairAnaSelector(TTree* /*tree*/ = 0)
        : fProofFile(0)
        , fFile(0)
        , fChain(0)
        , fRunAna(nullptr)
        , fProofSource(0)
        , fCurrentDirectory("")
    {}

    ~FairAnaSelector() override {}
    Int_t Version() const override { return 1; }
    void Begin(TTree* tree) override;
    void SlaveBegin(TTree* tree) override;
    void Init(TTree* tree) override;
    Bool_t Notify() override;
    Bool_t Process(Long64_t entry) override;
    Int_t GetEntry(Long64_t entry, Int_t getall = 0) override
    {
        return fChain ? fChain->GetTree()->GetEntry(entry, getall) : 0;
    }
    void SetOption(const char* option) override { fOption = option; }
    void SetObject(TObject* obj) override { fObject = obj; }
    void SetInputList(TList* input) override { fInput = input; }
    TList* GetOutputList() const override { return fOutput; }
    void SlaveTerminate() override;
    void Terminate() override;

    void SetFairRunAnaProof(FairRunAnaProof* runAna) { fRunAna = runAna; }

  private:
    FairAnaSelector(const FairAnaSelector&);
    FairAnaSelector operator=(const FairAnaSelector&);

    FairFileSource* fProofSource;

    TString fCurrentDirectory;

    ClassDefOverride(FairAnaSelector, 0);
};

#endif   // FAIRANASELECTOR_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANAPROOF_H
#define FAIRRUNANAPROOF_H

/**
 * Configure and manage the  Analysis on proof
 * @author R. Karabowicz
 * @version 0.1
 * @since 30.04.2013
 */

#include "FairFileSource.h"   // FairRunAnaProof can only accept FairFileSource as source
#include "FairRunAna.h"

#include <Rtypes.h>
#include <TProof.h>

class FairRunAnaProof : public FairRunAna
{
  public:
    /** \deprecated Deprecated in v18.8, will be removed in v20. */
    [[deprecated]] static FairRunAnaProof* Instance();
    virtual ~FairRunAnaProof();
    FairRunAnaProof(const char* proofName = "");

    /**initialize the run manager*/
    void Init() override;

    /** Init containers executed on PROOF, which is part of Init when running locally*/
    void InitContainers();

    /**Run from event number NStart to event number NStop */
    void Run(Int_t NStart = 0, Int_t NStop = 0) override;
    /**Run for one event, used on PROOF nodes*/
    void RunOneEvent(Long64_t entry);
    /**Run on proof from event NStart to event NStop*/
    void RunOnProof(Int_t NStart, Int_t NStop);

    /** set the input tree of fRootManager when running on PROOF worker*/
    /* void        SetInTree (TTree* tempTree)   { */
    /*   fRootManager->SetInTree (tempTree); */
    /* } */

    /** GetProof */
    TProof* GetProof() { return fProof; }

    /** To be set to kTRUE only when running on PROOF worker, only by TSelector */
    void SetRunOnProofWorker(Bool_t tb = kTRUE) { fRunOnProofWorker = tb; }
    /** Set PROOF ARchive (PAR) file name*/
    void SetProofParName(TString parName) { fProofParName = parName; }
    /** Set directory for storing output files*/
    void SetOutputDirectory(TString dirName) { fOutputDirectory = dirName; }
    /** Set PROOF output status, possibilities: "copy","merge"*/
    void SetProofOutputStatus(TString outStat) { fProofOutputStatus = outStat; }

    void SetSource(FairSource* tempSource) override;

  protected:
    static FairRunAnaProof* fRAPInstance;

    /** PROOF **/
    TProof* fProof;
    /** executing on PROOF worker*/
    Bool_t fRunOnProofWorker;   //!
    /** PROOF server name*/
    TString fProofServerName;   //!
    /** PROOF ARchive (PAR) file name*/
    TString fProofParName;   //!
    /** Output directory*/
    TString fOutputDirectory;   //!
    /** Output status indicator: "copy","merge","dataset"*/
    TString fProofOutputStatus;

  private:
    FairRunAnaProof(const FairRunAnaProof&);
    FairRunAnaProof operator=(const FairRunAnaProof&);

    FairFileSource* fProofFileSource;

    ClassDefOverride(FairRunAnaProof, 1);
};

#endif   // FAIRRUNANAPROOF_H

#undef  _BACKWARD_BACKWARD_WARNING_H

G__ParBase dictionary payload:664:34: error: base class has incomplete type
class FairParRootFileIo : public FairParIo
                          ~~~~~~~^~~~~~~~~
/home/physics/fair_install/FairRootInstall/include/FairParIo.h:19:7: note: definition of 'FairParIo' is not complete until the closing '}'
class FairParIo : public TObject
      ^
G__ParBase dictionary payload:677:18: error: only virtual member functions can be marked 'override'
    void close() override;
                 ^~~~~~~~
G__ParBase dictionary payload:678:18: error: only virtual member functions can be marked 'override'
    void print() override;
                 ^~~~~~~~
G__ParBase dictionary payload:680:37: error: only virtual member functions can be marked 'override'
    void readVersions(FairRtdbRun*) override;
                                    ^~~~~~~~
G__ParBase dictionary payload:682:20: error: only virtual member functions can be marked 'override'
    Bool_t check() override
                   ^~~~~~~~
G__ParBase dictionary payload:691:15: error: only virtual member functions can be marked 'override'
    void cd() override
              ^~~~~~~~
G__ParBase dictionary payload:708:5: error: only virtual member functions can be marked 'override'
    ClassDefOverride(FairParRootFileIo, 0);   // Parameter I/O from ROOT files
    ^
input_line_32:13:28: note: expanded from macro 'ClassDefOverride'
_ClassDefOutline_(name,id,,override)\
                           ^
G__ParBase dictionary payload:708:5: error: only virtual member functions can be marked 'override'
input_line_32:13:28: note: expanded from macro 'ClassDefOverride'
_ClassDefOutline_(name,id,,override)\
                           ^
G__ParBase dictionary payload:708:5: error: only virtual member functions can be marked 'override'
input_line_32:13:28: note: expanded from macro 'ClassDefOverride'
_ClassDefOutline_(name,id,,override)\
                           ^
G__ParBase dictionary payload:708:5: error: only virtual member functions can be marked 'override'
input_line_32:13:28: note: expanded from macro 'ClassDefOverride'
_ClassDefOutline_(name,id,,override)\
                           ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class FairParIo with content:

#line 1 "G__ParBase dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRCONTFACT_H
#define FAIRCONTFACT_H

#include <Rtypes.h>    // for Bool_t, ClassDef, etc
#include <TList.h>     // for TList
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString

class FairParIo;
class FairParSet;

class FairContainer : public TNamed
{
  private:
    FairContainer();
    FairContainer(const FairContainer&);
    FairContainer& operator=(const FairContainer&);

  protected:
    /** available contexts for this parameter container*/
    TList* contexts;
    /** actual context set by the user */
    TString actualContext;

  public:
    FairContainer(const char*, const char*, const char*);
    ~FairContainer() override;
    void addContext(const char*);
    Bool_t setActualContext(const char* c);
    const char* getDefaultContext();
    const char* getActualContext() const { return actualContext.Data(); }
    void print();
    TString getConcatName();
    const char* getContext();
    ClassDefOverride(FairContainer, 0);   // class for list elements in class FairContFact
};

class FairContFact : public TNamed
{
  public:
    FairContFact();
    FairContFact(const char* name, const char* title);
    ~FairContFact() override;
    Bool_t addContext(const char* name);
    void print();
    FairParSet* getContainer(const char*);
    virtual FairParSet* createContainer(FairContainer*) { return nullptr; }
    virtual void activateParIo(FairParIo*) {}
    /// @param[in] container Transfers ownership if return value is true
    Bool_t AddContainer(FairContainer*);

  protected:
    TList* containers{new TList};   // all parameter containers managed by this factory
    const char* getActualContext(const char* name)
    {
        return (static_cast<FairContainer*>(containers->FindObject(name)))->getActualContext();
    }
    ClassDefOverride(FairContFact, 0);   // base class of all factories for parameter containers

  private:
    FairContFact(const FairContFact&);
    FairContFact& operator=(const FairContFact&);
};

#endif /* !FAIRCONTFACT_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARASCIIFILEIO_H
#define FAIRDETPARASCIIFILEIO_H

#include "FairDetParIo.h"   // for FairDetParIo

#include <Rtypes.h>    // for Text_t, Bool_t, etc
#include <TString.h>   // for TString
#include <iosfwd>      // for fstream

class FairParSet;

class FairDetParAsciiFileIo : public FairDetParIo
{
  protected:
    TString fHeader;       //! header of container output in file
    TString sepLine;       //! comment line
    std::fstream* pFile;   //! pointer to ascii file
    Bool_t findContainer(const Text_t* name);
    Bool_t checkAllFound(Int_t*, Int_t);
    void writeHeader(const Text_t*,
                     const Text_t* context = "",
                     const Text_t* author = "",
                     const Text_t* description = "");
    void writeComment(FairParSet*);
    void readComment(const Char_t*, FairParSet*);

  public:
    FairDetParAsciiFileIo(std::fstream* f);
    virtual ~FairDetParAsciiFileIo() {}

  private:
    FairDetParAsciiFileIo& operator=(const FairDetParAsciiFileIo&);
    FairDetParAsciiFileIo(const FairDetParAsciiFileIo&);

    ClassDefOverride(FairDetParAsciiFileIo, 0);   // Class for detector parameter I/O from ascii file
};

#endif /* !FAIRDETPARASCIIFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARIO_H
#define FAIRDETPARIO_H

#include <Rtypes.h>   // for Int_t, FairDetParIo::Class, etc
#include <TNamed.h>   // for TNamed

class FairParSet;

class FairDetParIo : public TNamed
{
  protected:
    Int_t inputNumber;   // input number (first or second input in runtime database)

  public:
    FairDetParIo();
    virtual ~FairDetParIo() { ; }

    // sets the input number
    void setInputNumber(Int_t n) { inputNumber = n; }

    // returns the input number
    Int_t getInputNumber() { return inputNumber; }

    // initializes parameter container
    virtual Bool_t init(FairParSet*) { return kFALSE; }

    // writes parameter container to output
    virtual Int_t write(FairParSet*) { return kFALSE; }

    ClassDefOverride(FairDetParIo, 0);   // Base class for detector parameter IO
};

#endif /* !HDETPARIO_H */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARROOTFILEIO_H
#define FAIRDETPARROOTFILEIO_H

#include "FairDetParIo.h"   // for FairDetParIo

#include <Rtypes.h>   // for Int_t, Text_t, etc

class FairParRootFile;
class FairParSet;
class TObject;

class FairDetParRootFileIo : public FairDetParIo
{
  protected:
    FairParRootFile* pFile;   // pointer to parameter ROOT file

  public:
    FairDetParRootFileIo(FairParRootFile* f);
    virtual ~FairDetParRootFileIo() {}
    virtual Bool_t read(FairParSet*);
    Int_t write(FairParSet*) override;

  protected:
    Int_t findInputVersion(const char* contName);
    Int_t getMaxVersion(const char* contName);
    TObject* findContainer(Text_t* contName, Int_t version);

  private:
    FairDetParRootFileIo(const FairDetParRootFileIo&);
    FairDetParRootFileIo& operator=(const FairDetParRootFileIo&);

    ClassDefOverride(FairDetParRootFileIo, 0);   // detector base class for parameter I/O from ROOT file
};

#endif /* !FAIRDETPARROOTFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGENERICPARASCIIFILEIO_H
#define FAIRGENERICPARASCIIFILEIO_H

#include "FairDetParAsciiFileIo.h"   // for FairDetParAsciiFileIo

#include <Rtypes.h>   // for Int_t, Bool_t, etc
#include <iosfwd>     // for fstream

class FairParGenericSet;
class FairParSet;
class TString;

class FairGenericParAsciiFileIo : public FairDetParAsciiFileIo
{
  public:
    FairGenericParAsciiFileIo(std::fstream* f = 0);
    ~FairGenericParAsciiFileIo() {}
    Bool_t init(FairParSet*) override;
    Int_t write(FairParSet*) override;

  private:
    ClassDefOverride(FairGenericParAsciiFileIo,
                     0)   // I/O from Ascii file for parameter containers derived from FairParGenericSet
        Bool_t readGenericSet(FairParGenericSet* pPar);
    Int_t writeGenericSet(FairParGenericSet* pPar);

    template<class type>
    const UChar_t* readData(type, const Char_t*, TString&, Int_t&);
    template<class type>
    void writeData(type*, Int_t);
};

#endif /* !FAIRGENERICPARASCIIFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGENERICPARROOTFILEIO_H
#define FAIRGENERICPARROOTFILEIO_H

#include "FairDetParRootFileIo.h"   // for FairDetParRootFileIo

#include <Rtypes.h>   // for ClassDef macro

class FairParRootFile;
class FairParSet;

class FairGenericParRootFileIo : public FairDetParRootFileIo
{
  public:
    FairGenericParRootFileIo(FairParRootFile* f = 0);
    ~FairGenericParRootFileIo() {}
    Bool_t init(FairParSet*) override;
    ClassDefOverride(FairGenericParRootFileIo,
                     0)   // I/O from ROOT file for parameter containers derived from FairParGenericSet
};

#endif /* !FAIRGENERICPARROOTFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARAMLIST_H
#define FAIRPARAMLIST_H

#include <Rtypes.h>           // for Text_t, Int_t, Bool_t, etc
#include <TArrayC.h>          // for TArrayC
#include <TFile.h>            // for TFile
#include <THashTable.h>       // for THashTable
#include <TNamed.h>           // for TNamed
#include <TObject.h>          // for TObject
#include <TROOT.h>            // for TROOT, gROOT
#include <TSeqCollection.h>   // for TSeqCollection
#include <TString.h>          // for TString

class TArrayD;
class TArrayF;
class TArrayI;

class FairParamObj : public TNamed
{
  protected:
    UChar_t* paramValue;      // Pointer to binary array
    Int_t arraySize;          // Size of binary array
    TString paramType;        // Type of parameter value or class name
    Bool_t basicType;         // kTRUE for C-types and C-type parameter arrays, kFALSE for classes
    Int_t bytesPerValue;      // number of bytes per value
    Int_t classVersion;       // Code version of classes stored as binary
    UChar_t* streamerInfo;    // Pointer to binary array container the streamer info
    Int_t streamerInfoSize;   // Size of streamer info array

  public:
    FairParamObj(const Text_t* name = "");
    FairParamObj(FairParamObj&);
    FairParamObj(const Text_t*, Int_t);
    FairParamObj(const Text_t*, Bool_t);
    FairParamObj(const Text_t*, UInt_t);
    FairParamObj(const Text_t*, Float_t);
    FairParamObj(const Text_t*, Double_t);
    FairParamObj(const Text_t*, const Int_t*, const Int_t);
    FairParamObj(const Text_t*, const UInt_t*, const Int_t);
    FairParamObj(const Text_t*, const Float_t*, const Int_t);
    FairParamObj(const Text_t*, const Double_t*, const Int_t);
    FairParamObj(const Text_t*, const Text_t*);
    FairParamObj(const Text_t*, const Char_t*, const Int_t);
    FairParamObj(const Text_t*, const UChar_t*, const Int_t);
    ~FairParamObj();
    void setParamType(const Text_t* t);
    UChar_t* setLength(Int_t l);
    void setParamValue(UChar_t*, const Int_t);
    void setClassVersion(const Int_t v) { classVersion = v; }
    UChar_t* setStreamerInfoSize(Int_t);
    void setStreamerInfo(UChar_t*, const Int_t);
    UChar_t* getParamValue() { return paramValue; }
    Bool_t isBasicType() { return basicType; }
    const char* getParamType() { return paramType.Data(); }
    Int_t getBytesPerValue() { return bytesPerValue; }
    Int_t getClassVersion() { return classVersion; }
    Int_t getLength() { return arraySize; }
    Int_t getNumParams();
    UChar_t* getStreamerInfo() { return streamerInfo; }
    Int_t getStreamerInfoSize() { return streamerInfoSize; }
    void print();

  protected:
    template<class type>
    void printData(type*, Int_t);

  private:
    FairParamObj& operator=(const FairParamObj&);

    // Class for binary parameter object (name + binary array)
    ClassDefOverride(FairParamObj, 0);
};

class FairParamList : public TObject
{
  protected:
    THashTable paramList;   // List for parameters stored as string
    class FairParamTFile : public TFile
    {
      public:
        FairParamTFile()
        {
            // Create StreamerInfo index
            Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize() + 1;
            if (lenIndex < 5000) {
                lenIndex = 5000;
            }
            fClassIndex = new TArrayC(lenIndex);
        }
        ~FairParamTFile()
        {
            delete fClassIndex;
            fClassIndex = 0;
        }
    };

  public:
    FairParamList();
    ~FairParamList();
    void add(FairParamObj&);
    void add(const Text_t*, const Text_t*);
    void add(const Text_t*, Int_t);
    void add(const Text_t*, Bool_t);
    void add(const Text_t*, UInt_t);
    void add(const Text_t*, Float_t);
    void add(const Text_t*, Double_t);
    void add(const Text_t*, TArrayI&);
    void add(const Text_t*, TArrayC&);
    void add(const Text_t*, TArrayF&);
    void add(const Text_t*, TArrayD&);
    void add(const Text_t*, const UChar_t*, const Int_t);
    void add(const Text_t*, const Int_t*, const Int_t);
    void add(const Text_t*, const Float_t*, const Int_t);
    void add(const Text_t*, const Double_t*, const Int_t);
    void addObject(const Text_t*, TObject*);
    Bool_t fill(const Text_t*, Text_t*, const Int_t);
    Bool_t fill(const Text_t*, Int_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, Bool_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, UInt_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, Float_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, Double_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, UChar_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, TArrayI*);
    Bool_t fill(const Text_t*, TArrayC*);
    Bool_t fill(const Text_t*, TArrayF*);
    Bool_t fill(const Text_t*, TArrayD*);
    Bool_t fillObject(const Text_t*, TObject*);
    void print();
    FairParamObj* find(const Text_t* name) { return static_cast<FairParamObj*>(paramList.FindObject(name)); }
    THashTable* getList() { return &paramList; }

  private:
    FairParamList(const FairParamList&);
    FairParamList& operator=(const FairParamList&);

    // Class for lists of parameters (of type FairParamObj)
    ClassDefOverride(FairParamList, 4);
};

#endif /* !FAIRPARAMLIST_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARASCIFILEIIO_H
#define FAIRPARASCIFILEIIO_H

#include "FairParIo.h"   // for FairParIo

#include <Rtypes.h>   // for Bool_t, Text_t, etc
#include <fstream>    // for fstream, etc

class TList;

class FairParAsciiFileIo : public FairParIo
{
  protected:
    std::fstream* file;   // pointer to a file

  public:
    FairParAsciiFileIo();

    // default destructor closes an open file and deletes list of I/Os
    ~FairParAsciiFileIo();

    // opens file
    // if a file is already open, this file will be closed
    // activates detector I/Os
    Bool_t open(const Text_t* fname, const Text_t* status = "in");

    // concatenate files whose names are stored in the TList
    // TList holds list od TObjStrings
    // create file all.par in local working directory
    // calls open to open the generated file all.par
    Bool_t open(const TList* fnamelist, const Text_t* status = "in");

    // closes file
    void close() override;

    // returns kTRUE if file is open
    Bool_t check() override
    {
        if (file) {
            return (file->rdbuf()->is_open() == 1);
        } else {
            return kFALSE;
        }
    }

    // prints information about the file and the detector I/Os
    void print() override;

    std::fstream* getFile();

  private:
    FairParAsciiFileIo(const FairParAsciiFileIo&);
    FairParAsciiFileIo& operator=(const FairParAsciiFileIo&);

    ClassDefOverride(FairParAsciiFileIo, 0);   // Parameter I/O from ASCII files
};

#endif /* !FAIRPARASCIIFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARGENERICSET_H
#define FAIRPARGENERICSET_H

#include "FairParSet.h"   // for FairParSet

#include <Rtypes.h>   // for Bool_t, etc

class FairParIo;
class FairParamList;

class FairParGenericSet : public FairParSet
{
  public:
    FairParGenericSet(const char* name, const char* title, const char* context, Bool_t ownership = kFALSE)
        : FairParSet(name, title, context, ownership)
    {}
    virtual ~FairParGenericSet() {}
    virtual void putParams(FairParamList*) = 0;
    virtual Bool_t getParams(FairParamList*) = 0;
    virtual void printParams();

    Bool_t init(FairParIo* inp) override;
    Int_t write(FairParIo* output) override;

  protected:
    FairParGenericSet()
        : FairParSet()
    {}
    ClassDefOverride(FairParGenericSet, 1);   // Base class for generic-style parameter containers
};

#endif /* !FAIRPARGENERICSET_H */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARIO_H
#define FAIRPARIO_H

#include <Rtypes.h>    // for Bool_t, Text_t, etc
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString

class FairDetParIo;
class FairRtdbRun;
class TList;

class FairParIo : public TObject
{
  protected:
    TList* detParIoList;   // list of detector I/Os
    Bool_t autoWritable;   // flag indicating if automatic write is possible
    TString filename;

  public:
    FairParIo();
    virtual ~FairParIo();
    virtual FairDetParIo* getDetParIo(const Text_t*);
    virtual void setDetParIo(FairDetParIo*);
    virtual void removeDetParIo(Text_t*);
    void setInputNumber(Int_t);
    virtual void close() { ; }

    // returns the filename
    const char* getFilename() { return filename.Data(); }

    // creates input/output class for a special detector and stores pointer
    // used only for Oracle input/output
    // (code in  class OraIo)
    virtual void setDetParIo(Text_t*) { ; }

    // prints information about input/output
    virtual void print() { ; }

    // checks if the input/output is open
    virtual Bool_t check() { return kFALSE; }

    // reads versions of parameter containers for an event file
    virtual void readVersions(FairRtdbRun*) { ; }

    // sets global file pointer in ROOT if input/output is a ROOT-file
    // (code in FairParRootFileIo)
    virtual void cd() { ; }

    // set and get for flag autoWritable
    void setAutoWritable(Bool_t f = kTRUE) { autoWritable = f; }
    Bool_t isAutoWritable() const { return autoWritable; }

  private:
    FairParIo(const FairParIo&);
    FairParIo& operator=(const FairParIo&);

    ClassDefOverride(FairParIo, 0);   // Base class for all parameter I/Os
};

#endif /* !FAIRPARIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARROOTFILEIO_H
#define FAIRPARROOTFILEIO_H

#include "FairParIo.h"   // for FairParIo

#include <Rtypes.h>   // for Bool_t, Text_t, Int_t, etc
#include <TFile.h>    // for TFile
#include <TNamed.h>   // for TNamed
#include <fstream>
using std::fstream;

class FairRtdbRun;
class TKey;
class TList;

class FairParRootFile : public TNamed
{
  public:
    FairRtdbRun* run;   //! pointer to current run in ROOT file
    FairParRootFile(const Text_t* fname, Option_t* option = "READ", const Text_t* ftitle = "", Int_t compress = 1);
    FairParRootFile(TFile* f);
    ~FairParRootFile();
    FairRtdbRun* getRun() { return run; }
    void readVersions(FairRtdbRun*);

    Bool_t IsOpen() { return RootFile && (RootFile->IsOpen()); }
    void cd()
    {
        if (RootFile) {
            RootFile->cd();
        }
    }
    Bool_t IsWritable() { return RootFile && RootFile->IsWritable(); }

    TKey* GetKey(const Text_t* t)
    {
        if (RootFile) {
            return RootFile->GetKey(t);
        } else {
            return nullptr;
        }
    }
    TList* GetListOfKeys()
    {
        if (RootFile) {
            return RootFile->GetListOfKeys();
        } else {
            return nullptr;
        }
    }
    void Close()
    {
        if (RootFile) {
            RootFile->Close();
        }
    }

  protected:
    TFile* RootFile;

  private:
    FairParRootFile(const FairParRootFile&);
    FairParRootFile& operator=(const FairParRootFile&);

    ClassDefOverride(FairParRootFile, 0);   // ROOT file for Parameter I/O
};

class FairParRootFileIo : public FairParIo
{
  protected:
    FairParRootFile* file;   // pointer to ROOT file
    Bool_t fMerging;

  public:
    FairParRootFileIo();
    FairParRootFileIo(Bool_t merged);
    ~FairParRootFileIo();
    Bool_t open(const Text_t* fname, Option_t* option = "READ", const Text_t* ftitle = "", Int_t compress = 1);
    Bool_t open(const TList* fnamelist, Option_t* option = "READ", const Text_t* ftitle = "", Int_t compress = 1);
    static void MergeFiles(TFile* newParFile, const TList* fnamelist);
    void close() override;
    void print() override;
    FairParRootFile* getParRootFile();
    void readVersions(FairRtdbRun*) override;
    TList* getKeys();
    Bool_t check() override
    {
        // returns kTRUE if file is open
        if (file) {
            return file->IsOpen();
        } else {
            return kFALSE;
        }
    }
    void cd() override
    {
        // sets the global ROOT file pointer gFile
        if (file) {
            file->cd();
        }
    }
    /**
    Open an existing root file for IO
    */
    Bool_t open(TFile* f);
    void setMerging(Bool_t io) { fMerging = io; }

  private:
    FairParRootFileIo(const FairParRootFileIo&);
    FairParRootFileIo& operator=(const FairParRootFileIo&);

    ClassDefOverride(FairParRootFileIo, 0);   // Parameter I/O from ROOT files
};

#endif /* !FAIRPARROOTFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARSET_H
#define FAIRPARSET_H

#include <Rtypes.h>   // for Int_t, Bool_t, etc
#include <TObject.h>
#include <TString.h>   // for TString

class FairLogger;
class FairParIo;

class FairParSet : public TObject
{
  protected:
    TString fName;          //
    TString fTitle;         //
    TString detName;        //! name of the detector the container belongs to
    Int_t versions[3];      //! versions of container in the 2 possible inputs
    Bool_t status;          //! static flag
    Bool_t changed;         //! flag is kTRUE if parameters have changed
    Bool_t owned;           //! if flag is KTRUE FairDB has the par. class ownership
    TString paramContext;   // Context/purpose for parameters and conditions
    TString author;         // Author of parameters
    TString description;    // Description of parameters
    /** Fair Logger */
    FairLogger* fLogger;   //!

  public:
    FairParSet(const char* name = "", const char* title = "", const char* context = "", Bool_t owner = kFALSE);
    virtual ~FairParSet() {}

    const char* GetName() const override { return static_cast<const char*>(fName.Data()); }
    const char* GetTitle() const override { return static_cast<const char*>(fTitle.Data()); }

    virtual Bool_t init();
    virtual Bool_t init(FairParIo*) { return kFALSE; }
    virtual Int_t write();
    virtual Int_t write(FairParIo*) { return kFALSE; }
    virtual void clear() {}
    virtual void print();

    const char* getDetectorName() { return detName.Data(); }
    void resetInputVersions();

    void setInputVersion(Int_t v = -1, Int_t i = 0)
    {
        if (i >= 0 && i < 3) {
            versions[i] = v;
        }
    }
    Int_t getInputVersion(Int_t i)
    {
        if (i >= 0 && i < 3) {
            return versions[i];
        } else {
            return 0;
        }
    }

    void setStatic(Bool_t flag = kTRUE) { status = flag; }
    Bool_t isStatic() { return status; }

    void setOwnership(Bool_t flag = kTRUE) { owned = flag; }
    Bool_t isOwned() { return owned; }

    void setChanged(Bool_t flag = kTRUE) { changed = flag; }
    Bool_t hasChanged() { return changed; }

    const char* getParamContext() const { return paramContext.Data(); }

    void setAuthor(const char* s) { author = s; }
    const char* getAuthor() const { return author.Data(); }

    void setDescription(const char* s) { description = s; }
    const char* getDescription() const { return description.Data(); }

    void copyComment(FairParSet& r)
    {
        author = r.getAuthor();
        description = r.getDescription();
    }

    // TODO These two methods are not used in FairRoot at all.
    // They probably should be marked deprecated (or final, or = delete)
    // and later removed.
    virtual void fill(UInt_t){};
    virtual void store(UInt_t){};

    FairParSet& operator=(const FairParSet&);
    FairParSet(const FairParSet&);

    ClassDefOverride(FairParSet, 2);   // Base class for all parameter containers
};

#endif /* !FAIRPARSET_H */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRTDBRUN_H
#define FAIRRTDBRUN_H

#include <Rtypes.h>    // for Int_t, Text_t, UInt_t, etc
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString
#include <iosfwd>      // for fstream
#include <stdio.h>     // for sprintf, sscanf

class TList;
using std::fstream;

class FairParVersion : public TNamed
{
  protected:
    Int_t inputVersions[3];   //! version of the parameter container in the 2 possible inputs
    Int_t rootVersion;        // version of the parameter container in the ROOT output file

  public:
    FairParVersion()
        : TNamed()
        , rootVersion(0)
    {}
    FairParVersion(const char* name);
    ~FairParVersion() {}
    void setInputVersion(Int_t v = -1, Int_t i = 0)
    {
        if (i >= 0 && i < 3) {
            inputVersions[i] = v;
        }
    }
    Int_t getInputVersion(Int_t i) const
    {
        if (i >= 0 && i < 3) {
            return inputVersions[i];
        } else {
            return -1;
        }
    }
    void resetInputVersions()
    {
        for (Int_t i = 0; i < 3; i++) {
            inputVersions[i] = -1;
        }
    }
    void setRootVersion(Int_t v) { rootVersion = v; }
    Int_t getRootVersion() const { return rootVersion; }
    ClassDefOverride(FairParVersion, 1);   // Class for parameter versions
};

class FairRtdbRun : public TNamed
{
  protected:
    TList* parVersions;   // List of container names with the versions
    TString refRun;       //! name of the reference run for initialization

  public:
    FairRtdbRun();
    FairRtdbRun(const Text_t* name, const Text_t* refName = "");
    FairRtdbRun(Int_t r, Int_t rr = -1);
    FairRtdbRun(FairRtdbRun& run);
    ~FairRtdbRun();
    inline UInt_t getRunId(void);
    void addParVersion(FairParVersion* pv);
    FairParVersion* getParVersion(const Text_t* name);
    TList* getParVersions() { return parVersions; }
    const Text_t* getRefRun() { return refRun.Data(); }
    void setRefRun(Text_t* s) { refRun = s; }
    inline void setRefRun(Int_t r);
    void resetInputVersions();
    void resetOutputVersions();
    void print();
    void write(std::fstream&);

  private:
    FairRtdbRun& operator=(const FairRtdbRun&);

    ClassDefOverride(FairRtdbRun, 1);   // Class for parameter version management of a run
};

// -------------------- inlines ---------------------------

inline UInt_t FairRtdbRun::getRunId(void)
{
    UInt_t r;
    sscanf(GetName(), "%i", &r);
    return r;
}

inline void FairRtdbRun::setRefRun(Int_t r)
{
    if (r == -1) {
        refRun = "";
    } else {
        char name[255];
        sprintf(name, "%i", r);
        refRun = name;
    }
}

#endif /* !FAIRRTDBRUN_H */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNTIMEDB_H
#define FAIRRUNTIMEDB_H

#include <Rtypes.h>    // for Bool_t, Int_t, Text_t, etc
#include <TList.h>     // for TList
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString

class FairContFact;
class FairLogger;
class FairParIo;
class FairParSet;
class FairRtdbRun;

static TList contFactories;   //! list of container factories

/**
 * \ingroup parbase
 *
 * See Also: \ref parbase_runtimedb
 */
class FairRuntimeDb : public TObject
{
  private:
    static FairRuntimeDb* gRtdb;   //!

  protected:
    FairRuntimeDb(void);
    TList* containerList;      // list of parameter containers
    TList* runs;               // list of runs
    FairParIo* firstInput;     // first (prefered) input for parameters
    FairParIo* secondInput;    // second input (used if not found in first input)
    FairParIo* output;         // output for parameters
    FairRtdbRun* currentRun;   // Current run
    TString currentFileName;   // Name of current event file
    Bool_t versionsChanged;    // flag for write of list of runs (set kTRUE by each write)
    Bool_t isRootFileOutput;   // flag indicating that the output is a ROOT file
    /** Fair Logger */
    FairLogger* fLogger;   //!

    /**
     * Select which IO type to use.
     */
    typedef enum
    {
        UNKNOWN_Type = 0,
        AsciiFileOutput = 1,   // Ascii in-out-put
        RootFileOutput = 2,    // Root Files
        RootTSQLOutput = 3     // Use a TSQL db
    } ParamIOType;
    ParamIOType ioType;   // IO Type

  public:
    static FairRuntimeDb* instance(void);
    ~FairRuntimeDb() override;

    Bool_t addParamContext(const char*);
    void printParamContexts();
    void addContFactory(FairContFact*);
    void removeContFactory(FairContFact* fact);
    FairContFact* getContFactory(const Text_t*);

    Bool_t addContainer(FairParSet*);
    FairParSet* getContainer(const Text_t*);
    FairParSet* findContainer(const char*);
    void removeContainer(const char*);
    void removeAllContainers();
    Bool_t initContainers(UInt_t runId, Int_t refId = -1, const Text_t* fileName = "");
    void setContainersStatic(Bool_t f = kTRUE);
    Bool_t writeContainers(void);
    Bool_t writeContainer(FairParSet*, FairRtdbRun*, FairRtdbRun* refRun = 0);

    FairRtdbRun* addRun(Int_t runId, Int_t refId = -1);
    FairRtdbRun* getRun(Int_t);
    FairRtdbRun* getRun(const char*);
    FairRtdbRun* getCurrentRun(void) { return currentRun; }
    Text_t const* getCurrentFileName() { return currentFileName.Data(); }
    void clearRunList(void);

    void removeRun(Text_t*);

    Bool_t setInputVersion(Int_t run, Text_t* container, Int_t version, Int_t inputNumber);
    Bool_t setRootOutputVersion(Int_t run, Text_t* container, Int_t version);
    void setVersionsChanged(Bool_t f = kTRUE) { versionsChanged = f; }
    void resetInputVersions(void);
    void resetOutputVersions(void);
    void resetAllVersions(void);

    Bool_t readAll(void);
    void writeVersions(void);
    void saveOutput(void);

    Bool_t setFirstInput(FairParIo*);
    Bool_t setSecondInput(FairParIo*);
    Bool_t setOutput(FairParIo*);
    FairParIo* getFirstInput(void);
    FairParIo* getSecondInput(void);
    FairParIo* getOutput(void);
    void closeFirstInput(void);
    void closeSecondInput(void);
    void closeOutput(void);
    void activateParIo(FairParIo*);
    TList* getListOfContainers() { return containerList; }
    void print(void);

    Int_t findOutputVersion(FairParSet*);

  private:
    FairRuntimeDb(const FairRuntimeDb& M);
    FairRuntimeDb& operator=(const FairRuntimeDb&) { return *this; }
    Bool_t initContainers(void);

    ClassDefOverride(FairRuntimeDb, 0);   // Class for runtime database
};

#endif /* !FAIRRUNTIMEDB_H */

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class FairParAsciiFileIo with content:

#line 1 "G__ParBase dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRCONTFACT_H
#define FAIRCONTFACT_H

#include <Rtypes.h>    // for Bool_t, ClassDef, etc
#include <TList.h>     // for TList
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString

class FairParIo;
class FairParSet;

class FairContainer : public TNamed
{
  private:
    FairContainer();
    FairContainer(const FairContainer&);
    FairContainer& operator=(const FairContainer&);

  protected:
    /** available contexts for this parameter container*/
    TList* contexts;
    /** actual context set by the user */
    TString actualContext;

  public:
    FairContainer(const char*, const char*, const char*);
    ~FairContainer() override;
    void addContext(const char*);
    Bool_t setActualContext(const char* c);
    const char* getDefaultContext();
    const char* getActualContext() const { return actualContext.Data(); }
    void print();
    TString getConcatName();
    const char* getContext();
    ClassDefOverride(FairContainer, 0);   // class for list elements in class FairContFact
};

class FairContFact : public TNamed
{
  public:
    FairContFact();
    FairContFact(const char* name, const char* title);
    ~FairContFact() override;
    Bool_t addContext(const char* name);
    void print();
    FairParSet* getContainer(const char*);
    virtual FairParSet* createContainer(FairContainer*) { return nullptr; }
    virtual void activateParIo(FairParIo*) {}
    /// @param[in] container Transfers ownership if return value is true
    Bool_t AddContainer(FairContainer*);

  protected:
    TList* containers{new TList};   // all parameter containers managed by this factory
    const char* getActualContext(const char* name)
    {
        return (static_cast<FairContainer*>(containers->FindObject(name)))->getActualContext();
    }
    ClassDefOverride(FairContFact, 0);   // base class of all factories for parameter containers

  private:
    FairContFact(const FairContFact&);
    FairContFact& operator=(const FairContFact&);
};

#endif /* !FAIRCONTFACT_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARASCIIFILEIO_H
#define FAIRDETPARASCIIFILEIO_H

#include "FairDetParIo.h"   // for FairDetParIo

#include <Rtypes.h>    // for Text_t, Bool_t, etc
#include <TString.h>   // for TString
#include <iosfwd>      // for fstream

class FairParSet;

class FairDetParAsciiFileIo : public FairDetParIo
{
  protected:
    TString fHeader;       //! header of container output in file
    TString sepLine;       //! comment line
    std::fstream* pFile;   //! pointer to ascii file
    Bool_t findContainer(const Text_t* name);
    Bool_t checkAllFound(Int_t*, Int_t);
    void writeHeader(const Text_t*,
                     const Text_t* context = "",
                     const Text_t* author = "",
                     const Text_t* description = "");
    void writeComment(FairParSet*);
    void readComment(const Char_t*, FairParSet*);

  public:
    FairDetParAsciiFileIo(std::fstream* f);
    virtual ~FairDetParAsciiFileIo() {}

  private:
    FairDetParAsciiFileIo& operator=(const FairDetParAsciiFileIo&);
    FairDetParAsciiFileIo(const FairDetParAsciiFileIo&);

    ClassDefOverride(FairDetParAsciiFileIo, 0);   // Class for detector parameter I/O from ascii file
};

#endif /* !FAIRDETPARASCIIFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARIO_H
#define FAIRDETPARIO_H

#include <Rtypes.h>   // for Int_t, FairDetParIo::Class, etc
#include <TNamed.h>   // for TNamed

class FairParSet;

class FairDetParIo : public TNamed
{
  protected:
    Int_t inputNumber;   // input number (first or second input in runtime database)

  public:
    FairDetParIo();
    virtual ~FairDetParIo() { ; }

    // sets the input number
    void setInputNumber(Int_t n) { inputNumber = n; }

    // returns the input number
    Int_t getInputNumber() { return inputNumber; }

    // initializes parameter container
    virtual Bool_t init(FairParSet*) { return kFALSE; }

    // writes parameter container to output
    virtual Int_t write(FairParSet*) { return kFALSE; }

    ClassDefOverride(FairDetParIo, 0);   // Base class for detector parameter IO
};

#endif /* !HDETPARIO_H */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARROOTFILEIO_H
#define FAIRDETPARROOTFILEIO_H

#include "FairDetParIo.h"   // for FairDetParIo

#include <Rtypes.h>   // for Int_t, Text_t, etc

class FairParRootFile;
class FairParSet;
class TObject;

class FairDetParRootFileIo : public FairDetParIo
{
  protected:
    FairParRootFile* pFile;   // pointer to parameter ROOT file

  public:
    FairDetParRootFileIo(FairParRootFile* f);
    virtual ~FairDetParRootFileIo() {}
    virtual Bool_t read(FairParSet*);
    Int_t write(FairParSet*) override;

  protected:
    Int_t findInputVersion(const char* contName);
    Int_t getMaxVersion(const char* contName);
    TObject* findContainer(Text_t* contName, Int_t version);

  private:
    FairDetParRootFileIo(const FairDetParRootFileIo&);
    FairDetParRootFileIo& operator=(const FairDetParRootFileIo&);

    ClassDefOverride(FairDetParRootFileIo, 0);   // detector base class for parameter I/O from ROOT file
};

#endif /* !FAIRDETPARROOTFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGENERICPARASCIIFILEIO_H
#define FAIRGENERICPARASCIIFILEIO_H

#include "FairDetParAsciiFileIo.h"   // for FairDetParAsciiFileIo

#include <Rtypes.h>   // for Int_t, Bool_t, etc
#include <iosfwd>     // for fstream

class FairParGenericSet;
class FairParSet;
class TString;

class FairGenericParAsciiFileIo : public FairDetParAsciiFileIo
{
  public:
    FairGenericParAsciiFileIo(std::fstream* f = 0);
    ~FairGenericParAsciiFileIo() {}
    Bool_t init(FairParSet*) override;
    Int_t write(FairParSet*) override;

  private:
    ClassDefOverride(FairGenericParAsciiFileIo,
                     0)   // I/O from Ascii file for parameter containers derived from FairParGenericSet
        Bool_t readGenericSet(FairParGenericSet* pPar);
    Int_t writeGenericSet(FairParGenericSet* pPar);

    template<class type>
    const UChar_t* readData(type, const Char_t*, TString&, Int_t&);
    template<class type>
    void writeData(type*, Int_t);
};

#endif /* !FAIRGENERICPARASCIIFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGENERICPARROOTFILEIO_H
#define FAIRGENERICPARROOTFILEIO_H

#include "FairDetParRootFileIo.h"   // for FairDetParRootFileIo

#include <Rtypes.h>   // for ClassDef macro

class FairParRootFile;
class FairParSet;

class FairGenericParRootFileIo : public FairDetParRootFileIo
{
  public:
    FairGenericParRootFileIo(FairParRootFile* f = 0);
    ~FairGenericParRootFileIo() {}
    Bool_t init(FairParSet*) override;
    ClassDefOverride(FairGenericParRootFileIo,
                     0)   // I/O from ROOT file for parameter containers derived from FairParGenericSet
};

#endif /* !FAIRGENERICPARROOTFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARAMLIST_H
#define FAIRPARAMLIST_H

#include <Rtypes.h>           // for Text_t, Int_t, Bool_t, etc
#include <TArrayC.h>          // for TArrayC
#include <TFile.h>            // for TFile
#include <THashTable.h>       // for THashTable
#include <TNamed.h>           // for TNamed
#include <TObject.h>          // for TObject
#include <TROOT.h>            // for TROOT, gROOT
#include <TSeqCollection.h>   // for TSeqCollection
#include <TString.h>          // for TString

class TArrayD;
class TArrayF;
class TArrayI;

class FairParamObj : public TNamed
{
  protected:
    UChar_t* paramValue;      // Pointer to binary array
    Int_t arraySize;          // Size of binary array
    TString paramType;        // Type of parameter value or class name
    Bool_t basicType;         // kTRUE for C-types and C-type parameter arrays, kFALSE for classes
    Int_t bytesPerValue;      // number of bytes per value
    Int_t classVersion;       // Code version of classes stored as binary
    UChar_t* streamerInfo;    // Pointer to binary array container the streamer info
    Int_t streamerInfoSize;   // Size of streamer info array

  public:
    FairParamObj(const Text_t* name = "");
    FairParamObj(FairParamObj&);
    FairParamObj(const Text_t*, Int_t);
    FairParamObj(const Text_t*, Bool_t);
    FairParamObj(const Text_t*, UInt_t);
    FairParamObj(const Text_t*, Float_t);
    FairParamObj(const Text_t*, Double_t);
    FairParamObj(const Text_t*, const Int_t*, const Int_t);
    FairParamObj(const Text_t*, const UInt_t*, const Int_t);
    FairParamObj(const Text_t*, const Float_t*, const Int_t);
    FairParamObj(const Text_t*, const Double_t*, const Int_t);
    FairParamObj(const Text_t*, const Text_t*);
    FairParamObj(const Text_t*, const Char_t*, const Int_t);
    FairParamObj(const Text_t*, const UChar_t*, const Int_t);
    ~FairParamObj();
    void setParamType(const Text_t* t);
    UChar_t* setLength(Int_t l);
    void setParamValue(UChar_t*, const Int_t);
    void setClassVersion(const Int_t v) { classVersion = v; }
    UChar_t* setStreamerInfoSize(Int_t);
    void setStreamerInfo(UChar_t*, const Int_t);
    UChar_t* getParamValue() { return paramValue; }
    Bool_t isBasicType() { return basicType; }
    const char* getParamType() { return paramType.Data(); }
    Int_t getBytesPerValue() { return bytesPerValue; }
    Int_t getClassVersion() { return classVersion; }
    Int_t getLength() { return arraySize; }
    Int_t getNumParams();
    UChar_t* getStreamerInfo() { return streamerInfo; }
    Int_t getStreamerInfoSize() { return streamerInfoSize; }
    void print();

  protected:
    template<class type>
    void printData(type*, Int_t);

  private:
    FairParamObj& operator=(const FairParamObj&);

    // Class for binary parameter object (name + binary array)
    ClassDefOverride(FairParamObj, 0);
};

class FairParamList : public TObject
{
  protected:
    THashTable paramList;   // List for parameters stored as string
    class FairParamTFile : public TFile
    {
      public:
        FairParamTFile()
        {
            // Create StreamerInfo index
            Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize() + 1;
            if (lenIndex < 5000) {
                lenIndex = 5000;
            }
            fClassIndex = new TArrayC(lenIndex);
        }
        ~FairParamTFile()
        {
            delete fClassIndex;
            fClassIndex = 0;
        }
    };

  public:
    FairParamList();
    ~FairParamList();
    void add(FairParamObj&);
    void add(const Text_t*, const Text_t*);
    void add(const Text_t*, Int_t);
    void add(const Text_t*, Bool_t);
    void add(const Text_t*, UInt_t);
    void add(const Text_t*, Float_t);
    void add(const Text_t*, Double_t);
    void add(const Text_t*, TArrayI&);
    void add(const Text_t*, TArrayC&);
    void add(const Text_t*, TArrayF&);
    void add(const Text_t*, TArrayD&);
    void add(const Text_t*, const UChar_t*, const Int_t);
    void add(const Text_t*, const Int_t*, const Int_t);
    void add(const Text_t*, const Float_t*, const Int_t);
    void add(const Text_t*, const Double_t*, const Int_t);
    void addObject(const Text_t*, TObject*);
    Bool_t fill(const Text_t*, Text_t*, const Int_t);
    Bool_t fill(const Text_t*, Int_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, Bool_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, UInt_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, Float_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, Double_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, UChar_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, TArrayI*);
    Bool_t fill(const Text_t*, TArrayC*);
    Bool_t fill(const Text_t*, TArrayF*);
    Bool_t fill(const Text_t*, TArrayD*);
    Bool_t fillObject(const Text_t*, TObject*);
    void print();
    FairParamObj* find(const Text_t* name) { return static_cast<FairParamObj*>(paramList.FindObject(name)); }
    THashTable* getList() { return &paramList; }

  private:
    FairParamList(const FairParamList&);
    FairParamList& operator=(const FairParamList&);

    // Class for lists of parameters (of type FairParamObj)
    ClassDefOverride(FairParamList, 4);
};

#endif /* !FAIRPARAMLIST_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARASCIFILEIIO_H
#define FAIRPARASCIFILEIIO_H

#include "FairParIo.h"   // for FairParIo

#include <Rtypes.h>   // for Bool_t, Text_t, etc
#include <fstream>    // for fstream, etc

class TList;

class FairParAsciiFileIo : public FairParIo
{
  protected:
    std::fstream* file;   // pointer to a file

  public:
    FairParAsciiFileIo();

    // default destructor closes an open file and deletes list of I/Os
    ~FairParAsciiFileIo();

    // opens file
    // if a file is already open, this file will be closed
    // activates detector I/Os
    Bool_t open(const Text_t* fname, const Text_t* status = "in");

    // concatenate files whose names are stored in the TList
    // TList holds list od TObjStrings
    // create file all.par in local working directory
    // calls open to open the generated file all.par
    Bool_t open(const TList* fnamelist, const Text_t* status = "in");

    // closes file
    void close() override;

    // returns kTRUE if file is open
    Bool_t check() override
    {
        if (file) {
            return (file->rdbuf()->is_open() == 1);
        } else {
            return kFALSE;
        }
    }

    // prints information about the file and the detector I/Os
    void print() override;

    std::fstream* getFile();

  private:
    FairParAsciiFileIo(const FairParAsciiFileIo&);
    FairParAsciiFileIo& operator=(const FairParAsciiFileIo&);

    ClassDefOverride(FairParAsciiFileIo, 0);   // Parameter I/O from ASCII files
};

#endif /* !FAIRPARASCIIFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARGENERICSET_H
#define FAIRPARGENERICSET_H

#include "FairParSet.h"   // for FairParSet

#include <Rtypes.h>   // for Bool_t, etc

class FairParIo;
class FairParamList;

class FairParGenericSet : public FairParSet
{
  public:
    FairParGenericSet(const char* name, const char* title, const char* context, Bool_t ownership = kFALSE)
        : FairParSet(name, title, context, ownership)
    {}
    virtual ~FairParGenericSet() {}
    virtual void putParams(FairParamList*) = 0;
    virtual Bool_t getParams(FairParamList*) = 0;
    virtual void printParams();

    Bool_t init(FairParIo* inp) override;
    Int_t write(FairParIo* output) override;

  protected:
    FairParGenericSet()
        : FairParSet()
    {}
    ClassDefOverride(FairParGenericSet, 1);   // Base class for generic-style parameter containers
};

#endif /* !FAIRPARGENERICSET_H */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARIO_H
#define FAIRPARIO_H

#include <Rtypes.h>    // for Bool_t, Text_t, etc
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString

class FairDetParIo;
class FairRtdbRun;
class TList;

class FairParIo : public TObject
{
  protected:
    TList* detParIoList;   // list of detector I/Os
    Bool_t autoWritable;   // flag indicating if automatic write is possible
    TString filename;

  public:
    FairParIo();
    virtual ~FairParIo();
    virtual FairDetParIo* getDetParIo(const Text_t*);
    virtual void setDetParIo(FairDetParIo*);
    virtual void removeDetParIo(Text_t*);
    void setInputNumber(Int_t);
    virtual void close() { ; }

    // returns the filename
    const char* getFilename() { return filename.Data(); }

    // creates input/output class for a special detector and stores pointer
    // used only for Oracle input/output
    // (code in  class OraIo)
    virtual void setDetParIo(Text_t*) { ; }

    // prints information about input/output
    virtual void print() { ; }

    // checks if the input/output is open
    virtual Bool_t check() { return kFALSE; }

    // reads versions of parameter containers for an event file
    virtual void readVersions(FairRtdbRun*) { ; }

    // sets global file pointer in ROOT if input/output is a ROOT-file
    // (code in FairParRootFileIo)
    virtual void cd() { ; }

    // set and get for flag autoWritable
    void setAutoWritable(Bool_t f = kTRUE) { autoWritable = f; }
    Bool_t isAutoWritable() const { return autoWritable; }

  private:
    FairParIo(const FairParIo&);
    FairParIo& operator=(const FairParIo&);

    ClassDefOverride(FairParIo, 0);   // Base class for all parameter I/Os
};

#endif /* !FAIRPARIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARROOTFILEIO_H
#define FAIRPARROOTFILEIO_H

#include "FairParIo.h"   // for FairParIo

#include <Rtypes.h>   // for Bool_t, Text_t, Int_t, etc
#include <TFile.h>    // for TFile
#include <TNamed.h>   // for TNamed
#include <fstream>
using std::fstream;

class FairRtdbRun;
class TKey;
class TList;

class FairParRootFile : public TNamed
{
  public:
    FairRtdbRun* run;   //! pointer to current run in ROOT file
    FairParRootFile(const Text_t* fname, Option_t* option = "READ", const Text_t* ftitle = "", Int_t compress = 1);
    FairParRootFile(TFile* f);
    ~FairParRootFile();
    FairRtdbRun* getRun() { return run; }
    void readVersions(FairRtdbRun*);

    Bool_t IsOpen() { return RootFile && (RootFile->IsOpen()); }
    void cd()
    {
        if (RootFile) {
            RootFile->cd();
        }
    }
    Bool_t IsWritable() { return RootFile && RootFile->IsWritable(); }

    TKey* GetKey(const Text_t* t)
    {
        if (RootFile) {
            return RootFile->GetKey(t);
        } else {
            return nullptr;
        }
    }
    TList* GetListOfKeys()
    {
        if (RootFile) {
            return RootFile->GetListOfKeys();
        } else {
            return nullptr;
        }
    }
    void Close()
    {
        if (RootFile) {
            RootFile->Close();
        }
    }

  protected:
    TFile* RootFile;

  private:
    FairParRootFile(const FairParRootFile&);
    FairParRootFile& operator=(const FairParRootFile&);

    ClassDefOverride(FairParRootFile, 0);   // ROOT file for Parameter I/O
};

class FairParRootFileIo : public FairParIo
{
  protected:
    FairParRootFile* file;   // pointer to ROOT file
    Bool_t fMerging;

  public:
    FairParRootFileIo();
    FairParRootFileIo(Bool_t merged);
    ~FairParRootFileIo();
    Bool_t open(const Text_t* fname, Option_t* option = "READ", const Text_t* ftitle = "", Int_t compress = 1);
    Bool_t open(const TList* fnamelist, Option_t* option = "READ", const Text_t* ftitle = "", Int_t compress = 1);
    static void MergeFiles(TFile* newParFile, const TList* fnamelist);
    void close() override;
    void print() override;
    FairParRootFile* getParRootFile();
    void readVersions(FairRtdbRun*) override;
    TList* getKeys();
    Bool_t check() override
    {
        // returns kTRUE if file is open
        if (file) {
            return file->IsOpen();
        } else {
            return kFALSE;
        }
    }
    void cd() override
    {
        // sets the global ROOT file pointer gFile
        if (file) {
            file->cd();
        }
    }
    /**
    Open an existing root file for IO
    */
    Bool_t open(TFile* f);
    void setMerging(Bool_t io) { fMerging = io; }

  private:
    FairParRootFileIo(const FairParRootFileIo&);
    FairParRootFileIo& operator=(const FairParRootFileIo&);

    ClassDefOverride(FairParRootFileIo, 0);   // Parameter I/O from ROOT files
};

#endif /* !FAIRPARROOTFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARSET_H
#define FAIRPARSET_H

#include <Rtypes.h>   // for Int_t, Bool_t, etc
#include <TObject.h>
#include <TString.h>   // for TString

class FairLogger;
class FairParIo;

class FairParSet : public TObject
{
  protected:
    TString fName;          //
    TString fTitle;         //
    TString detName;        //! name of the detector the container belongs to
    Int_t versions[3];      //! versions of container in the 2 possible inputs
    Bool_t status;          //! static flag
    Bool_t changed;         //! flag is kTRUE if parameters have changed
    Bool_t owned;           //! if flag is KTRUE FairDB has the par. class ownership
    TString paramContext;   // Context/purpose for parameters and conditions
    TString author;         // Author of parameters
    TString description;    // Description of parameters
    /** Fair Logger */
    FairLogger* fLogger;   //!

  public:
    FairParSet(const char* name = "", const char* title = "", const char* context = "", Bool_t owner = kFALSE);
    virtual ~FairParSet() {}

    const char* GetName() const override { return static_cast<const char*>(fName.Data()); }
    const char* GetTitle() const override { return static_cast<const char*>(fTitle.Data()); }

    virtual Bool_t init();
    virtual Bool_t init(FairParIo*) { return kFALSE; }
    virtual Int_t write();
    virtual Int_t write(FairParIo*) { return kFALSE; }
    virtual void clear() {}
    virtual void print();

    const char* getDetectorName() { return detName.Data(); }
    void resetInputVersions();

    void setInputVersion(Int_t v = -1, Int_t i = 0)
    {
        if (i >= 0 && i < 3) {
            versions[i] = v;
        }
    }
    Int_t getInputVersion(Int_t i)
    {
        if (i >= 0 && i < 3) {
            return versions[i];
        } else {
            return 0;
        }
    }

    void setStatic(Bool_t flag = kTRUE) { status = flag; }
    Bool_t isStatic() { return status; }

    void setOwnership(Bool_t flag = kTRUE) { owned = flag; }
    Bool_t isOwned() { return owned; }

    void setChanged(Bool_t flag = kTRUE) { changed = flag; }
    Bool_t hasChanged() { return changed; }

    const char* getParamContext() const { return paramContext.Data(); }

    void setAuthor(const char* s) { author = s; }
    const char* getAuthor() const { return author.Data(); }

    void setDescription(const char* s) { description = s; }
    const char* getDescription() const { return description.Data(); }

    void copyComment(FairParSet& r)
    {
        author = r.getAuthor();
        description = r.getDescription();
    }

    // TODO These two methods are not used in FairRoot at all.
    // They probably should be marked deprecated (or final, or = delete)
    // and later removed.
    virtual void fill(UInt_t){};
    virtual void store(UInt_t){};

    FairParSet& operator=(const FairParSet&);
    FairParSet(const FairParSet&);

    ClassDefOverride(FairParSet, 2);   // Base class for all parameter containers
};

#endif /* !FAIRPARSET_H */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRTDBRUN_H
#define FAIRRTDBRUN_H

#include <Rtypes.h>    // for Int_t, Text_t, UInt_t, etc
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString
#include <iosfwd>      // for fstream
#include <stdio.h>     // for sprintf, sscanf

class TList;
using std::fstream;

class FairParVersion : public TNamed
{
  protected:
    Int_t inputVersions[3];   //! version of the parameter container in the 2 possible inputs
    Int_t rootVersion;        // version of the parameter container in the ROOT output file

  public:
    FairParVersion()
        : TNamed()
        , rootVersion(0)
    {}
    FairParVersion(const char* name);
    ~FairParVersion() {}
    void setInputVersion(Int_t v = -1, Int_t i = 0)
    {
        if (i >= 0 && i < 3) {
            inputVersions[i] = v;
        }
    }
    Int_t getInputVersion(Int_t i) const
    {
        if (i >= 0 && i < 3) {
            return inputVersions[i];
        } else {
            return -1;
        }
    }
    void resetInputVersions()
    {
        for (Int_t i = 0; i < 3; i++) {
            inputVersions[i] = -1;
        }
    }
    void setRootVersion(Int_t v) { rootVersion = v; }
    Int_t getRootVersion() const { return rootVersion; }
    ClassDefOverride(FairParVersion, 1);   // Class for parameter versions
};

class FairRtdbRun : public TNamed
{
  protected:
    TList* parVersions;   // List of container names with the versions
    TString refRun;       //! name of the reference run for initialization

  public:
    FairRtdbRun();
    FairRtdbRun(const Text_t* name, const Text_t* refName = "");
    FairRtdbRun(Int_t r, Int_t rr = -1);
    FairRtdbRun(FairRtdbRun& run);
    ~FairRtdbRun();
    inline UInt_t getRunId(void);
    void addParVersion(FairParVersion* pv);
    FairParVersion* getParVersion(const Text_t* name);
    TList* getParVersions() { return parVersions; }
    const Text_t* getRefRun() { return refRun.Data(); }
    void setRefRun(Text_t* s) { refRun = s; }
    inline void setRefRun(Int_t r);
    void resetInputVersions();
    void resetOutputVersions();
    void print();
    void write(std::fstream&);

  private:
    FairRtdbRun& operator=(const FairRtdbRun&);

    ClassDefOverride(FairRtdbRun, 1);   // Class for parameter version management of a run
};

// -------------------- inlines ---------------------------

inline UInt_t FairRtdbRun::getRunId(void)
{
    UInt_t r;
    sscanf(GetName(), "%i", &r);
    return r;
}

inline void FairRtdbRun::setRefRun(Int_t r)
{
    if (r == -1) {
        refRun = "";
    } else {
        char name[255];
        sprintf(name, "%i", r);
        refRun = name;
    }
}

#endif /* !FAIRRTDBRUN_H */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNTIMEDB_H
#define FAIRRUNTIMEDB_H

#include <Rtypes.h>    // for Bool_t, Int_t, Text_t, etc
#include <TList.h>     // for TList
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString

class FairContFact;
class FairLogger;
class FairParIo;
class FairParSet;
class FairRtdbRun;

static TList contFactories;   //! list of container factories

/**
 * \ingroup parbase
 *
 * See Also: \ref parbase_runtimedb
 */
class FairRuntimeDb : public TObject
{
  private:
    static FairRuntimeDb* gRtdb;   //!

  protected:
    FairRuntimeDb(void);
    TList* containerList;      // list of parameter containers
    TList* runs;               // list of runs
    FairParIo* firstInput;     // first (prefered) input for parameters
    FairParIo* secondInput;    // second input (used if not found in first input)
    FairParIo* output;         // output for parameters
    FairRtdbRun* currentRun;   // Current run
    TString currentFileName;   // Name of current event file
    Bool_t versionsChanged;    // flag for write of list of runs (set kTRUE by each write)
    Bool_t isRootFileOutput;   // flag indicating that the output is a ROOT file
    /** Fair Logger */
    FairLogger* fLogger;   //!

    /**
     * Select which IO type to use.
     */
    typedef enum
    {
        UNKNOWN_Type = 0,
        AsciiFileOutput = 1,   // Ascii in-out-put
        RootFileOutput = 2,    // Root Files
        RootTSQLOutput = 3     // Use a TSQL db
    } ParamIOType;
    ParamIOType ioType;   // IO Type

  public:
    static FairRuntimeDb* instance(void);
    ~FairRuntimeDb() override;

    Bool_t addParamContext(const char*);
    void printParamContexts();
    void addContFactory(FairContFact*);
    void removeContFactory(FairContFact* fact);
    FairContFact* getContFactory(const Text_t*);

    Bool_t addContainer(FairParSet*);
    FairParSet* getContainer(const Text_t*);
    FairParSet* findContainer(const char*);
    void removeContainer(const char*);
    void removeAllContainers();
    Bool_t initContainers(UInt_t runId, Int_t refId = -1, const Text_t* fileName = "");
    void setContainersStatic(Bool_t f = kTRUE);
    Bool_t writeContainers(void);
    Bool_t writeContainer(FairParSet*, FairRtdbRun*, FairRtdbRun* refRun = 0);

    FairRtdbRun* addRun(Int_t runId, Int_t refId = -1);
    FairRtdbRun* getRun(Int_t);
    FairRtdbRun* getRun(const char*);
    FairRtdbRun* getCurrentRun(void) { return currentRun; }
    Text_t const* getCurrentFileName() { return currentFileName.Data(); }
    void clearRunList(void);

    void removeRun(Text_t*);

    Bool_t setInputVersion(Int_t run, Text_t* container, Int_t version, Int_t inputNumber);
    Bool_t setRootOutputVersion(Int_t run, Text_t* container, Int_t version);
    void setVersionsChanged(Bool_t f = kTRUE) { versionsChanged = f; }
    void resetInputVersions(void);
    void resetOutputVersions(void);
    void resetAllVersions(void);

    Bool_t readAll(void);
    void writeVersions(void);
    void saveOutput(void);

    Bool_t setFirstInput(FairParIo*);
    Bool_t setSecondInput(FairParIo*);
    Bool_t setOutput(FairParIo*);
    FairParIo* getFirstInput(void);
    FairParIo* getSecondInput(void);
    FairParIo* getOutput(void);
    void closeFirstInput(void);
    void closeSecondInput(void);
    void closeOutput(void);
    void activateParIo(FairParIo*);
    TList* getListOfContainers() { return containerList; }
    void print(void);

    Int_t findOutputVersion(FairParSet*);

  private:
    FairRuntimeDb(const FairRuntimeDb& M);
    FairRuntimeDb& operator=(const FairRuntimeDb&) { return *this; }
    Bool_t initContainers(void);

    ClassDefOverride(FairRuntimeDb, 0);   // Class for runtime database
};

#endif /* !FAIRRUNTIMEDB_H */

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from G__Base dictionary payload:42:
In file included from /home/physics/fair_install/FairRootInstall/include/FairWriteoutBuffer.h:36:
/home/physics/fair_install/FairRootInstall/include/FairRootManager.h:69:18: error: member access into incomplete type 'FairSink'
            fSink->Close();
                 ^
/home/physics/fair_install/FairRootInstall/include/FairSink.h:35:7: note: definition of 'FairSink' is not complete until the closing '}'
class FairSink
      ^
In file included from G__Base dictionary payload:42:
In file included from /home/physics/fair_install/FairRootInstall/include/FairWriteoutBuffer.h:36:
/home/physics/fair_install/FairRootInstall/include/FairRootManager.h:453:18: error: member access into incomplete type 'FairSink'
            fSink->RegisterAny(brname, ot, pt, &obj);
                 ^
/home/physics/fair_install/FairRootInstall/include/FairSink.h:35:7: note: definition of 'FairSink' is not complete until the closing '}'
class FairSink
      ^
In file included from G__Base dictionary payload:42:
In file included from /home/physics/fair_install/FairRootInstall/include/FairWriteoutBuffer.h:37:
In file included from /home/physics/fair_install/FairRootInstall/include/FairTimeStamp.h:11:
In file included from /home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData_Interface.h:11:
/home/physics/fair_install/FairRootInstall/include/FairLink.h:104:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<<(std::ostream& out, const FairLink& link)
                         ^
/home/physics/fair_install/FairRootInstall/include/FairLink.h:104:26: note: previous definition is here
    friend std::ostream& operator<<(std::ostream& out, const FairLink& link)
                         ^
In file included from G__Base dictionary payload:42:
In file included from /home/physics/fair_install/FairRootInstall/include/FairWriteoutBuffer.h:37:
In file included from /home/physics/fair_install/FairRootInstall/include/FairTimeStamp.h:11:
In file included from /home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData_Interface.h:12:
/home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData.h:128:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData& data)
                         ^
/home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData.h:128:26: note: previous definition is here
    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData& data)
                         ^
In file included from G__Base dictionary payload:42:
In file included from /home/physics/fair_install/FairRootInstall/include/FairWriteoutBuffer.h:37:
In file included from /home/physics/fair_install/FairRootInstall/include/FairTimeStamp.h:11:
/home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData_Interface.h:79:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData_Interface& data)
                         ^
/home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData_Interface.h:79:26: note: previous definition is here
    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData_Interface& data)
                         ^
In file included from G__Base dictionary payload:42:
In file included from /home/physics/fair_install/FairRootInstall/include/FairWriteoutBuffer.h:37:
/home/physics/fair_install/FairRootInstall/include/FairTimeStamp.h:69:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<<(std::ostream& out, const FairTimeStamp& link)
                         ^
/home/physics/fair_install/FairRootInstall/include/FairTimeStamp.h:69:26: note: previous definition is here
    friend std::ostream& operator<<(std::ostream& out, const FairTimeStamp& link)
                         ^
G__Base dictionary payload:2694:18: error: no viable overloaded '='
    fFSTrackIter = fFSTrackMap.find(iTrack);   // check if point created by FastSimulation
    ~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~
G__Base dictionary payload:2696:30: error: member reference type 'std::map<Int_t, Int_t>::iterator' (aka '_Rb_tree_iterator<std::pair<const int, int> >') is not a pointer; did you mean to use '.'?
        iTrack = fFSTrackIter->second;
                 ~~~~~~~~~~~~^~
                             .
G__Base dictionary payload:2696:32: error: no member named 'second' in 'std::_Rb_tree_iterator<std::pair<const int, int> >'
        iTrack = fFSTrackIter->second;
                 ~~~~~~~~~~~~  ^
G__Base dictionary payload:6517:19: error: no viable overloaded '='
        fSimSetup = f;
        ~~~~~~~~~ ^ ~
/usr/include/c++/11/bits/std_function.h:487:7: note: candidate function not viable: no known conversion from 'std::function<void ()>' to 'std::function<void ()> &&' for 1st argument
      operator=(function&& __x) noexcept
      ^
/usr/include/c++/11/bits/std_function.h:501:7: note: candidate function not viable: no known conversion from 'std::function<void ()>' to 'std::nullptr_t' (aka 'nullptr_t') for 1st argument
      operator=(nullptr_t) noexcept
      ^
/usr/include/c++/11/type_traits:2205:46: note: candidate template ignored: disabled by 'enable_if' [with _Functor = std::function<void ()> &]
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;
                                             ^
/usr/include/c++/11/bits/std_function.h:540:2: note: candidate template ignored: could not match 'reference_wrapper' against 'function'
        operator=(reference_wrapper<_Functor> __f) noexcept
        ^
G__Base dictionary payload:6522:27: error: no viable overloaded '='
        fSimSetupPostInit = f;
        ~~~~~~~~~~~~~~~~~ ^ ~
/usr/include/c++/11/bits/std_function.h:487:7: note: candidate function not viable: no known conversion from 'std::function<void ()>' to 'std::function<void ()> &&' for 1st argument
      operator=(function&& __x) noexcept
      ^
/usr/include/c++/11/bits/std_function.h:501:7: note: candidate function not viable: no known conversion from 'std::function<void ()>' to 'std::nullptr_t' (aka 'nullptr_t') for 1st argument
      operator=(nullptr_t) noexcept
      ^
/usr/include/c++/11/type_traits:2205:46: note: candidate template ignored: disabled by 'enable_if' [with _Functor = std::function<void ()> &]
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;
                                             ^
/usr/include/c++/11/bits/std_function.h:540:2: note: candidate template ignored: could not match 'reference_wrapper' against 'function'
        operator=(reference_wrapper<_Functor> __f) noexcept
        ^
In file included from /home/physics/fair_install/FairSoft/build/Build/root/input_line_4:2:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/Rtypes.h:191:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/TGenericClassInfo.h:22:
In file included from /usr/include/c++/11/vector:67:
/usr/include/c++/11/bits/stl_vector.h:680:30: error: no member named '_M_start' in 'std::_Vector_base<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_Vector_impl'
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                      ~~~~~~~~~~~~~ ^
G__Base dictionary payload:5257:5: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::~vector' requested here
    FairRingSorter(int size = 100, double width = 10)
    ^
In file included from /home/physics/fair_install/FairSoft/build/Build/root/input_line_4:2:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/Rtypes.h:191:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/TGenericClassInfo.h:22:
In file included from /usr/include/c++/11/vector:67:
/usr/include/c++/11/bits/stl_vector.h:557:16: error: no member named '_M_finish' in 'std::_Vector_base<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_Vector_impl'
        this->_M_impl._M_finish =
        ~~~~~~~~~~~~~ ^
G__Base dictionary payload:5275:66: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::vector' requested here
    virtual std::vector<FairTimeStamp*> GetOutputData() { return fOutputData; }
                                                                 ^
In file included from /home/physics/fair_install/FairSoft/build/Build/root/input_line_4:2:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/Rtypes.h:191:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/TGenericClassInfo.h:22:
In file included from /usr/include/c++/11/vector:67:
/usr/include/c++/11/bits/stl_vector.h:919:40: error: no member named '_M_finish' in 'std::_Vector_base<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_Vector_impl'
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
                         ~~~~~~~~~~~~~ ^
/usr/include/c++/11/bits/stl_vector.h:554:19: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::size' requested here
      : _Base(__x.size(),
                  ^
G__Base dictionary payload:5275:66: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::vector' requested here
    virtual std::vector<FairTimeStamp*> GetOutputData() { return fOutputData; }
                                                                 ^
In file included from /home/physics/fair_install/FairSoft/build/Build/root/input_line_4:2:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/Rtypes.h:191:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/TGenericClassInfo.h:22:
In file included from /usr/include/c++/11/vector:67:
/usr/include/c++/11/bits/stl_vector.h:1499:39: error: no member named '_M_start' in 'std::_Vector_base<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_Vector_impl'
      { _M_erase_at_end(this->_M_impl._M_start); }
                        ~~~~~~~~~~~~~ ^
G__Base dictionary payload:5277:51: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::clear' requested here
    virtual void DeleteOutputData() { fOutputData.clear(); }
                                                  ^
In file included from /home/physics/fair_install/FairSoft/build/Build/root/input_line_4:2:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/Rtypes.h:191:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/TGenericClassInfo.h:22:
In file included from /usr/include/c++/11/vector:67:
/usr/include/c++/11/bits/stl_vector.h:1794:36: error: no member named '_M_finish' in 'std::_Vector_base<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_Vector_impl'
        if (size_type __n = this->_M_impl._M_finish - __pos)
                            ~~~~~~~~~~~~~ ^
/usr/include/c++/11/bits/stl_vector.h:1499:9: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_M_erase_at_end' requested here
      { _M_erase_at_end(this->_M_impl._M_start); }
        ^
G__Base dictionary payload:5277:51: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::clear' requested here
    virtual void DeleteOutputData() { fOutputData.clear(); }
                                                  ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class FairSink with content:

#line 1 "G__Base dictionary payload"

#ifndef BUILD_PROOF_SUPPORT
  #define BUILD_PROOF_SUPPORT 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilder header file                -----
// -----                  Created 23/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------

/** FairEventBuilder
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 23/09/2013
 *@version 1.0
 **
 ** FairRoot base task for the event buffers.
 ** The tasks may:
 ** 1. analyze data to reconstruct event times or other characteristics
 **    in the function TClonesArray* FindEvents(), that returns
 **    TClonesArray of FairRecoEvents
 ** 2. identify the data that could belong to event in the
 **    function and insert this identified data to the output TClonesArrays
 **    in the function StoreEventData(event)
 ** The implementations may be using any or both of the above functions.
 **/

#ifndef FAIREVENTBUILDER_H
#define FAIREVENTBUILDER_H 1

#include "FairRecoEventHeader.h"
#include "FairWriteoutBuffer.h"

#include <Rtypes.h>
#include <TStopwatch.h>
#include <TString.h>
#include <utility>   // pair
#include <vector>

class TClonesArray;
// class FairRecoEventHeader;

class FairEventBuilder : public FairWriteoutBuffer
{
  public:
    /** Default constructor **/
    FairEventBuilder();

    /** Constructor with task name **/
    FairEventBuilder(TString branchName, TString className, TString folderName, Bool_t persistance);

    /** Destructor **/
    virtual ~FairEventBuilder();

    virtual void WriteOutAllDeadTimeData();

    virtual std::vector<std::pair<double, FairRecoEventHeader*>> FindEvents() = 0;
    virtual void StoreEventData(FairRecoEventHeader* /*recoEvent*/) = 0;

    void SetIdentifier(Int_t ident) { fIdentifier = ident; }
    Int_t GetIdentifier() { return fIdentifier; }

    virtual Bool_t Init() = 0;

    virtual void Print(Option_t* option = "") const = 0;

    /** Finish at the end of each event **/
    virtual void Finish();

    Double_t AllowedTime() { return fMaxAllowedEventCreationTime; };
    void SetMaxAllowedTime(Double_t td) { fMaxAllowedEventCreationTime = td; };

    void SetBuilderName(const char* name) { fBuilderName = name; }
    TString GetBuilderName() { return fBuilderName; }

  private:
    TString fBuilderName;

    TStopwatch fTimer;
    Double_t fExecTime;

    Int_t fIdentifier;
    Double_t fMaxAllowedEventCreationTime;

    ClassDef(FairEventBuilder, 1);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilderManager header file              -----
// -----                  Created 20/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------

/** FairEventBuilderManager
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 20/09/2013
 *@version 1.0
 **
 ** FairRoot general task for recreating events in Time-Based reconstruction mode.
 ** Various experiments should implement their own version of Event Builder.
 ** The main member of the task is vector of reconstructed events fRecoEvents.
 ** It also contains a vector of implementations of FairEventBuilders, that are
 ** responsible for feeding fRecoEvents vector via FindEvents() function.
 **
 ** The heart of the experiment-specific implemenations is
 ** the AnalyzeAndExtractEvents() function, which should interpret
 ** the experimental data to reconstruct events.
 **/

#ifndef FAIREVENTBUILDERMANAGER_H
#define FAIREVENTBUILDERMANAGER_H 1

#include "FairEventBuilder.h"
#include "FairTask.h"

#include <Rtypes.h>   // ClassDef
#include <vector>

class TClonesArray;

class FairEventBuilderManager : public FairTask
{
  public:
    /** Default constructor **/
    FairEventBuilderManager();

    /** Constructor with task name **/
    FairEventBuilderManager(const char* name, Int_t iVerbose = 1);

    /** Destructor **/
    virtual ~FairEventBuilderManager();

    /** Execution **/
    virtual void Exec(Option_t* opt);

    /** Adding FairEventBuilder **/
    virtual void AddEventBuilder(FairEventBuilder* eventBuilder);

  protected:
    std::vector<FairEventBuilder*> fEventBuilders;
    std::vector<std::vector<std::pair<double, FairRecoEventHeader*>>> fPossibleEvents;

    /** Fill events from various builders **/
    virtual Double_t FillEventVectors();

    /** Analyze and extract events - experiment specific **/
    virtual void AnalyzeAndExtractEvents(Double_t maxEventTimeAllowed) = 0;

    /** Create output tree structure **/
    virtual void CreateAndFillEvent(FairRecoEventHeader* recoEvent);

  private:
    /** Intialisation **/
    virtual InitStatus Init();

    /** Reinitialisation **/
    virtual InitStatus ReInit();

    /** Finish at the end of each event **/
    virtual void Finish();

    ClassDef(FairEventBuilderManager, 1);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2023 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairEventHeader header file                      -----
// -----          Created 08/09/04                 D.Bertini           -----
// -------------------------------------------------------------------------

#ifndef FAIREVENTHEADER_H
#define FAIREVENTHEADER_H

#include <Rtypes.h>   // for Int_t, Double_t, UInt_t, ClassDef, etc
#include <TNamed.h>   // for TNamed

/**
 *  Event Header Class
 **@author D.Bertini <d.bertini@gsi.de>
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairEventHeader : public TNamed
{
  public:
    /** Default constructor */
    FairEventHeader() = default;

    /**
     * Destructor
     */
    ~FairEventHeader() override = default;

    /** Get the run ID for this run*/
    UInt_t GetRunId() const { return fRunId; }

    /** Get the MC time for this event*/
    Double_t GetEventTime() const { return fEventTime; }

    /** Get the MC input file Id for this event*/
    Int_t GetInputFileId() const { return fInputFileId; }

    /**The entry number in the original MC chain */
    Int_t GetMCEntryNumber() const { return fMCEntryNo; }

    /** Set the run ID for this run
     * @param runid : unique run id
     */
    void SetRunId(UInt_t runid) { fRunId = runid; }

    /** Set the MC time for this event
     * @param time : time in ns
     */
    void SetEventTime(Double_t time) { fEventTime = time; }

    /** Set the Signal file Id for this event*/
    void SetInputFileId(Int_t id) { fInputFileId = id; }

    /**The entry number in the original MC chain */
    void SetMCEntryNumber(Int_t id) { fMCEntryNo = id; }

    virtual void Register(Bool_t Persistance = kTRUE);

  protected:
    /** Run Id */
    UInt_t fRunId{0};
    /** Event Time **/
    Double_t fEventTime{-1.};
    /** Input file identifier, the file description is in the File header*/
    Int_t fInputFileId{0};
    /**MC entry number from input chain*/
    Int_t fMCEntryNo{0};

    ClassDefOverride(FairEventHeader, 3);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                         FairFileHeader source file           -----
// -----            Created 20/04/11                 M.Al-Turany        -----
// -------------------------------------------------------------------------

#ifndef FAIRFILEHEADER_H
#define FAIRFILEHEADER_H

#include <Rtypes.h>    // for UInt_t, etc
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString

class FairFileInfo;
class TFile;
class TList;

/**
 *  File Header Class
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairFileHeader : public TNamed
{
  public:
    /** Default constructor */
    FairFileHeader();

    /**Add a class name of a task*/
    void AddTaskClassName(TString taskname);

    /** Set the run ID for this run
     * @param runid : unique run id
     */
    void SetRunId(UInt_t runid) { fRunId = runid; }

    /** Get the run ID for this run*/
    UInt_t GetRunId() { return fRunId; }

    /** Return the list of tasks class names */
    TList* GetListOfTasks() { return fTaskList; }

    void AddInputFile(TFile* f, UInt_t id, UInt_t ChId);

    /**
     * Destructor
     */
    virtual ~FairFileHeader();

    FairFileInfo* GetFileInfo(UInt_t id, UInt_t ChId);

  protected:
    /** Run Id */
    UInt_t fRunId;

    /**list of TObjStrings presenting the class names of tasks used to produce this file */
    TList* fTaskList;

    /**list of TObjStrings presenting the input files used to produce this file*/
    TList* fFileList;

  private:
    FairFileHeader(const FairFileHeader&);
    FairFileHeader& operator=(const FairFileHeader&);

    ClassDef(FairFileHeader, 2);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//  FairFileInfo.h
//  Created by Mohammad Al-Turany on 6/21/11.
//
#ifndef FAIRFILEINFO_H
#define FAIRFILEINFO_H

#include <Rtypes.h>    // for UInt_t, FairFileInfo::Class, etc
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString

class TFile;

class FairFileInfo : public TNamed
{
  public:
    FairFileInfo();
    FairFileInfo(TFile* file, UInt_t id, UInt_t ChId);
    virtual ~FairFileInfo();

    TString GetPath() { return fPath; }
    UInt_t GetSize() { return fSize; }
    UInt_t GetIdentifier() { return fIdentifier; }
    UInt_t GetOrderInChain() { return fInChainId; }

    void Print(Option_t* option = "") const;

    void SetPath(TString path) { fPath = path; }
    void SetSize(UInt_t size) { fSize = size; }
    void SetIdentifier(UInt_t id) { fIdentifier = id; }
    void SetOrderInChain(UInt_t id) { fInChainId = id; }

  protected:
    /** Full path of file*/
    TString fPath;
    /** size of file in bytes*/
    UInt_t fSize;
    /** Signal file identifier used*/
    UInt_t fIdentifier;
    /** file order in the chain*/
    UInt_t fInChainId;

  private:
    FairFileInfo(const FairFileInfo&);
    FairFileInfo& operator=(const FairFileInfo&);

    ClassDef(FairFileInfo, 1);
};

#endif   // FAIRFILEINFO_H
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRHIT_H
#define FAIRHIT_H

#include "FairTimeStamp.h"   // for FairTimeStamp

#include <Rtypes.h>     // for Double_t, Int_t, Double32_t, etc
#include <TVector3.h>   // for TVector3

/**
 * Abstract base class for reconstructed hits in the FAIR detectors.
 **@author V.Friese <v.friese@gsi.de>
 **@author D.Bertini <d.bertini@gsi.de>
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairHit : public FairTimeStamp
{
  public:
    /** Default constructor **/
    FairHit();

    /** Constructor with hit parameters **/
    FairHit(Int_t detID, const TVector3& pos, const TVector3& dpos, Int_t index);

    /** Destructor **/
    virtual ~FairHit();

    /** Accessors **/
    Double_t GetDx() const { return fDx; };
    Double_t GetDy() const { return fDy; };
    Double_t GetDz() const { return fDz; };
    Int_t GetRefIndex() const { return fRefIndex; };
    void PositionError(TVector3& dpos) const;
    Int_t GetDetectorID() const { return fDetectorID; };
    Double_t GetX() const { return fX; };
    Double_t GetY() const { return fY; };
    Double_t GetZ() const { return fZ; };
    void Position(TVector3& pos) const;

    /** Modifiers **/
    void SetDx(Double_t dx) { fDx = dx; }
    void SetDy(Double_t dy) { fDy = dy; }
    void SetDz(Double_t dz) { fDz = dz; }
    void SetDxyz(Double_t dx, Double_t dy, Double_t dz);
    void SetPositionError(const TVector3& dpos);
    void SetRefIndex(Int_t index) { fRefIndex = index; }
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);

    /*** Output to screen */
    virtual void Print(const Option_t*) const { ; }

  protected:
    Double32_t fDx, fDy, fDz;   ///< Errors of position [cm]
    Int_t fRefIndex;            ///< Index of FairMCPoint for this hit
    Int_t fDetectorID;          ///< Detector unique identifier
    Double32_t fX, fY, fZ;      ///< Position of hit [cm]

    ClassDef(FairHit, 3);
};

inline void FairHit::PositionError(TVector3& dpos) const { dpos.SetXYZ(fDx, fDy, fDz); }

inline void FairHit::SetDxyz(Double_t dx, Double_t dy, Double_t dz)
{
    fDx = dx;
    fDy = dy;
    fDz = dz;
}

inline void FairHit::SetPositionError(const TVector3& dpos)
{
    fDx = dpos.X();
    fDy = dpos.Y();
    fDz = dpos.Z();
}

inline void FairHit::Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); }

inline void FairHit::SetXYZ(Double_t x, Double_t y, Double_t z)
{
    fX = x;
    fY = y;
    fZ = z;
}

inline void FairHit::SetPosition(const TVector3& pos)
{
    fX = pos.X();
    fY = pos.Y();
    fZ = pos.Z();
}

#endif   // FAIRHIT_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairLink.h
 *
 *  Created on: Dec 23, 2009
 *      Author: stockman
 *      "Pointer" to any data structure inside a root file with a tree structure
 *      Contains four information:
 *      	File : in which file is the data written (-1 : actual number; 254 : maximum number)
 *      	Entry: entry number in branch of a tree (-1 : actual entry)
 *      	Type : branch inside the tree (-1 : FairLink not set; 65534 : maximum number)
 *      	Index: position inside a container stored in the given branch and entry
 *      	Weight: weighting factor to describe probabilities of a MC truth match
 *
 */

#ifndef FAIRLINK_H_
#define FAIRLINK_H_

#include <Rtypes.h>   // for Int_t, Float_t, etc, ClassDefNV
#include <iostream>   // for ostream, cout

class FairLink
{
  public:
    FairLink();
    FairLink(Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(TString branchName, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, TString branchName, Int_t index, Float_t weight = 1.);
    ~FairLink(){};

    void SetLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.)
    {
        SetFile(file);
        SetEntry(entry);
        SetType(type);
        SetIndex(index);
        SetWeight(weight);
    };
    void SetLink(Int_t type, Int_t index, Float_t weight = 1.)
    {
        SetFile(-1);
        SetEntry(-1);
        SetType(type);
        SetIndex(index);
        SetWeight(weight);
    };
    int GetFile() const;
    int GetEntry() const { return fEntry; }
    int GetType() const;
    int GetIndex() const { return fIndex; }
    float GetWeight() const { return fWeight; }

    void SetFile(int file);
    void SetEntry(int entry) { fEntry = entry; };
    void SetType(int type);
    void SetIndex(int index) { fIndex = index; };

    void SetWeight(Float_t weight) { fWeight = weight; }
    void AddWeight(Float_t weight) { fWeight += weight; }

    void PrintLinkInfo(std::ostream& out = std::cout) const;

    bool operator==(const FairLink& link) const
    {
        return (GetFile() == link.GetFile() || link.GetFile() == -1)
               && (GetEntry() == link.GetEntry() || link.GetEntry() == -1) && GetType() == link.GetType()
               && GetIndex() == link.GetIndex();
    }

    bool operator<(const FairLink& link) const
    {
        if (GetFile() != -1 && link.GetFile() != -1) {
            if (GetFile() < link.GetFile())
                return true;
            else if (link.GetFile() < GetFile())
                return false;
        }
        if (GetEntry() != -1 && link.GetEntry() != -1) {
            if (GetEntry() < link.GetEntry())
                return true;
            else if (link.GetEntry() < GetEntry())
                return false;
        }
        if (GetType() < link.GetType())
            return true;
        else if (link.GetType() < GetType())
            return false;
        if (GetIndex() < link.GetIndex())
            return true;
        else if (link.GetIndex() < GetIndex())
            return false;

        return false;
    }

    friend std::ostream& operator<<(std::ostream& out, const FairLink& link)
    {
        link.PrintLinkInfo(out);
        return out;
    }

    ClassDefNV(FairLink, 5);

    template<class Archive>
    void serialize(Archive& ar, const unsigned int)
    {
        ar& fFile;
        ar& fType;
        ar& fEntry;
        ar& fIndex;
        ar& fWeight;
    }

  private:
    unsigned char fFile;
    unsigned short fType;
    int fEntry;
    int fIndex;
    float fWeight;
};

inline FairLink::FairLink()
    : fFile(0)
    , fType(0)
    , fEntry(-1)
    , fIndex(-1)
    , fWeight(1.0)
{}

inline FairLink::FairLink(Int_t type, Int_t index, Float_t weight)
    : fFile(0)
    , fType(0)
    , fEntry(-1)
    , fIndex(index)
    , fWeight(weight)
{
    SetType(type);
}

inline FairLink::FairLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight)
    : fFile(0)
    , fType(0)
    , fEntry(entry)
    , fIndex(index)
    , fWeight(weight)
{
    SetFile(file);
    SetType(type);
}

inline void FairLink::SetType(int type)
{
    if (type < -1)
        return;
    fType = type + 1;
}

inline int FairLink::GetType() const
{
    int type = fType;
    return type - 1;
}

inline void FairLink::SetFile(int file)
{
    if (file < -1)
        return;
    fFile = file + 1;
}

inline int FairLink::GetFile() const
{
    int file = fFile;
    return file - 1;
}

#endif /* FAIRLINK_H_ */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/** FairMCEventHeader.h
 *@author V.Friese <v.friese@gsi.de>
 ** Data class (level MC) containing information about the input event.
 ** 15.05.2008 change the event time to ns (M. Al-Turany)
 **/

#ifndef FAIRMCEVENTHEADER_H
#define FAIRMCEVENTHEADER_H 1

#include <Rtypes.h>     // for Double_t, UInt_t, etc
#include <TNamed.h>     // for TNamed
#include <TVector3.h>   // for TVector3
#include <limits>       // for std::numeric_limits

class FairMCEventHeader : public TNamed
{
  public:
    /// Alias name for event id type
    using EventID = UInt_t;

    /// Sentinel value for the event id, meaning no event id stored
    static constexpr EventID NoEventID = std::numeric_limits<EventID>::max();

    /** Default constructor **/
    FairMCEventHeader();

    /** Constructor with all members
     **
     *@param iEvent   event identifier
     *@param x,y,z    vertex oordinates [cm]
     *@param t        event time [ns]
     *@param b        impact parameter [fm] (if relevant)
     *@param nPrim    number of input tracks
     **/
    FairMCEventHeader(EventID iEvent, Double_t x, Double_t y, Double_t z, Double_t t, Double_t b, Int_t nPrim);

    /** Standard constructor with run identifier **/
    FairMCEventHeader(UInt_t runId);

    /** Destructor **/
    virtual ~FairMCEventHeader();

    /** Accessors **/
    UInt_t GetRunID() const { return fRunId; }        /// run identifier
    EventID GetEventID() const { return fEventId; }   /// event identifier
    /// check whether an event id is set
    Bool_t HasEventID() const { return fEventId != NoEventID; }
    Double_t GetX() const { return fX; }         /// vertex x [cm]
    Double_t GetY() const { return fY; }         /// vertex y [cm]
    Double_t GetZ() const { return fZ; }         /// vertex z [cm]
    Double_t GetT() const { return fT; }         /// event time [ns]
    Double_t GetB() const { return fB; }         /// impact parameter [fm]
    Int_t GetNPrim() const { return fNPrim; }    /// number of input tracks
    Bool_t IsSet() const { return fIsSet; }      /// Flag
    Double_t GetRotX() const { return fRotX; }   /// rot. around x-axis [rad]
    Double_t GetRotY() const { return fRotY; }   /// rot. around y-axis [rad]
    Double_t GetRotZ() const { return fRotZ; }   /// rot. around z-axis [rad]

    void GetVertex(TVector3& vertex) { vertex.SetXYZ(fX, fY, fZ); }

    /** Modifiers **/
    void SetEventID(EventID eventId) { fEventId = eventId; }
    void SetRunID(UInt_t runId) { fRunId = runId; }
    void SetTime(Double_t t) { fT = t; }
    void SetB(Double_t b) { fB = b; }
    void SetNPrim(Int_t nPrim) { fNPrim = nPrim; }
    void MarkSet(Bool_t isSet) { fIsSet = isSet; }
    void SetVertex(Double_t x, Double_t y, Double_t z);
    void SetVertex(const TVector3& vertex);
    void SetRotX(Double_t rotx) { fRotX = rotx; }
    void SetRotY(Double_t roty) { fRotY = roty; }
    void SetRotZ(Double_t rotz) { fRotZ = rotz; }

    /** Reset all members **/
    void Reset();

    /** Register the class as data branch to the output */
    virtual void Register();

  protected:
    UInt_t fRunId;                 ///  Run identifier
    EventID fEventId{NoEventID};   ///  Event identifier
    Double32_t fX;                 ///  Primary vertex x [cm]
    Double32_t fY;                 ///  Primary vertex y [cm]
    Double32_t fZ;                 ///  Primary vertex z [cm]
    Double32_t fT;                 ///  Event time [s]
    Double32_t fB;                 ///  Impact parameter [fm] (if relevant)
    Int_t fNPrim;                  ///  Number of input tracks
    Bool_t fIsSet;                 ///  Flag whether variables are filled
    Double32_t fRotX;              ///  Rotation around x-axis (beam tilt) [rad]
    Double32_t fRotY;              ///  Rotation around y-axis (beam tilt) [rad]
    Double32_t fRotZ;              ///  Rotation around z-axis (event plane) [rad]

    ClassDef(FairMCEventHeader, 2);
};

inline void FairMCEventHeader::SetVertex(Double_t x, Double_t y, Double_t z)
{
    fX = x;
    fY = y;
    fZ = z;
}

inline void FairMCEventHeader::SetVertex(const TVector3& vertex)
{
    fX = vertex.X();
    fY = vertex.Y();
    fZ = vertex.Z();
}

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**  FairMCPoint.h
 * This is the base class for all MC Points generated by the transport of
 * tracks through active detectors.
 **/

#ifndef FAIRMCPOINT_H
#define FAIRMCPOINT_H

#include "FairMultiLinkedData_Interface.h"   // for FairMultiLinkedData

#include <Rtypes.h>     // for Double_t, Double32_t, Int_t, etc
#include <TVector3.h>   // for TVector3

class FairMCPoint : public FairMultiLinkedData_Interface
{
  public:
    /** Default constructor **/
    FairMCPoint();

    /** Constructor with arguments
     *@param trackID  Index of MCTrack
     *@param detID    Detector ID
     *@param pos      Point coordinates [cm]
     *@param mom      Momentum of track at MCPoint [GeV]
     *@param tof      Time since event start [ns]
     *@param length   Track length since creation [cm]
     *@param eLoss    Energy deposit [GeV]
     *@param EventId  MC event id
     **/
    FairMCPoint(Int_t trackID,
                Int_t detID,
                TVector3 pos,
                TVector3 mom,
                Double_t tof,
                Double_t length,
                Double_t eLoss,
                UInt_t EventId = 0);

    /** Destructor **/
    virtual ~FairMCPoint();

    /** Accessors */
    UInt_t GetEventID() const { return fEventId; }   /// event identifier
    Int_t GetTrackID() const { return fTrackID; }
    Double_t GetPx() const { return fPx; }
    Double_t GetPy() const { return fPy; }
    Double_t GetPz() const { return fPz; }
    Double_t GetTime() const { return fTime; }
    Double_t GetLength() const { return fLength; }
    Double_t GetEnergyLoss() const { return fELoss; }
    void Momentum(TVector3& mom) const { mom.SetXYZ(fPx, fPy, fPz); }
    Int_t GetDetectorID() const { return fDetectorID; };
    Double_t GetX() const { return fX; };
    Double_t GetY() const { return fY; };
    Double_t GetZ() const { return fZ; };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); }

    /** Modifiers **/
    void SetEventID(UInt_t eventId) { fEventId = eventId; }
    virtual void SetTrackID(Int_t id) { fTrackID = id; }
    void SetTime(Double_t time) { fTime = time; }
    void SetLength(Double_t length) { fLength = length; }
    void SetEnergyLoss(Double_t eLoss) { fELoss = eLoss; }
    void SetMomentum(const TVector3& mom);
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);

    /** Output to screen **/
    virtual void Print(const Option_t* opt = 0) const;

  protected:
    Int_t fTrackID;             ///< Track index
    UInt_t fEventId;            ///< MC Event id
    Double32_t fPx, fPy, fPz;   ///< Momentum components [GeV]
    Double32_t fTime;           ///< Time since event start [ns]
    Double32_t fLength;         ///< Track length since creation [cm]
    Double32_t fELoss;          ///< Energy loss at this point [GeV]
    Int_t fDetectorID;          ///< Detector unique identifier
    Double32_t fX, fY, fZ;      ///< Position of hit [cm]

    ClassDef(FairMCPoint, 5);
};

inline void FairMCPoint::SetMomentum(const TVector3& mom)
{
    fPx = mom.Px();
    fPy = mom.Py();
    fPz = mom.Pz();
}

inline void FairMCPoint::SetXYZ(Double_t x, Double_t y, Double_t z)
{
    fX = x;
    fY = y;
    fZ = z;
}

inline void FairMCPoint::SetPosition(const TVector3& pos)
{
    fX = pos.X();
    fY = pos.Y();
    fZ = pos.Z();
}

#endif   // FAIRMCPOINT_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairMesh header file                    -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------

#ifndef FAIRMESH_H
#define FAIRMESH_H

#include <Rtypes.h>    // for Double_t, Int_t, etc
#include <TH2.h>       // for TH2D
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString

/**
 * Abstract base class for Mesh Objects.
 **@author D.Bertini <d.bertini@gsi.de>
 */
class FairMesh : public TObject
{
  public:
    /** Default constructor **/
    FairMesh();
    FairMesh(const char*);

    /** Destructor **/
    virtual ~FairMesh();

    /** Accessors **/
    Double_t GetXmin() const { return fXmin; };
    Double_t GetYmin() const { return fYmin; };
    Double_t GetZmin() const { return fZmin; };

    Double_t GetXmax() const { return fXmax; };
    Double_t GetYmax() const { return fYmax; };
    Double_t GetZmax() const { return fZmax; };

    /** Modifiers **/
    void SetX(Double_t xmin, Double_t xmax, Int_t nbin)
    {
        fXmin = xmin;
        fXmax = xmax;
        NXbin = nbin;
    }
    void SetY(Double_t ymin, Double_t ymax, Int_t nbin)
    {
        fYmin = ymin;
        fYmax = ymax;
        NYbin = nbin;
    }
    void SetZ(Double_t zmin, Double_t zmax, Int_t nbin)
    {
        fZmin = zmin;
        fZmax = zmax;
        NZbin = nbin;
    }

    TH2D* GetMeshTid() { return fMeshTid; }
    TH2D* GetMeshFlu() { return fMeshFlu; }
    TH2D* GetMeshSEU() { return fMeshSEU; }
    /*** Output to screen */
    // virtual void Print(const Option_t* opt = 0) const {;}

    Double_t GetDiag() { return fDiag; }
    Double_t GetBinVolume() { return fBinVolume; }

    void fillTID(Double_t x, Double_t y, Double_t we) { fMeshTid->Fill(x, y, we); }
    void fillFluence(Double_t x, Double_t y, Double_t we) { fMeshFlu->Fill(x, y, we); }
    void fillSEU(Double_t x, Double_t y, Double_t we) { fMeshSEU->Fill(x, y, we); }
    void Scale(Double_t fac)
    {
        fMeshTid->Scale(fac);
        fMeshFlu->Scale(fac);
        fMeshSEU->Scale(fac);
    }

    void calculate();

    void print();

  protected:
    Double_t fXmin, fYmin, fZmin;
    Double_t fXmax, fYmax, fZmax;
    Int_t NXbin, NYbin, NZbin;
    Double_t fBinVolume;
    Double_t fDiag;
    TH2D* fMeshTid;   // !mesh
    TH2D* fMeshFlu;   // !mesh
    TH2D* fMeshSEU;   // !mesh
    TString fhname;   // !mesh

  private:
    FairMesh(const FairMesh&);
    FairMesh& operator=(const FairMesh&);

    ClassDef(FairMesh, 1);
};

#endif
/**
 * FairMultiLinkedData_Interface.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FairMultiLinkedData_Interface_H_
#define FairMultiLinkedData_Interface_H_

#include "FairLink.h"   // for FairLink
#include "FairMultiLinkedData.h"

#include <Rtypes.h>    // for Int_t, Bool_t, kFALSE, etc
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString
#include <iostream>    // for operator<<, ostream, cout
#include <memory>      // for std::unique_ptr
#include <set>         // for set
#include <vector>      // for vector

class FairMultiLinkedData_Interface : public TObject
{
  public:
    FairMultiLinkedData_Interface() = default;   ///< Default constructor
    FairMultiLinkedData_Interface(FairMultiLinkedData& links, Bool_t persistanceCheck = kTRUE);   ///< Constructor
    FairMultiLinkedData_Interface(TString dataType,
                                  std::vector<Int_t> links,
                                  Int_t fileId = -1,
                                  Int_t evtId = -1,
                                  Bool_t persistanceCheck = kTRUE,
                                  Bool_t bypass = kFALSE,
                                  Float_t mult = 1.0);   ///< Constructor
    FairMultiLinkedData_Interface(Int_t dataType,
                                  std::vector<Int_t> links,
                                  Int_t fileId = -1,
                                  Int_t evtId = -1,
                                  Bool_t persistanceCheck = kTRUE,
                                  Bool_t bypass = kFALSE,
                                  Float_t mult = 1.0);   ///< Constructor
    FairMultiLinkedData_Interface(const FairMultiLinkedData_Interface& toCopy);

    ~FairMultiLinkedData_Interface() = default;

    FairMultiLinkedData_Interface& operator=(const FairMultiLinkedData_Interface& rhs);

    std::set<FairLink> GetLinks() const;                      ///< returns stored links as FairLinks
    Int_t GetNLinks() const;                                  ///< returns the number of stored links
    FairLink GetLink(Int_t pos) const;                        ///< returns the FairLink at the given position
    FairMultiLinkedData GetLinksWithType(Int_t type) const;   ///< returns all FairLinks with the corresponding type
    FairLink GetEntryNr() const;
    FairMultiLinkedData* GetPointerToLinks() const { return fLink.get(); }   ///< returns non-owning pointer

    std::vector<FairLink> GetSortedMCTracks();

    void SetLinks(FairMultiLinkedData links);   ///< Sets the links as vector of FairLink
    void SetLink(FairLink link);                ///< Sets the Links with a single FairLink
    void SetInsertHistory(Bool_t val);
    void SetEntryNr(FairLink val);
    ///< @param[in] links transfers ownership
    void SetPointerToLinks(FairMultiLinkedData* links) { fLink.reset(links); }
    void SetPointerToLinks(std::unique_ptr<FairMultiLinkedData> links) { fLink = std::move(links); }

    void AddLinks(FairMultiLinkedData links,
                  Float_t mult = 1.0);   ///< Adds a List of FairLinks (FairMultiLinkedData_Interface) to fLinks
    void AddLink(FairLink link);   ///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link is allowed
                                   ///< more than once otherwise
    void AddInterfaceData(FairMultiLinkedData_Interface* data);

    void ResetLinks();

    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const
    {
        if (GetPointerToLinks() != 0)
            GetPointerToLinks()->PrintLinkInfo(out);
        return out;
    }   ///< Output

    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData_Interface& data)
    {
        data.PrintLinkInfo(out);
        return out;
    }   ///< Output

  protected:
    std::unique_ptr<FairMultiLinkedData> fLink;
    FairMultiLinkedData* CreateFairMultiLinkedData();   ///< returns non-owning pointer

    ClassDef(FairMultiLinkedData_Interface, 6);
};

/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is
 * stored
 */

/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is
 * stored
 */

#endif /* FairMultiLinkedData_Interface_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * FairMultiLinkedData.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FAIRMULTILINKEDDATA_H_
#define FAIRMULTILINKEDDATA_H_

#include "FairLink.h"   // for FairLink

#include <Rtypes.h>    // for Int_t, Bool_t, kFALSE, etc
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString
#include <iosfwd>      // for ostream
#include <iostream>    // for operator<<, ostream, cout
#include <set>         // for set
#include <vector>      // for vector

class FairMultiLinkedData : public TObject
{
  public:
    FairMultiLinkedData();                                                                   ///< Default constructor
    FairMultiLinkedData(const std::set<FairLink>& links, Bool_t persistanceCheck = kTRUE);   ///< Constructor
    FairMultiLinkedData(TString dataType,
                        const std::vector<Int_t>& links,
                        Int_t fileId = -1,
                        Int_t evtId = -1,
                        Bool_t persistanceCheck = kTRUE,
                        Bool_t bypass = kFALSE,
                        Float_t mult = 1.0);   ///< Constructor
    FairMultiLinkedData(Int_t dataType,
                        const std::vector<Int_t>& links,
                        Int_t fileId = -1,
                        Int_t evtId = -1,
                        Bool_t persistanceCheck = kTRUE,
                        Bool_t bypass = kFALSE,
                        Float_t mult = 1.0);   ///< Constructor

    virtual ~FairMultiLinkedData(){};

    virtual std::set<FairLink> GetLinks() const { return fLinks; }   ///< returns stored links as FairLinks
    virtual FairLink GetEntryNr() const { return fEntryNr; }         ///< gives back the entryNr
    virtual Int_t GetNLinks() const { return fLinks.size(); }        ///< returns the number of stored links
    virtual FairLink GetLink(Int_t pos) const;                       ///< returns the FairLink at the given position
    virtual FairMultiLinkedData GetLinksWithType(
        Int_t type) const;   ///< Gives you a list of links which contain the given type
    virtual std::vector<FairLink>
        GetSortedMCTracks();   ///< Gives you a list of all FairLinks pointing to a "MCTrack" sorted by their weight
    TObject* GetData(FairLink& myLink);   ///< Get the TObject the Link is pointing to
    virtual Int_t GetDefaultType() { return fDefaultType; }
    Bool_t GetPersistanceCheck() { return fPersistanceCheck; }   ///< Returns the value of PersistanceCheck
    Int_t GetVerbose() { return fVerbose; }                      ///< Returns the verbosity level
    virtual void SetDefaultType(Int_t type) { fDefaultType = type; }
    virtual void SetPersistanceCheck(Bool_t check)
    {
        fPersistanceCheck = check;
    }   ///< Controls if a persistance check of a link is done or not
    virtual void SetVerbose(Int_t level) { fVerbose = level; }   ///< Sets the verbosity level
    virtual void SetInsertHistory(Bool_t val)
    {
        fInsertHistory = val;
    }   ///< Toggles if history of a link is inserted or not
    Bool_t GetInsertHistory() const { return fInsertHistory; }

    virtual void SetEntryNr(FairLink entry) { fEntryNr = entry; }
    virtual void SetLinks(FairMultiLinkedData links, Float_t mult = 1.0);   ///< Sets the links as vector of FairLink
    virtual void SetLink(FairLink link,
                         Bool_t bypass = kFALSE,
                         Float_t mult = 1.0);   ///< Sets the Links with a single FairLink

    virtual void AddLinks(FairMultiLinkedData links,
                          Float_t mult = 1.0);   ///< Adds a List of FairLinks (FairMultiLinkedData) to fLinks
    virtual void AddLink(FairLink link,
                         Bool_t bypass = kFALSE,
                         Float_t mult = 1.0);   ///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link
                                                ///< is allowed more than once otherwise it is stored only once

    virtual void InsertLink(FairLink link);   ///< Inserts a link into the list of links without persistance checking
    virtual void InsertHistory(
        FairLink link);   ///< Adds the FairLinks of the inserted link to the set of links of this object

    virtual void AddAllWeights(Double_t weight);        ///< Adds weight to all Links
    virtual void SetAllWeights(Double_t weight);        ///< Sets a common weight for Links
    virtual void MultiplyAllWeights(Double_t weight);   ///< Multiplies all Links with weight

    virtual Bool_t IsLinkInList(FairLink link)
    {
        return IsLinkInList(link.GetType(), link.GetIndex());
    }   ///< Test if a given link is in fLinks
    virtual Bool_t IsLinkInList(
        Int_t type,
        Int_t index);   ///< Same as IsLinkInList(FairLink) just with type and index given separately
    virtual Int_t LinkPosInList(FairLink link)
    {
        return LinkPosInList(link.GetType(), link.GetIndex());
    }   ///< returns position of link in fLinks. If it is not in the list -1 is returned
    virtual Int_t LinkPosInList(Int_t type, Int_t index);   ///< Same as LinkPosInList(FairLink)

    virtual void DeleteLink(FairLink link)
    {
        DeleteLink(link.GetType(), link.GetIndex());
    }                                                   ///< Deletes a link ouf of fLinks
    virtual void DeleteLink(Int_t type, Int_t index);   ///< Deletes a link ouf of fLinks

    virtual void Reset() { ResetLinks(); }
    virtual void ResetLinks() { fLinks.clear(); }   ///< Clears fLinks

    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const
    {
        out << GetEntryNr() << " -> [";
        for (Int_t i = 0; i < GetNLinks(); i++) {
            GetLink(i).PrintLinkInfo(out);
            out << " ";
        }
        out << "]";
        return out;
    }   ///< Output

    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData& data)
    {
        data.PrintLinkInfo(out);
        return out;
    }   ///< Output

  protected:
    std::set<FairLink> fLinks;
    FairLink fEntryNr;
    Bool_t fPersistanceCheck;   //!
    Bool_t fInsertHistory;      //!
    Int_t fVerbose;             //!

    virtual void SimpleAddLinks(Int_t fileId,
                                Int_t evtId,
                                Int_t dataType,
                                const std::vector<Int_t>& links,
                                Bool_t,
                                Float_t)
    {
        for (UInt_t i = 0; i < links.size(); i++) {
            fLinks.insert(FairLink(fileId, evtId, dataType, links[i]));
        }
    }
    Int_t fDefaultType;

    ClassDef(FairMultiLinkedData, 4);
};

/**\fn virtual void FairMultiLinkedData::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is
 * stored
 */

/**\fn virtual void FairMultiLinkedData::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is
 * stored
 */

#endif /* FAIRMULTILinkedData_H_ */
// -------------------------------------------------------------------------
// -----                 FairPrintFairLinks header file             -----
// -----                  Created 20/03/07  by R.Kliemt               -----
// -------------------------------------------------------------------------

/** FairPrintFairLinks.h
 *@author T.Stockmanns <t.stockmanns@fz-juelich.de>
 **
 ** Prints all FairLinks of a given branch to the screen
 **/

#ifndef FairPrintFairLinks_H
#define FairPrintFairLinks_H

// framework includes
#include "FairTask.h"
#include "TObjString.h"

#include <map>

class TClonesArray;

class FairPrintFairLinks : public FairTask
{
  public:
    /** Default constructor **/
    FairPrintFairLinks();

    /** Destructor **/
    virtual ~FairPrintFairLinks();

    virtual void AddBranchName(const TString& name) { fSelectedBranches->AddLast(new TObjString(name.Data())); }

    virtual void PrintBranchNameList(TList* branches);

    virtual InitStatus Init();

    /** Virtual method Exec **/
    virtual void Exec(Option_t* opt);

    virtual void Finish();

  protected:
    void InitBranchList(TList* branches);

  private:
    std::map<Int_t, TClonesArray*> fBranches;
    TList* fSelectedBranches;

    void Register();
    void Reset();
    void ProduceHits();

    ClassDef(FairPrintFairLinks, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenPoint header file               -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------

/**  FairRadLenPoint.h
 *@author M. Al-Turany
 *
 */

#ifndef FAIRRADLENPOINT_H
#define FAIRRADLENPOINT_H

#include "FairMCPoint.h"   // for FairMCPoint

#include <Rtypes.h>     // for Double_t, Float_t, etc
#include <TVector3.h>   // for TVector3

class FairRadLenPoint : public FairMCPoint
{
  public:
    /** Default constructor **/
    FairRadLenPoint();

    FairRadLenPoint(Int_t trackID,
                    Int_t detID,
                    TVector3 pos,
                    TVector3 mom,
                    Double_t tof,
                    Double_t length,
                    Double_t eLoss,
                    TVector3 posOut,
                    TVector3 momOut,
                    Float_t fA,
                    Float_t fZ,
                    Float_t fDensity,
                    Float_t fRadLen);

    /** Destructor **/
    virtual ~FairRadLenPoint();

    /** Accessors **/
    Float_t GetA() { return fA; }
    Float_t GetZm() { return fZmat; }
    Float_t GetRadLength() { return fRadLen; }
    Float_t GetDensity() { return fDensity; }

    /** Modifiers **/
    void SetA(Double_t A) { fA = A; }
    void SetZm(Double_t Z) { fZmat = Z; }
    void SetRadLength(Double_t length) { fRadLen = length; }
    void SetDensity(Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Double_t GetXOut() const { return fXOut; };
    Double_t GetYOut() const { return fYOut; };
    Double_t GetZOut() const { return fZOut; };

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ); }
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut); }

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut); };
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut, fPyOut, fPzOut); }

  protected:
    Float_t fA;         // A of material
    Float_t fZmat;      // Z of material
    Float_t fDensity;   // density of material
    Float_t fRadLen;    // radiation length

    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;

    ClassDef(FairRadLenPoint, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairRadMapPoint header file               -----
// -------------------------------------------------------------------------

/**  FairRadMapPoint.h
 *@author O.N. Hartmann
 *
 */

#ifndef FAIRRADMAPPOINT_H
#define FAIRRADMAPPOINT_H

#include "FairMCPoint.h"   // for FairMCPoint

#include <Rtypes.h>     // for Double_t, Float_t, Int_t, etc
#include <TVector3.h>   // for TVector3

class FairRadMapPoint : public FairMCPoint
{
  public:
    /** Default constructor **/
    FairRadMapPoint();

    FairRadMapPoint(Int_t trackID,
                    Int_t detID,
                    TVector3 pos,
                    TVector3 mom,
                    Double_t tof,
                    Double_t length,
                    Double_t eLoss,
                    TVector3 posOut,
                    TVector3 momOut,
                    Float_t fA,
                    Float_t fZ,
                    Float_t fDensity,
                    Double_t fVolMass,
                    Double_t fStep,
                    Double_t fDose,
                    Double_t fDoseSL,
                    Int_t fPdg);

    /** Destructor **/
    virtual ~FairRadMapPoint();

    /** Accessors **/
    Float_t GetA() { return fA; }
    Float_t GetZm() { return fZmat; }
    Float_t GetMass() { return fVolMass; }
    Float_t GetDensity() { return fDensity; }

    /** Modifiers **/
    void SetA(Double_t A) { fA = A; }
    void SetZm(Double_t Z) { fZmat = Z; }
    void SetMass(Double_t vmass) { fVolMass = vmass; }
    void SetDensity(Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Int_t GetPdg() const { return fPdg; };

    Double_t GetXOut() const { return fXOut; }
    Double_t GetYOut() const { return fYOut; }
    Double_t GetZOut() const { return fZOut; }

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    Double_t GetDose() const { return fDose; }
    Double_t GetDoseSL() const { return fDoseSL; }

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ); }
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut); }

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut); };
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut, fPyOut, fPzOut); }

  protected:
    // Int_t detID; // detector ID or volume ID
    Int_t fPdg;          // track PID
    Float_t fA;          // A of material
    Float_t fZmat;       // Z of material
    Float_t fDensity;    // density of material
    Double_t fVolMass;   // radiation length

    Double_t fStep, fDose, fDoseSL;
    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;

    ClassDef(FairRadMapPoint, 3);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----          FairRecoEventHeader header file                      -----
// -----          Created 20/09/13                 R.Karabowicz        -----
// -------------------------------------------------------------------------

#ifndef FAIRRECOEVENTHEADER_H
#define FAIRRECOEVENTHEADER_H

#include <TNamed.h>

/**
 *  Event Header Class
 **@author D.Bertini <d.bertini@gsi.de>
 **@author M.Al-Turany <m.al-turany@gsi.de>
 **@author R.Karabowicz <r.karabowicz@gsi.de>
 */
class FairRecoEventHeader : public TNamed
{
  public:
    /** Default constructor */
    FairRecoEventHeader();

    /** Get the run ID for this run*/
    UInt_t GetRunId() const { return fRunId; }

    /** Get the MC time for this event*/
    Double_t GetEventTime() const { return fEventTime; }

    /** Get the error of MC time for this event*/
    Double_t GetEventTimeError() const { return fEventTimeError; }

    /** Get identifier*/
    Int_t GetIdentifier() const { return fIdentifier; }

    /** Set the run ID for this run
     * @param runid : unique run id
     */
    void SetRunId(UInt_t runid) { fRunId = runid; }

    /** Set the MC time for this event
     * @param time : time in ns
     * @param terr : time error in ns
     */
    void SetEventTime(Double_t time, Double_t terr)
    {
        fEventTime = time;
        fEventTimeError = terr;
    }

    /** Set the run ID for this run
     * @param ident : identifier
     */
    void SetIdentifier(Int_t ident) { fIdentifier = ident; }

    virtual bool operator<(const FairRecoEventHeader& tempObj) const
    {
        if (fEventTime < tempObj.GetEventTime()) {
            return true;
        } else if (fEventTime > tempObj.GetEventTime()) {
            return false;
        }
        return false;
    }

    virtual bool operator>(const FairRecoEventHeader& tempObj) const
    {
        if (fEventTime > tempObj.GetEventTime()) {
            return true;
        } else if (fEventTime < tempObj.GetEventTime()) {
            return false;
        }
        return false;
    }

    virtual bool operator==(const FairRecoEventHeader& tempObj) const { return fEventTime == tempObj.GetEventTime(); }

    /**
     * Destructor
     */
    virtual ~FairRecoEventHeader();

  protected:
    /** Run Id */
    UInt_t fRunId;
    /** Identifier */
    Int_t fIdentifier;
    /** Event Time **/
    Double_t fEventTime;
    /** Event Time Error **/
    Double_t fEventTimeError;

    ClassDef(FairRecoEventHeader, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNINFO_H
#define FAIRRUNINFO_H

#include <Rtypes.h>       // for Double_t, Long_t, etc
#include <TObject.h>      // for TObject
#include <TSystem.h>      // for CpuInfo_t, MemInfo_t, etc
#include <TTimeStamp.h>   // for TTimeStamp
#include <vector>         // for vector

class TList;

class FairRunInfo : public TObject
{
  public:
    FairRunInfo();
    ~FairRunInfo();

    void StoreInfo();
    void WriteInfo();
    void Reset();

  private:
    TTimeStamp fTimeStamp;                 //!
    CpuInfo_t fCpuInfo;                    //!
    MemInfo_t fMemInfo;                    //!
    ProcInfo_t fProcInfo;                  //!
    std::vector<Double_t> fTimeDiff;       //!
    std::vector<Double_t> fTime;           //!
    std::vector<Long_t> fResidentMemory;   //!
    std::vector<Long_t> fVirtualMemory;    //!

    void CalculateTimeDifference();
    void PrintInfo();
    void GetInfo();
    void CreateAndFillHistograms(TList* histoList);
    void WriteHistosToFile(TList* histoList);

    FairRunInfo(const FairRunInfo&);
    FairRunInfo& operator=(const FairRunInfo&);

    ClassDef(FairRunInfo, 2);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRTIMESTAMP_H
#define FAIRTIMESTAMP_H

#include "FairMultiLinkedData_Interface.h"   // for FairMultiLinkedData

#include <Rtypes.h>   // for Double_t, etc
#include <iosfwd>     // for ostream
#include <iostream>   // for ostream, cout

class TObject;

/**
 * Base class for Time stamp information
 ** Aug. 2010
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairTimeStamp : public FairMultiLinkedData_Interface
{
  public:
    /** Default constructor **/
    FairTimeStamp();
    /** Constructor with time **/
    FairTimeStamp(Double_t time);
    /** Constructor with time and time error **/
    FairTimeStamp(Double_t time, Double_t timeerror);

    /** Destructor **/
    virtual ~FairTimeStamp(){};
    /** Accessors **/
    Double_t GetTimeStamp() const { return fTimeStamp; }
    Double_t GetTimeStampError() const { return fTimeStampError; }
    /** Modifiers **/
    void SetTimeStamp(Double_t t) { fTimeStamp = t; }
    void SetTimeStampError(Double_t t) { fTimeStampError = t; }
    virtual Int_t Compare(const TObject* obj) const
    {
        if (this == obj) {
            return 0;
        }
        FairTimeStamp* tsobj = static_cast<FairTimeStamp*>(const_cast<TObject*>(obj));
        Double_t ts = tsobj->GetTimeStamp();
        Double_t tserror = tsobj->GetTimeStampError();
        if (fTimeStamp < ts) {
            return -1;
        } else if (fTimeStamp == ts && fTimeStampError < tserror) {
            return -1;
        } else if (fTimeStamp == ts && fTimeStampError == tserror) {
            return 0;
        } else {
            return 1;
        }
    }

    virtual std::ostream& PrintTimeInfo(std::ostream& out = std::cout) const;
    virtual Bool_t IsSortable() const { return kTRUE; };

    virtual bool equal(FairTimeStamp* data)
    {
        return (fTimeStamp == data->GetTimeStamp() && fTimeStampError == data->GetTimeStampError());
    }

    friend std::ostream& operator<<(std::ostream& out, const FairTimeStamp& link)
    {
        link.PrintTimeInfo(out);
        return out;
    }

    virtual bool operator<(const FairTimeStamp* rValue) const { return GetTimeStamp() < rValue->GetTimeStamp(); }

  protected:
    Double_t fTimeStamp;      /** Time of digit or Hit  [ns] */
    Double_t fTimeStampError; /** Error on time stamp */

    ClassDef(FairTimeStamp, 4);
};

// -----   Default constructor   -------------------------------------------
inline FairTimeStamp::FairTimeStamp()
    : FairMultiLinkedData_Interface()
    , fTimeStamp(-1)
    , fTimeStampError(-1)
{}

// -----   Standard constructor   ------------------------------------------
inline FairTimeStamp::FairTimeStamp(Double_t time)
    : FairMultiLinkedData_Interface()
    , fTimeStamp(time)
    , fTimeStampError(-1)
{}

inline FairTimeStamp::FairTimeStamp(Double_t time, Double_t timeerror)
    : FairMultiLinkedData_Interface()
    , fTimeStamp(time)
    , fTimeStampError(timeerror)
{}

#endif   // FAIRTIMESTAMP_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairTrackParam header file                 -----
// -----                  Created 27/01/05  by V. Friese               -----
// -------------------------------------------------------------------------

/**  FairTrackParam.h
 *@author V.Friese <v.friese@gsi.de>
 **
 ** Parameters (x, y, tx, ty, q/p) of a track
 ** resulting from the track fit. The z coordinate is not a parameter.
 ** The 5x5 covariance matrix can be set and accessed by either an array
 ** of size 15, the TMatrixFSym class or elementwise. Note that TMatrixFSym
 ** should not be used when performance is an issue.
 ** The internal representation of the covariance matrix elements is
 ** an array of double.
 **/

#ifndef FAIRSTSTRACKPARAM
#define FAIRSTSTRACKPARAM 1

#include <Rtypes.h>           // for Double_t, Double32_t, Int_t, etc
#include <TMatrixFSymfwd.h>   // for TMatrixFSym
#include <TObject.h>          // for TObject
#include <TVector3.h>         // for TVector3

class FairTrackParam : public TObject
{
  public:
    /** Constructor **/
    FairTrackParam();

    /** Constructor with all variables **/
    FairTrackParam(Double_t x,
                   Double_t y,
                   Double_t z,
                   Double_t tx,
                   Double_t ty,
                   Double_t qp,
                   const TMatrixFSym& covMat);

    /** Copy constructor **/
    FairTrackParam(const FairTrackParam& param);

    /** Destructor **/
    virtual ~FairTrackParam();

    /** Output to screen **/
    void Print(Option_t* option = "") const;

    /** Accessors **/
    Double_t GetX() const { return fX; };
    Double_t GetY() const { return fY; };
    Double_t GetZ() const { return fZ; };
    Double_t GetTx() const { return fTx; };
    Double_t GetTy() const { return fTy; };
    Double_t GetQp() const { return fQp; };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); };
    void Momentum(TVector3& mom) const;
    void CovMatrix(Double_t cov[]) const;
    void CovMatrix(TMatrixFSym& covMat) const;
    Double_t GetCovariance(Int_t i, Int_t j) const;

    /** Modifiers **/
    void SetX(Double_t x) { fX = x; };
    void SetY(Double_t y) { fY = y; };
    void SetZ(Double_t z) { fZ = z; };
    void SetTx(Double_t tx) { fTx = tx; };
    void SetTy(Double_t ty) { fTy = ty; };
    void SetQp(Double_t qp) { fQp = qp; };
    void SetPosition(const TVector3& pos);
    void SetCovMatrix(Double_t cov[]);
    void SetCovMatrix(const TMatrixFSym& covMat);
    void SetCovariance(Int_t i, Int_t j, Double_t val);

    /** Assignment operator  **/
    FairTrackParam& operator=(const FairTrackParam& par);

  private:
    /** Position of track at given z [cm] **/
    Double32_t fX, fY, fZ;

    /** Direction of track tx = dx/dz; ty = dy/dz **/
    Double32_t fTx, fTy;

    /** Charge over momentum [1/GeV] **/
    Double32_t fQp;

    /** Covariance matrix for the variables x, y, tx, ty, q/p
     ** The 15 elements of the upper triangle of the symmetric matrix
     ** are stored in an array of floats. The sequence of the array is
     ** a[0,0..4], a[1,1..4], a[2,2..4], a[3,3..4], a[4,4].
     **/

    Double32_t fCovMatrix[15];

    ClassDef(FairTrackParam, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairField header file                     -----
// -----                Created 06/01/04  by M. Al-Turany              -----
// -----                Redesign 13/02/06  by V. Friese                -----
// -----                Redesign 04/08/06  by M. Al-Turany               -----
// -------------------------------------------------------------------------

/** FairField.h
 ** @author M.Al-Turany <m.al/turany@gsi.de>
 ** @author V.Friese <v.friese@gsi.de>
 ** @since 06.01.2004
 ** @version 1.0
 **
 ** Abstract base class for magnetic fields in FAIR
 ** Concrete field should implement the pure virtual methods
 ** GetBx, GetBy and GetBz and/or  GetBxyz
 **
 ** Note: Field values should be returned in kG (thanks to Geant3)
 **/

#ifndef FAIRFIELD_H
#define FAIRFIELD_H 1

#include "FairLogger.h"

#include <Rtypes.h>   // for Double_t, Bool_t, etc
#include <TVirtualMagField.h>

class FairField : public TVirtualMagField
{
  public:
    /** Default constructor **/
    FairField();

    /** Constructor with name and title **/
    FairField(const char* name, const char* title = "FAIR Magnetic Field");

    FairField& operator=(const FairField&) { return *this; }

    /** Destructor **/
    virtual ~FairField();

    /** Intialisation. E.g. read in the field map. If needed, to be
     ** implemented in the concrete class.
     **/
    virtual void Init(){};

    /** Test whether field type is Constant **/
    Bool_t IsConst();

    /** Test whether field typ is Map **/
    Bool_t IsMap();

    /** Field type ( 0=constant, 1=map, 2=map sym2, 3 = map sym3 ) **/
    Int_t GetType() const { return fType; }

    /** Get x component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBx([[maybe_unused]] Double_t x, [[maybe_unused]] Double_t y, [[maybe_unused]] Double_t z)
    {
        LOG(warn) << "FairField::GetBx Should be implemented in User class";
        return 0;
    }

    /** Get y component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBy([[maybe_unused]] Double_t x, [[maybe_unused]] Double_t y, [[maybe_unused]] Double_t z)
    {
        LOG(warn) << "FairField::GetBy Should be implemented in User class";
        return 0;
    }

    /** Get z component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBz([[maybe_unused]] Double_t x, [[maybe_unused]] Double_t y, [[maybe_unused]] Double_t z)
    {
        LOG(warn) << "FairField::GetBz Should be implemented in User class";
        return 0;
    }

    /** Get magnetic field. For use of Geant3
     ** @param point            Coordinates [cm]
     ** @param bField (return)  Field components [kG]
     **/
    virtual void GetFieldValue(const Double_t point[3], Double_t* bField);

    void Field(const Double_t point[3], Double_t* B) { GetFieldValue(point, B); }

    /** Screen output. To be implemented in the concrete class. **/
    virtual void Print(Option_t*) const { ; }
    virtual void GetBxyz(const Double_t[3], Double_t*)
    {
        LOG(warn) << "FairField::GetBxyz Should be implemented in User class";
    }

    /**Fill Paramater*/
    virtual void FillParContainer() { LOG(warn) << "FairField::FillParContainer Should be implemented in User class"; }

  protected:
    /** Field type. 1 = constant field, 2 = field map. **/
    Int_t fType;

  private:
    FairField(const FairField&);
    //    FairField& operator=(const FairField&);
    // TODO: Check why the htrack needs this

    ClassDef(FairField, 4);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairFieldFactory header file                  -----
// -----                Created 15/01/07  by M. Al-Turany              -----
// -------------------------------------------------------------------------

#ifndef FAIRFIELDFACTORY_H
#define FAIRFIELDFACTORY_H

#include <Rtypes.h>   // for FairFieldFactory::Class, etc

class FairField;

class FairFieldFactory
{
  public:
    static FairFieldFactory* Instance();
    FairFieldFactory();
    virtual ~FairFieldFactory();
    virtual FairField* createFairField() = 0;
    virtual void SetParm() {}

  protected:
    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] FairFieldFactory* fCreator;
    static FairFieldFactory* fgRinstance;

    ClassDef(FairFieldFactory, 1);

  private:
    FairFieldFactory(const FairFieldFactory& M);
    FairFieldFactory& operator=(const FairFieldFactory&) { return *this; }
};

#endif   // FAIRFIELDFACTORY_H
/********************************************************************************
 * Copyright (C) 2014-2023 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASECONTFACT_H
#define FAIRBASECONTFACT_H

#include "FairContFact.h"   // for FairContFact, etc

#include <Rtypes.h>   // for FairBaseContFact::Class, etc

class FairParSet;

class FairBaseContFact : public FairContFact
{
    /** Factory for all Base parameter containers */
  public:
    /**default ctor*/
    FairBaseContFact();
    /**default dtor*/
    ~FairBaseContFact() override {}
    /** Calls the constructor of the corresponding parameter container.
     * For an actual context, which is not an empty string and not the default context
     * of this container, the name is concatinated with the context. */
    FairParSet* createContainer(FairContainer*) override;
    ClassDefOverride(FairBaseContFact, 0);
};

#endif /* !FAIRBASECONTFACT_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASEPARSET_H
#define FAIRBASEPARSET_H

/**
 * Parameter class for run
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"   // for FairParGenericSet

#include <Rtypes.h>        // for Double_t, etc
#include <TGeoManager.h>   // IWYU pragma: keep needed by cint

class FairParamList;
class FairPrimaryGenerator;
class TObjArray;

class FairBaseParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
     * @param title:  Parameter set title
     * @param context:  Parameter set context
     */

    FairBaseParSet(const char* name = "FairBaseParSet",
                   const char* title = "Class for base parameter io",
                   const char* context = "BaseDefaultContext");
    /** dtor*/
    ~FairBaseParSet() override;
    /** clear*/
    void clear() override;
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
     */
    void putParams(FairParamList*) override;
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*) override;
    /**
     * Set the detector list used in the simulation
     * @param array: TObjArray of detector
     */
    void SetDetList(TObjArray* array) { fDetList = array; }
    /**
     * Set the Generator used in the simulation
     * @param gen: Primary generator used in simulation
     */
    void SetGen(FairPrimaryGenerator* gen) { fPriGen = gen; }
    /**
     * Set the beam momentum (if any) used in the simulation
     * @param BMom: Beam Momentum in GeV/c
     */
    void SetBeamMom(Double_t BMom) { fBeamMom = BMom; }
    /**
     * Set the list of parameter containers used in a run
     * @param array: TObjArray of containers
     */
    void SetContListStr(TObjArray* list) { fContNameList = list; }
    /**
     * Set the random seed used in a run
     * @param RndSeed: Random Seed
     */
    void SetRndSeed(UInt_t RndSeed) { fRandomSeed = RndSeed; }
    /**
     *  Get the detector list used in the simulation
     */
    TObjArray* GetDetList() { return fDetList; }
    /**
     *  Get the Primery generator used in the simulation
     */
    FairPrimaryGenerator* GetPriGen() { return fPriGen; }
    /**
     *  Get the Beam Momentum used in the simulation (GeV/c)
     */
    Double_t GetBeamMom() { return fBeamMom; }
    /**
     *  Get the parameter container list used in this run
     */
    TObjArray* GetContList() { return fContNameList; }
    /**
     *  Get the Random Seed used in this run
     */
    UInt_t GetRndSeed() { return fRandomSeed; }

  protected:
    /// Detectors used in the simulation
    TObjArray* fDetList;
    /// Generator used for simulation
    FairPrimaryGenerator* fPriGen;
    /// Beam momentum (GeV/c)
    Double_t fBeamMom;
    /// List of parameter container names in the RUN
    TObjArray* fContNameList;
    /// Random Seed from gRandom
    UInt_t fRandomSeed;

    ClassDefOverride(FairBaseParSet, 6);

  private:
    FairBaseParSet(const FairBaseParSet& L);
    FairBaseParSet& operator=(const FairBaseParSet&) { return *this; }
};

#endif /* !FAIRBASEPARSET_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETECTOR_H
#define FAIRDETECTOR_H

#include "FairModule.h"   // for FairModule

#include <Rtypes.h>   // for Int_t, Bool_t, etc

class FairLogger;
class FairVolume;
class TClonesArray;

/**
 * Base class for constructing detecors
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairDetector : public FairModule
{
  public:
    /**
      constructor
      Name :  Detector Name
      Active: kTRUE for active detectors  (ProcessHits() will be called)
              kFALSE for inactive detectors
    */
    FairDetector(const char* Name, Bool_t Active, Int_t DetId = 0);
    /**
      default constructor
    */
    FairDetector();
    /**
      destructor
    */
    virtual ~FairDetector();
    /**
      Initialization of the detector is done here
    */
    virtual void Initialize();
    /**
      this method is called for each step during simulation (see FairMCApplication::Stepping())
    */
    virtual Bool_t ProcessHits(FairVolume* v = 0) = 0;
    /**
      this is called at the end of an event after the call to tree fill in the FairRootManager
    */
    virtual void EndOfEvent() {}
    /**
      Registers the produced collections in FAIRRootManager.
    */
    virtual void Register() = 0;

    /**
     Gets the produced collections
    */
    virtual TClonesArray* GetCollection(Int_t iColl) const = 0;
    /**
      has to be called after each event to reset the containers
    */
    virtual void Reset() = 0;

    virtual void CopyClones(TClonesArray*, TClonesArray*, Int_t) {}
    /**
     User actions after finishing of a primary track
    */
    virtual void FinishPrimary() {}
    /**
     Finish MC Run
    */
    virtual void FinishRun() {}
    /**
     User actions at beginning of a primary track
    */
    virtual void BeginPrimary() {}
    /**
     User actions after finishing of each track
    */
    virtual void PostTrack() {}
    /**
     User actions at beginning of each track
    */
    virtual void PreTrack() {}
    /**
     User actions at beginning of event
    */
    virtual void BeginEvent() {}
    /**
     this is called at the end of an event before the call to tree fill in the FairRootManager
    */
    virtual void FinishEvent() {}

    void SaveGeoParams();
    Int_t GetDetId() { return fDetId; }

  protected:
    /** Copy constructor */
    FairDetector(const FairDetector&);
    /** Assignment operator */
    FairDetector& operator=(const FairDetector&);

    void DefineSensitiveVolumes();

    Int_t fDetId;          // Detector Id has to be set from ctr.
    FairLogger* fLogger;   //! /// FairLogger

    ClassDef(FairDetector, 1);
};
#endif   // FAIRDETECTOR_H
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairGeaneApplication header file                   -----
// -----            Created 10/11/10  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_GEANE_APPLICATION_H
#define FAIR_GEANE_APPLICATION_H

#include <Rtypes.h>                  // for Bool_t, etc
#include <TLorentzVector.h>          // for TLorentzVector
#include <TVirtualMCApplication.h>   // for TVirtualMCApplication

class FairField;

/**
 * The Main Application for GEANE
 * @author M. Al-Turany
 * @version 0.1
 * @since 10.11.10
 */

class FairGeaneApplication : public TVirtualMCApplication
{
  public:
    /** default constructor */
    FairGeaneApplication();
    /** Special constructor, used for initializing G3 for Geane track propagation
     *@param Debug    true to print step info*/
    FairGeaneApplication(Bool_t Debug);
    /** default destructor */
    ~FairGeaneApplication() override;
    /** Return Field used in simulation*/
    FairField* GetField() { return fxField; }
    /** Initialize MC engine */
    void InitMC(const char* setup, const char* cuts);
    /**
     * Set the magnetic field for simulation or Geane
     * @param field: magnetic field
     */
    void SetField(FairField* field);
    /** Define action at each step, dispatch the action to the corresponding detectors */
    void GeaneStepping() override;   // MC Application
    void ConstructGeometry() override;
    /**
     * Singelton instance
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] static FairGeaneApplication* Instance()
    {
        return static_cast<FairGeaneApplication*>(TVirtualMCApplication::Instance());
    }

    /**pure virtual functions that hasve to be implimented */

    void InitGeometry() override { ; }
    void GeneratePrimaries() override { ; }
    void BeginEvent() override { ; }
    void BeginPrimary() override { ; }
    void PreTrack() override { ; }
    void PostTrack() override { ; }
    void FinishPrimary() override { ; }
    void FinishEvent() override { ; }
    void Stepping() override { ; }
    void StopRun() { ; }

  private:
    // data members
    /**Magnetic Field Pointer*/
    FairField* fxField;   //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t fMcVersion;   // mc Version
    /** Debug flag*/
    Bool_t fDebug;            //!
    TLorentzVector fTrkPos;   //!

    // Interface to MonteCarlo application
    ClassDefOverride(FairGeaneApplication, 1);

  private:
    FairGeaneApplication(const FairGeaneApplication&);
    FairGeaneApplication& operator=(const FairGeaneApplication&);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairGenerator header file                   -----
// -----          Created 09/06/04  by D. Bertini / V. Friese          -----
// -------------------------------------------------------------------------

/** FairGenerator.h
 *@author D.Bertini <d.bertini@gsi.de>
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairGenerator is the abtract base class for the generators used to
generate input for the transport simulation.Each concrete generator class
derived from this one must implement the abtract method ReadEvent,
which has to use the method FairPrimaryGenerator::AddTrack.
**/

#ifndef FAIRGENERATOR_H
#define FAIRGENERATOR_H

#include <Rtypes.h>   // for Bool_t, etc
#include <TNamed.h>   // for TNamed

class FairPrimaryGenerator;

class FairGenerator : public TNamed
{
  public:
    /** Default constructor. **/
    FairGenerator();

    /** Constructor with name and title **/
    FairGenerator(const char* name, const char* title = "FAIR Generator");

    /** Destructor. **/
    virtual ~FairGenerator();

    /** Abstract method ReadEvent must be implemented by any derived class.
        It has to handle the generation of input tracks (reading from input
        file) and the handing of the tracks to the FairPrimaryGenerator. I
        t is called from FairMCApplication.
        *@param pStack The stack
        *@return kTRUE if successful, kFALSE if not
    **/
    virtual Bool_t ReadEvent(FairPrimaryGenerator* primGen) = 0;

    /**Initialize the generator if needed */
    virtual Bool_t Init() { return kTRUE; }

    /**Finalize the generator if needed */
    virtual void Finish() { return; }

    /** Clone this object (used in MT mode only) */
    virtual FairGenerator* CloneGenerator() const;

  protected:
    /** Copy constructor */
    FairGenerator(const FairGenerator&);
    /** Assignment operator */
    FairGenerator& operator=(const FairGenerator&);

    ClassDef(FairGenerator, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairGenericStack header file            -----
// -----           Created 10/08/04  by D. Bertini                     -----
// -------------------------------------------------------------------------

/** FairGenericStack.h
 *@author D.Bertini <d.bertini@gsi.de>
 * Generic MC stack class
 **/

#ifndef FAIRGENERICSTACK_H
#define FAIRGENERICSTACK_H

#include <Rtypes.h>   // for Double_t, Int_t, etc
#include <TClonesArray.h>
#include <TMCProcess.h>        // for TMCProcess
#include <TVirtualMCStack.h>   // for TVirtualMCStack
#include <map>
#include <tuple>

class FairLogger;
class TParticle;
class TRefArray;
class TIterator;

class FairGenericStack : public TVirtualMCStack
{
  public:
    /** Default constructor  **/
    FairGenericStack();

    /** Destructor with estimated array size  **/
    FairGenericStack(Int_t size);

    /** Destructor  **/
    virtual ~FairGenericStack();

    /** Virtual method PushTrack.
     ** Add a TParticle to the stack.
     ** This function has an extra argument wrt to the function defined in the base class.
     *@param toBeDone         Flag for tracking
     *@param parentID         Index of mother particle
     *@param pdgCode          Particle type (PDG encoding)
     *@param px,py,pz         Momentum components at start vertex [GeV]
     *@param e                Total energy at start vertex [GeV]
     *@param vx,vy,vz         Coordinates of start vertex [cm]
     *@param time             Start time of track [s]
     *@param polx,poly,polz   Polarisation vector
     *@param proc             Production mechanism (VMC encoding)
     *@param ntr              Track number (filled by the stack)
     *@param weight           Particle weight
     *@param is               Generation status code (whatever that means)
     *@param secondparentID   used fot the index of mother of primery in the list
     **/
    virtual void PushTrack(Int_t toBeDone,
                           Int_t parentID,
                           Int_t pdgCode,
                           Double_t px,
                           Double_t py,
                           Double_t pz,
                           Double_t e,
                           Double_t vx,
                           Double_t vy,
                           Double_t vz,
                           Double_t time,
                           Double_t polx,
                           Double_t poly,
                           Double_t polz,
                           TMCProcess proc,
                           Int_t& ntr,
                           Double_t weight,
                           Int_t is,
                           Int_t secondparentID) = 0;

    /** Fill the MCTrack output array, applying filter criteria **/
    virtual void FillTrackArray() {}

    /** Update the track index in the MCTracks and MCPoints **/
    virtual void UpdateTrackIndex(TRefArray* /* detArray=0 */) {}

    /** Set the list of detectors to be used for filltering the stack*/
    void SetDetArrayList(TRefArray* detArray);

    /** Allow a stack to perform a clean-up after a primary particle is finished **/
    virtual void FinishPrimary() {}

    /** Resets arrays and stack and deletes particles and tracks **/
    virtual void Reset() {}

    /** Register the MCTrack array to the Root Manager  **/
    virtual void Register() {}

    virtual TClonesArray* GetListOfParticles() { return 0; }
    virtual void SetParticleArray(__attribute__((unused)) TClonesArray* partArray) {}
    virtual void SetParticleArray(__attribute__((unused)) TClonesArray* partArray,
                                  __attribute__((unused)) Int_t partFrom,
                                  __attribute__((unused)) Int_t partTo)
    {}

    /** Clone this object (used in MT mode only) */
    virtual FairGenericStack* CloneStack() const;

    /** Fast simulation function to move particle to different position.
        In Geant3 it stops the current trajectory, and starts it again in the position given by the user.
        In Geant4 the FastSimulationModel with take over.
        Later, the points are reindexed and the thus created tracks are not stored in the output.
     *@param xx,yy,zz    new position    of the particle
     *@param tt          new proper time of the particle
     *@param px,py,pz    new momentum    of the particle
     *@param en          new energy      of the particle
     **/
    virtual void FastSimMoveParticleTo(Double_t xx,
                                       Double_t yy,
                                       Double_t zz,
                                       Double_t tt,
                                       Double_t px,
                                       Double_t py,
                                       Double_t pz,
                                       Double_t en);
    /** Fast simulation function to stop original particle. **/
    virtual void FastSimStopParticle();
    /** Fast simulation function to generate secondaries.
     *@param xx,yy,zz    position    of the particle
     *@param tt          proper time of the particle
     *@param px,py,pz    momentum    of the particle
     *@param en          energy      of the particle
     **/
    virtual void FastSimPushSecondary(Int_t parentID,
                                      Int_t pdgCode,
                                      Double_t xx,
                                      Double_t yy,
                                      Double_t zz,
                                      Double_t tt,
                                      Double_t px,
                                      Double_t py,
                                      Double_t pz,
                                      Double_t en,
                                      Double_t polx,
                                      Double_t poly,
                                      Double_t polz,
                                      TMCProcess proc,
                                      Double_t weight,
                                      Int_t is);
    /** Allow FairFastSim the retrieval of moved particle position, p1 and p2 to get secondaries **/
    virtual std::tuple<Int_t, Int_t, Int_t> FastSimGetMovedIndex()
    {
        return std::make_tuple(fFSMovedIndex, fFSFirstSecondary, fFSNofSecondaries);
    }
    virtual void FastSimClearMovedIndex()
    {
        fFSMovedIndex = -2;
        fFSFirstSecondary = -2;
        fFSNofSecondaries = 0;
    }

    template<typename T>
    void FastSimUpdateTrackIndex(T* point, Int_t& iTrack);

  protected:
    /** Copy constructor */
    FairGenericStack(const FairGenericStack&);
    /** Assignment operator */
    FairGenericStack& operator=(const FairGenericStack&);

    /** Fair Logger */
    FairLogger* fLogger;   //!

    /** List of detectors registering hits in the simulation */
    TRefArray* fDetList;   //!

    /** Iterator for the detector list*/
    TIterator* fDetIter;

    /**Verbosity level*/
    Int_t fVerbose;

    /** FastSimulation: STL map from new track index to original track index  **/
    std::map<Int_t, Int_t> fFSTrackMap;              //!
    std::map<Int_t, Int_t>::iterator fFSTrackIter;   //!
    Int_t fFSMovedIndex;                             //!
    Int_t fFSFirstSecondary;                         //!
    Int_t fFSNofSecondaries;                         //!

    ClassDef(FairGenericStack, 1);
};

template<typename T>
void FairGenericStack::FastSimUpdateTrackIndex(T* point, Int_t& iTrack)
{
    fFSTrackIter = fFSTrackMap.find(iTrack);   // check if point created by FastSimulation
    if (fFSTrackIter != fFSTrackMap.end()) {   // indeed the point has been created by the FastSimulation mechanism
        iTrack = fFSTrackIter->second;
        point->SetTrackID(iTrack);   // set proper TrackID
    }
}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairGenericVMCConfig header file                -----
// -----            Created 2019.02.19 by R. Karabowicz                -----
// -------------------------------------------------------------------------

#include <string>   // for string

#ifndef FAIR_GENERIC_VMC_CONFIG_H
#define FAIR_GENERIC_VMC_CONFIG_H

class FairGenericVMCConfig
{
  public:
    FairGenericVMCConfig();
    virtual ~FairGenericVMCConfig();

    virtual void Setup(const char* mcEngine);
    virtual void SetupPostInit(const char* mcEngine);

    virtual void UsePostInitConfig(bool useC = true, const char* stringC = "g4ConfigPostInit.C")
    {
        fPostInitFlag = useC;
        fPostInitName = stringC;
    }

  protected:
    bool fPostInitFlag;
    std::string fPostInitName;
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairGeoParSet_H
#define FairGeoParSet_H

/**
 * Parameter class for Geometry stuff
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"   // for FairParGenericSet

#include <Rtypes.h>        // for Double_t, etc
#include <TGeoManager.h>   // IWYU pragma: keep needed by cint

class FairParamList;
class TObjArray;

class FairGeoParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
     * @param title:  Parameter set title
     * @param context:  Parameter set context
     */

    FairGeoParSet(const char* name = "FairGeoParSet",
                  const char* title = "Class for base parameter io",
                  const char* context = "BaseDefaultContext");
    /** dtor*/
    ~FairGeoParSet() override;
    /** clear*/
    void clear() override;
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
     */
    void putParams(FairParamList*) override;
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*) override;
    /**
     * Set the Geometry node list used in the simulation
     * @param array: TObjArray of Geometry nodes
     */
    void SetGeoNodes(TObjArray* array) { fGeoNodes = array; }
    /**
     * Set the Geometry (TGeoManager) used in the simulation
     * @param Geom: TGeoManager of the full geometry
     */
    void SetGeometry(TGeoManager* Geom) { fGeom = Geom; }
    /**
     *  Get the Geometry Nodes list used in the simulation
     */
    TObjArray* GetGeoNodes() { return fGeoNodes; }
    /**
     *  Get the geometry (TGeoManager) used in the simulation
     */
    TGeoManager* GetGeometry() { return fGeom; }

  protected:
    /// List of FairGeoNodes for sensitive volumes
    TObjArray* fGeoNodes;   //!
    /// Full Geometry
    TGeoManager* fGeom;
    ClassDefOverride(FairGeoParSet, 1);

  private:
    FairGeoParSet(const FairGeoParSet& L);
    FairGeoParSet& operator=(const FairGeoParSet&) { return *this; }
};

#endif /* !FairGeoParSet_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairIon header file                      -----
// -----          Created 27/08/04  by V. Friese / D.Bertini           -----
// -------------------------------------------------------------------------

/** FairIon.h
 *@author V.Friese <v.friese@gsi.de>
 *@author D.Bertini <d.bertini@gsi.de>
 **
 ** A class for the user definition of an ion. It will be instantiated
 ** from the constructor of the FairIonGenerator.
 **/

#ifndef FAIRION_H
#define FAIRION_H

#include <Rtypes.h>   // for Int_t, Double_t, etc
#include <TNamed.h>   // for TNamed

class FairLogger;

class FairIon : public TNamed
{
  public:
    /** Default constructor **/
    FairIon();

    /** Standard constructor
     *@param name  name
     *@param z     atomic number
     *@param a     atomic mass
     *@param q     electric charge
     *@param e     excitation energy
     *@param m     mass [GeV]
     ** If mass is not given, it will be set to a times the proton mass.
     **/

    FairIon(const char* name, Int_t z, Int_t a, Int_t q, Double_t e = 0., Double_t m = 0.);
    void SetParams(const char* name, Int_t z, Int_t a, Int_t q, Double_t e = 0., Double_t m = 0.)
    {
        SetName(name);
        fZ = z;
        fA = a;
        fQ = q;
        fExcEnergy = e;
        fMass = m;
    }
    /** Destructor **/
    virtual ~FairIon();

    /** Accessors **/
    /**
     * Return the atomic number
     */
    Int_t GetZ() const { return fZ; }
    /**
     * Return the atomic mass
     */
    Int_t GetA() const { return fA; }
    /**
     * Return the charge
     */
    Int_t GetQ() const { return fQ; }
    /**
     * Return the  excitation energy
     */
    Double_t GetExcEnergy() const { return fExcEnergy; }
    /**
     * Return the mass in GeV
     */
    Double_t GetMass() const { return fMass; }

    /** Modifiers **/
    /**
     * Set the  excitation energy
     */
    void SetExcEnergy(Double_t eExc) { fExcEnergy = eExc; }
    /**
     * Set the atomic mass, use SetMass to set the mass of the ion
     */
    void SetA(Int_t a) { fA = a; }
    /**
     * Set the mass in GeV
     */
    void SetMass(Double_t mass) { fMass = mass; }

  private:
    static Int_t fgNIon;         //! /// Number of ions instantiated. One per generator.
    Int_t fZ;                    /// Atomic number
    Int_t fA;                    /// Atomic mass
    Int_t fQ;                    /// Electric charge
    Double_t fExcEnergy;         /// Excitation energy [GeV]
    Double_t fMass;              /// Mass [GeV]
    FairLogger* fLogger;         //! /// FairLogger

    FairIon(const FairIon&);
    FairIon& operator=(const FairIon&);

    ClassDef(FairIon, 2);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairMCApplication header file                   -----
// -----            Created 06/01/04  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_MC_APPLICATION_H
#define FAIR_MC_APPLICATION_H

#include "FairRadGridManager.h"
#include "FairRunInfo.h"   // for FairRunInfo

#include <Rtypes.h>                  // for Int_t, Bool_t, Double_t, etc
#include <TLorentzVector.h>          // for TLorentzVector
#include <TString.h>                 // for TString
#include <TVirtualMCApplication.h>   // for TVirtualMCApplication
#include <list>                      // for list
#include <map>                       // for map, multimap, etc
#include <memory>                    // for std::unique_ptr

class FairDetector;
class FairEventHeader;
class FairField;
class FairGenericStack;
class FairMCEventHeader;
class FairPrimaryGenerator;
class FairRadLenManager;
class FairRadMapManager;
class FairRootManager;
class FairTask;
class FairTrajFilter;
class FairVolume;
class FairRunSim;
class TChain;
class TIterator;
class TObjArray;
class TRefArray;
class TTask;
class TVirtualMC;

enum class FairMCApplicationState { kUnknownState, kConstructGeometry, kInitGeometry };

/**
 * The Main Application ( Interface to MonteCarlo application )
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairMCApplication : public TVirtualMCApplication
{
  public:
    /** Standard constructor
     *@param name      name
     *@param title     title
     *@param ModList  a TObjArray containing all detectors and modules used in this simulation
     *@param MatName  material file name
     */
    FairMCApplication(const char* name, const char* title, TObjArray* ModList, const char* MatName);
    /** default constructor
     */
    FairMCApplication();

    FairMCApplication(const FairMCApplication&) = delete;
    FairMCApplication& operator=(const FairMCApplication&) = delete;
    FairMCApplication(FairMCApplication&&) = delete;
    FairMCApplication& operator=(FairMCApplication&&) = delete;

    /** default destructor
     */
    ~FairMCApplication() override;
    /** Singelton instance
     */
    static FairMCApplication* Instance();
    virtual void AddDecayModes();
    /**  Add user defined particles (optional) */
    void AddParticles() override;   // MC Application
    /** Add user defined ions (optional)
        Called by TVirtualMC.
        TGeant3 calls AddIons() first, then InitGeometry().
        TGeant4 calls InitGeometry() first, then AddIons().
        This function also initializes event generators.*/
    void AddIons() override;   // MC Application
    /**
     *Add user defined Tasks to be executed after each event (optional)
     * @param fTask: Task that has to be excuted during simulation
     */
    void AddTask(TTask* fTask);
    /** Define actions at the beginning of the event */
    void BeginEvent() override;   // MC Application
    /** Define actions at the beginning of primary track */
    void BeginPrimary() override;   // MC Application
    /** Construct user geometry */
    void ConstructGeometry() override;   // MC Application
    /** Align or misalign geometry before actual run       */
    Bool_t MisalignGeometry() override;
    /** Define parameters for optical processes (optional) */
    void ConstructOpGeometry() override;   // MC Application
    /** Define actions at the end of event */
    void FinishEvent() override;   // MC Application
    /** Define actions at the end of primary track */
    void FinishPrimary() override;   // MC Application
    /** Define actions at the end of run */
    void FinishRun();
    /** Generate primary particles */
    void GeneratePrimaries() override;   // MC Application
    /** Return detector by name  */
    FairDetector* GetDetector(const char* DetName);
    /** Return Field used in simulation*/
    FairField* GetField() { return fxField; }
    /**Return primary generator*/
    FairPrimaryGenerator* GetGenerator();
    /**Return list of tasks*/
    TTask* GetListOfTasks();
    FairGenericStack* GetStack();
    TChain* GetChain();
    /** Initialize geometry
        Called by TVirtualMC.
        TGeant3 calls AddIons() first, then InitGeometry().
        TGeant4 calls InitGeometry() first, then AddIons().
        This function also registers detectors.*/
    void InitGeometry() override;   // MC Application
    /** Initialize MC engine */
    void InitMC(const char* setup, const char* cuts);
    /** Initialize Tasks if any*/
    void InitTasks();
    /**Define actions at the end of each track */
    void PostTrack() override;   // MC Application
    /** Define actions at the beginning of each track*/
    void PreTrack() override;   // MC Application

    /** Clone for worker (used in MT mode only) */
    TVirtualMCApplication* CloneForWorker() const override;

    /** Init application on worker (used in MT mode only) */
    void InitOnWorker() override;

    /** Finish run on worker (used in MT mode only) */
    void FinishRunOnWorker() override;

    /** Run the MC engine
     * @param nofEvents : number of events to simulate
     */
    void RunMC(Int_t nofEvents);
    /**
     * Set the magnetic field for simulation
     * @param field: magnetic field
     */
    void SetField(FairField* field);
    /**
     * Set the event generator  for simulation
     * @param fxGenerator: Event generator(s)
     */
    void SetGenerator(FairPrimaryGenerator* fxGenerator);
    /**
     * Set the parameter containers needed by Tasks(if any)
     */
    void SetParTask();
    /**
     * Switch for using Pythia as external decayer
     * @param decayer: if TRUE pythia will decay particles specifid in the Decay Config macro (see
     * SetPythiaDecayerConfig)
     */
    void SetPythiaDecayer(Bool_t decayer) { fPythiaDecayer = decayer; }
    /**
     * set the decay configuration macro to be used by Pythia
     */
    void SetPythiaDecayerConfig(const TString decayerConf) { fPythiaDecayerConfig = decayerConf; }
    /**
     * Switch for using the radiation length manager
     */
    void SetRadiationLengthReg(Bool_t RadLen);
    /**
     * Switch for using the radiation map manager
     */
    void SetRadiationMapReg(Bool_t RadMap);
    /**
     * Switch for debuging the tracking
     */
    void SetTrackingDebugMode(Bool_t set) { fDebug = set; }
    /**
     * Switch for using 2 or 3 body phase-space decay
     * @param  decay: if TRUE 2/3 body phase space decay will be used for particle specified in the User Decay Config
     * macro (see SetUserDecayConfig)
     */
    void SetUserDecay(Bool_t decay) { fUserDecay = decay; }
    /**
     * set the decay configuration macro to be used by user decay
     */
    void SetUserDecayConfig(const TString decayerConf) { fUserDecayConfig = decayerConf; }
    /** Define action at each step, dispatch the action to the corresponding detectors */
    void Stepping() override;   // MC Application
    /** Stop the run*/
    virtual void StopRun();
    /** Stop the run*/
    virtual void StopMCRun();
    /**Define maximum radius for tracking (optional) */
    Double_t TrackingRmax() const override;   // MC Application
    /** Define maximum z for tracking (optional) */
    Double_t TrackingZmax() const override;   // MC Application

    void AddMeshList(TObjArray* meshList);

    /**
     * Set if the current event should be written to the output file.
     * The default value which is set back after each event is to store
     * the event.
     */
    void SetSaveCurrentEvent(Bool_t set) { fSaveCurrentEvent = set; }

    /**
     * Get the current application state.
     */
    FairMCApplicationState GetState() const { return fState; }

    /**
     * Return non-owning pointer to FairRadGridManager
     */
    auto GetRadGridMan() { return fRadGridMan.get(); }

  private:
    // methods
    Int_t GetIonPdg(Int_t z, Int_t a) const;

    void UndoGeometryModifications();

  protected:
    // data members
    /**
     * \brief Main instance
     *
     * Only set for instances created by \ref CloneForWorker
     * and points to the instance from which the clone was
     * created
     */
    const FairMCApplication* fParent{nullptr};   //!
    /**List of active detector */
    TRefArray* fActiveDetectors;
    /**List of FairTask*/
    FairTask* fFairTaskList;   //!
    /**detector list (Passive and Active)*/
    TRefArray* fDetectors;
    /**Iterator for Module list*/
    TIterator* fModIter;   //!
    /**Module list in simulation*/
    TObjArray* fModules;
    /**Number of sensetive volumes in simulation session*/
    Int_t fNoSenVolumes;   //!
    /**flag for using Pythia as external decayer */
    Bool_t fPythiaDecayer;
    /** Pythia decay config macro*/
    TString fPythiaDecayerConfig;   //!
    /** Simulation Stack  */
    FairGenericStack* fStack;   //!
    /**Pointer to thr I/O Manager */
    FairRootManager* fRootManager;   //!
    /**List of sensetive volumes in all detectors*/
    TRefArray* fSenVolumes;   //!
    /**Magnetic Field Pointer*/
    FairField* fxField;   //
    /**Primary generator*/
    FairPrimaryGenerator* fEvGen;   //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t fMcVersion;   // mc Version
    /** Track visualization manager */
    FairTrajFilter* fTrajFilter;   //!
    /**Flag for accepted tracks for visualization*/
    Bool_t fTrajAccepted;   //!
    /**Flag for using user decay*/
    Bool_t fUserDecay;
    /**User decay config macro*/
    TString fUserDecayConfig;   //!
    /** Debug flag*/
    Bool_t fDebug;   //!
    /**dispatcher internal use */
    std::multimap<Int_t, FairVolume*> fVolMap;   //!
    /** Track position*/
    /**dispatcher internal use RadLeng*/
    std::map<Int_t, Int_t> fModVolMap;   //!
    TLorentzVector fTrkPos;              //!
    /** Flag for Radiation length register mode  */
    Bool_t fRadLength;   //!

    /**Radiation length Manager*/
    FairRadLenManager* fRadLenMan;   //!
    /** Flag for Radiation map register mode  */
    Bool_t fRadMap;   //!
    /**Radiation Map Manager*/
    FairRadMapManager* fRadMapMan;   //!
    /**Radiation map Grid Manager*/
    std::unique_ptr<FairRadGridManager> fRadGridMan{};   //!

    FairEventHeader* fEventHeader;   //!

    FairMCEventHeader* fMCEventHeader;   //!
    /** list of senstive detectors used in the simuation session*/
    std::list<FairDetector*> listActiveDetectors;   //!
    /** list of all detectors used in the simuation session*/
    std::list<FairDetector*> listDetectors;   //!
    /** Pointer to the current MC engine //!
     */
    TVirtualMC* fMC;

    FairRunSim* fRun{nullptr};   //!

    /** Flag if the current event should be saved */
    Bool_t fSaveCurrentEvent;

    /** Current state */
    FairMCApplicationState fState;   //!

    ClassDefOverride(FairMCApplication, 5);

  private:
    /** Private special copy constructor, needed for CloneForWorker */
    FairMCApplication(const FairMCApplication&, std::unique_ptr<FairRunSim>);

    FairRunInfo fRunInfo;   //!
    Bool_t fGeometryIsInitialized;

    /**
     * Clean up the FairRunSim created in CloneForWorker
     */
    std::unique_ptr<FairRunSim> fWorkerRunSim;   //!
};

// inline functions

inline FairMCApplication* FairMCApplication::Instance()
{
    return static_cast<FairMCApplication*>(TVirtualMCApplication::Instance());
}

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRMODULE_H
#define FAIRMODULE_H

#include "FairGeoInterface.h"   // for FairGeoInterface
#include "FairGeoLoader.h"      // for FairGeoLoader
#include "FairGeoNode.h"        // for FairGeoNode
#include "FairGeoVolume.h"      // for FairGeoVolume
#include "FairLogger.h"
#include "FairRun.h"         // for FairRun
#include "FairRuntimeDb.h"   // for FairRuntimeDb

#include <Rtypes.h>      // for Bool_t, Int_t, etc
#include <TList.h>       // for TList (ptr only), TListIter
#include <TNamed.h>      // for TNamed
#include <TObjArray.h>   // for TObjArray
#include <TString.h>     // for TString, operator!=
#include <string>        // for string

class FairVolumeList;
class FairVolume;
class TArrayI;
class TGeoMatrix;
class TGeoNode;
class TGeoVolume;
class TRefArray;
class TVirtualMC;

/**
 * Base class for constructing all detecors and passive volumes
 * @author M. Al-Turany, Denis Bertini
 * @version 1.0
 * @since 01.04.08 M.Al-Turany
 * Add methods to construct geometry via ROOT files
 * Add some documentation
 *
 * Changelog: 29.02.2012 [O.Merle] Fixed missing material assignment for top volume.
 *                                 ... and please - add some documentation to your code.
 */
class FairModule : public TNamed
{
  public:
    /**default ctor*/
    FairModule();
    /**Standard ctor*/
    FairModule(const char* Name, const char* title, Bool_t Active = kFALSE);
    /**default dtor*/
    ~FairModule() override;
    /**Print method should be implemented in detector or module*/
    void Print(Option_t*) const override { ; }
    /**Set the geometry file name o be used*/
    virtual void SetGeometryFileName(TString fname, TString geoVer = "0");
    /**Get the Geometry file name*/
    virtual TString GetGeometryFileName() { return fgeoName; }
    /**Get the geometry file version if used*/
    virtual TString GetGeometryFileVer() { return fgeoVer; }
    /**method called from the MC application to construct the geometry, has to be implimented by user*/
    virtual void ConstructGeometry();
    /**method called from the MC application to set optical geometry properties*/
    virtual void ConstructOpGeometry();
    /**construct geometry from root files (TGeo)*/
    virtual void ConstructRootGeometry(TGeoMatrix* shiftM = nullptr);
    /**construct geometry from standard ASSCII files (Hades Format)*/
    virtual void ConstructASCIIGeometry();
    /**
     * Modify the geometry for the simulation run using methods of the Root geometry package
     * \deprecated Deprecated pre-v18.8, will be removed in v20.
     */
    [[deprecated("Use FairAlignmentHandler instead, see Tutorial4 for examples")]] virtual void ModifyGeometry()
    {
        LOG(warn) << "This function is deprecated. Use FairAlignmentHandler instead, see Tutorial4 for examples.";
    }
    virtual void RegisterAlignmentMatrices() { ; }

    /**construct geometry from GDML files*/
    virtual void ConstructGDMLGeometry(__attribute__((unused)) TGeoMatrix* posrot);
    /** custom settings of processes and cuts for media to be forwarded to the
     ** detector simulation */
    virtual void SetSpecialPhysicsCuts() { ; }
    /** Clone this object (used in MT mode only)*/
    virtual FairModule* CloneModule() const;
    /** Init worker run (used in MT mode only) */
    virtual void BeginWorkerRun() const { ; }
    /** Finish worker run (used in MT mode only) */
    virtual void FinishWorkerRun() const { ; }

    /** @deprecated template function to construct geometry. to be used in derived classes.
     * The first and the third argument are meaningless, just pass nullptr */
    template<class T, class U>
    [[deprecated("Broken signature, use ConstructASCIIGeometry(TString) instead")]] void
        ConstructASCIIGeometry(T*, TString containerName = "", U* = nullptr);
    /** Helper function to construct geometry. */
    template<class T, class U>
    void ConstructASCIIGeometry(TString containerName = "");

    /**Set the sensitivity flag for volumes, called from ConstructASCIIRootGeometry(), and has to be implimented for
     * detectors which use ConstructASCIIRootGeometry() to build the geometry */
    virtual Bool_t IsSensitive(const std::string& name);
    /**The function below is depracated, please change to the new method above */
    virtual Bool_t CheckIfSensitive(__attribute__((unused)) std::string name) __attribute__((
        deprecated("The method CheckIfSensitive is deprecated. Implement IsSensitive in the detector classes.")))
    {
        return kFALSE;
    }
    /**called from ConstructRootGeometry()*/
    virtual void ExpandNode(TGeoNode* Node);
    /**called from ConstructGDMLGeometry()*/
    virtual void ExpandNodeForGDML(__attribute__((unused)) TGeoNode* curNode);
    /**return the MC id of a volume named vname*/
    virtual Int_t getVolId(const TString&) const { return 0; }
    /**return the detector/Module id (which was set in the sim macro for the detector)*/
    Int_t GetModId() { return fModId; }
    /**Set the verbose level in this detector*/
    void SetVerboseLevel(Int_t level) { fVerboseLevel = level; }
    /**return the detector status */
    Bool_t IsActive() { return fActive; }
    /**set the detector/module id*/
    void SetModId(Int_t id) { fModId = id; }
    /** Set the name of the mother volume to which a new geometry is added.
     ** This function is needed for geometries which are defined as ROOT geometry manager.
     **/
    void SetMotherVolume(TString volName) { fMotherVolumeName = volName; }
    /**called from ConstuctASCIIGeometry*/
    void ProcessNodes(TList* aList);
    /**Set the parameter containers*/
    virtual void SetParContainers() { ; }
    /** Initialize everything which has to be done before the construction and modification
     ** of the geometry. Mostly this is needed to read data from the parameter containers.*/
    virtual void InitParContainers() { ; }
    /**return the geo parameter of this detector/module*/
    TList* GetListOfGeoPar() { return flGeoPar; }

    /**list of volumes in a simulation session*/
    static thread_local FairVolumeList* vList;   //!
    /**total number of volumes in a simulaion session*/
    static thread_local Int_t fNbOfVolumes;   //!
    /**list of all sensitive volumes in  a simulaion session*/
    static thread_local TRefArray* svList;   //!

    static thread_local TArrayI* volNumber;   //!
    TString fMotherVolumeName;                //!
    FairVolume* getFairVolume(FairGeoNode* fNode);
    void AddSensitiveVolume(TGeoVolume* v);

  private:
    /** Re-implimented from ROOT:  TGeoMatrix::SetDefaultName()  */
    void SetDefaultMatrixName(TGeoMatrix* matrix);
    void AssignMediumAtImport(TGeoVolume* v);   // O.Merle, 29.02.2012 - see impl.

    /**called from ConstructGDMLGeometry. Changes default ID created by TGDMLParse*/
    void ReAssignMediaId();
    void swap(FairModule& other) throw();

  protected:
    FairModule(const FairModule&);
    FairModule& operator=(const FairModule&);
    TString fgeoVer;
    TString fgeoName;
    Int_t fModId;
    Bool_t fActive;
    Int_t fNbOfSensitiveVol;   //!
    Int_t fVerboseLevel;
    TList* flGeoPar;    //!  list of Detector Geometry parameters
    Bool_t fGeoSaved;   //! flag for initialisation
    TVirtualMC* fMC;    //! cahed pointer to MC (available only after initialization)

    ClassDefOverride(FairModule, 4);
};

template<class T, class U>
void FairModule::ConstructASCIIGeometry(TString containerName)
{
    FairGeoLoader* loader = FairGeoLoader::Instance();
    FairGeoInterface* GeoInterface = loader->getGeoInterface();
    T* MGeo = new T();
    MGeo->print();
    MGeo->setGeomFile(GetGeometryFileName());
    GeoInterface->addGeoModule(MGeo);   // takes ownership!
    Bool_t rc = GeoInterface->readSet(MGeo);
    if (rc) {
        MGeo->create(loader->getGeoBuilder());
    }

    TList* volList = MGeo->getListOfVolumes();
    // store geo parameter
    FairRun* fRun = FairRun::Instance();
    FairRuntimeDb* rtdb = FairRun::Instance()->GetRuntimeDb();

    if ("" != containerName) {
        LOG(info) << "Add GeoNodes for " << MGeo->getDescription() << " to container " << containerName;

        //    U par=(U)(rtdb->getContainer(containerName));
        U* par = static_cast<U*>(rtdb->getContainer(containerName));
        TObjArray* fSensNodes = par->GetGeoSensitiveNodes();
        TObjArray* fPassNodes = par->GetGeoPassiveNodes();

        TListIter iter(volList);
        FairGeoNode* node = nullptr;
        FairGeoVolume* aVol = nullptr;

        while ((node = static_cast<FairGeoNode*>(iter.Next()))) {
            aVol = dynamic_cast<FairGeoVolume*>(node);
            if (node->isSensitive()) {
                fSensNodes->AddLast(aVol);
            } else {
                fPassNodes->AddLast(aVol);
            }
        }
        ProcessNodes(volList);
        par->setChanged();
        par->setInputVersion(fRun->GetRunId(), 1);
    }
}

template<class T, class U>
void FairModule::ConstructASCIIGeometry(T*, TString containerName, U*)
{
    ConstructASCIIGeometry<T, U>(containerName);
}

#endif   // FAIRMODULE_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/// Class FAIRParticle
/// ------------------
/// Extended TParticle with persistent pointers to mother and daughters
/// particles  (Ivana Hrivnacova, 5.4.2002)
/// Used to define particles which will be added to Geant3/4 (M. Al-Turany)

#ifndef FAIR_PARTICLE_H
#define FAIR_PARTICLE_H

#include <Rtypes.h>            // for Int_t, Double_t, Bool_t, etc
#include <TMCParticleType.h>   // for TMCParticleType
#include <TObject.h>           // for TObject
#include <TRef.h>              // for TRef
#include <TRefArray.h>         // for TRefArray
#include <TString.h>           // for TString

class TParticle;

class FairParticle : public TObject
{
  public:
    FairParticle(Int_t id, TParticle* particle);
    FairParticle(Int_t id, TParticle* particle, FairParticle* mother);
    FairParticle(const char* name,
                 Int_t z,
                 Int_t a,
                 Int_t s,
                 Double_t mass,
                 Int_t q,
                 Bool_t stable,
                 Double_t decaytime);
    FairParticle(const char* name, Int_t z, Int_t a, Double_t mass, Int_t q, Bool_t stable, Double_t decaytime);
    FairParticle(Int_t pdg,
                 const TString name,
                 TMCParticleType mcType,
                 Double_t mass,
                 Double_t charge,
                 Double_t lifetime,
                 const TString pType = "Ion",
                 Double_t width = 0,
                 Int_t iSpin = 0,
                 Int_t iParity = 0,
                 Int_t iConjugation = 0,
                 Int_t iIsospin = 0,
                 Int_t iIsospinZ = 0,
                 Int_t gParity = 0,
                 Int_t lepton = 0,
                 Int_t baryon = 0,
                 Bool_t stable = kFALSE);

    FairParticle();

    ~FairParticle() override;

    // methods
    void SetMother(FairParticle* particle);
    void AddDaughter(FairParticle* particle);
    void Print(Option_t* option = "") const override;
    void PrintDaughters() const;

    // get methods
    Int_t GetPDG() const;
    TParticle* GetParticle() const;
    FairParticle* GetMother() const;
    Int_t GetNofDaughters() const;
    FairParticle* GetDaughter(Int_t i) const;
    const char* GetName() const override { return fname.Data(); }
    TMCParticleType GetMCType() { return fmcType; }
    Double_t GetMass() { return fmass; }
    Double_t GetCharge() { return fcharge; }
    Double_t GetDecayTime() { return fDecayTime; }
    const TString& GetPType() { return fpType; }
    Double_t GetWidth() { return fwidth; }
    Int_t GetSpin() { return fiSpin; }
    Int_t GetiParity() { return fiParity; }
    Int_t GetConjugation() { return fiConjugation; }
    Int_t GetIsospin() { return fiIsospin; }
    Int_t GetIsospinZ() { return fiIsospinZ; }
    Int_t GetgParity() { return fgParity; }
    Int_t GetLepton() { return flepton; }
    Int_t GetBaryon() { return fbaryon; }
    Bool_t IsStable() { return fstable; }

  private:
    FairParticle(const FairParticle& P);
    FairParticle& operator=(const FairParticle&) { return *this; }
    // data members
    Int_t fpdg;
    TParticle* fParticle;
    TRef fMother;
    TRefArray fDaughters;
    const TString fname;
    TMCParticleType fmcType;
    Double_t fmass;
    Double_t fcharge;
    Double_t fDecayTime;
    const TString fpType;
    Double_t fwidth;
    Int_t fiSpin;
    Int_t fiParity;
    Int_t fiConjugation;
    Int_t fiIsospin;
    Int_t fiIsospinZ;
    Int_t fgParity;
    Int_t flepton;
    Int_t fbaryon;
    Bool_t fstable;

    ClassDefOverride(FairParticle, 3);
};

#endif   // FAIR_PARTICLE_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH *
 *                                                                              *
 *              This software is distributed under the terms of the *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE" *
 ********************************************************************************/

/** FairPrimaryGenerator.h
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairPrimaryGenerator is responsible for the handling of the MC input.
Several input generators can be registered to it; these have to be
derived from the FairGenerator class. The FairPrimaryGenerator defines
position and (optionally) smearing of the primary vertex.
This class should be instantised only once.

Modified 05.06.07:  add a method DoTracking(Bool_t) to be able to switch on/off
the tracking from the macro (M. Al-Turany)

**/

#ifndef FAIRPRIMARYGENERATOR_H
#define FAIRPRIMARYGENERATOR_H

#include "FairGenerator.h"   // for FairGenerator

#include <Rtypes.h>   // for Double_t, Bool_t, Int_t, etc
#include <TMCProcess.h>
#include <TNamed.h>      // for TNamed
#include <TObjArray.h>   // for TObjArray
#include <TVector3.h>    // for TVector3
#include <iostream>      // for cout

class FairGenericStack;
class FairMCEventHeader;
class TIterator;

class FairPrimaryGenerator : public TNamed
{

  public:
    /** Default constructor. **/
    FairPrimaryGenerator();

    /** Constructor with name and title **/
    FairPrimaryGenerator(const char *name, const char *title = "FAIR Generator");

    /** Destructor. **/
    virtual ~FairPrimaryGenerator();

    /** Initialize the generater (if needed!)*/
    virtual Bool_t Init();

    /** Finalize the generater (if needed!)*/
    virtual void Finish();

    /** Register a generator derived from FairGenerator.  **/
    void AddGenerator(FairGenerator *generator)
    {
        if (!fGenList) {
            std::cout << "Empty fGenList pointer ! " << std::endl;
            return;
        }
        fGenList->Add(generator);
    }

    void SetEventNr(Int_t evtNr) { fEventNr = evtNr; }

    /** Public method GenerateEvent
      To be called at the beginning of each event from FairMCApplication.
      Generates an event vertex and calls the ReadEvent methods from the
      registered generators.
      *@param pStack The particle stack
      *@return kTRUE if successful, kFALSE if not
      **/
    virtual Bool_t GenerateEvent(FairGenericStack *pStack);

    /** Public method AddTrack
      Adding a track to the MC stack. To be called within the ReadEvent
      methods of the registered generators.
      *@param pdgid Particle ID (PDG code)
      *@param px,py,pz Momentum coordinates [GeV]
      *@param vx,vy,vz Track origin relative to event vertex
      **/
    virtual void AddTrack(Int_t pdgid,
                          Double_t px,
                          Double_t py,
                          Double_t pz,
                          Double_t vx,
                          Double_t vy,
                          Double_t vz,
                          Int_t parent = -1,
                          Bool_t wanttracking = true,
                          Double_t e = -9e9,
                          Double_t tof = 0.,
                          Double_t weight = 0.,
                          TMCProcess proc = kPPrimary);

    /** Clone this object (used in MT mode only) */
    virtual FairPrimaryGenerator *ClonePrimaryGenerator() const;

    /** Set beam position and widths.
     *@param beamX0      mean x position of beam at target
     *@param beamY0      mean y position of beam at target
     *@param beamSigmaX  Gaussian beam width in x
     *@param beamSigmaY  Gaussian beam width in y
     **/
    void SetBeam(Double_t beamX0, Double_t beamY0, Double_t beamSigmaX, Double_t beamSigmaY);

    /** Set nominal beam angle and angle widths.
     *@param beamAngleX0      mean x angle of beam at target
     *@param beamAngleY0      mean y angle of beam at target
     *@param beamAngleSigmaX  Gaussian beam angle width in x
     *@param beamAngleSigmaY  Gaussian beam angle width in y
     **/
    void SetBeamAngle(Double_t beamAngleX0, Double_t beamAngleY0, Double_t beamAngleSigmaX, Double_t beamAngleSigmaY);

    /** Public method SetEventPlane
     **@param phiMin   Lower limit for event plane angle [rad]
     **@param phiMax   Upper limit for event plane angle [rad]
     **If set, an event plane angle will be generated with flat
     **distrtibution between phiMin and phiMax.
     **/
    void SetEventPlane(Double_t phiMin, Double_t phiMax);

    /** Set target position and thickness.
     *@param targetZ   z position of target center
     *@param targetDz  full target thickness
     **/
    void SetTarget(Double_t targetZ, Double_t targetDz);

    /** Set target position for multiple tagets. The thickness
     * is the same for all targets.
     *@param nroftargets   number of targets
     *@param *targetZ      z positions of target center
     *@param targetDz      full target thickness
     **/
    void SetMultTarget(Int_t nroftargets, Double_t *targetZ, Double_t targetDz);

    /** Enable vertex smearing in z and/or xy direction **/
    void SmearVertexZ(Bool_t flag);
    void SmearGausVertexZ(Bool_t flag);
    void SmearVertexXY(Bool_t flag);
    void SmearGausVertexXY(Bool_t flag);

    TObjArray *GetListOfGenerators() { return fGenList; }

    /** Set the pointer to the MCEvent **/
    void SetEvent(FairMCEventHeader *event) { fEvent = event; };

    /** Accessor to the MCEvent **/
    FairMCEventHeader *GetEvent() { return fEvent; };

    /** Swich on/off the tracking of a particle*/

    void DoTracking(Bool_t doTracking = kTRUE) { fdoTracking = doTracking; }

    Int_t GetTotPrimary() { return fTotPrim; }

  protected:
    /**  Copy constructor */
    FairPrimaryGenerator(const FairPrimaryGenerator &);
    /**  Assignment operator */
    FairPrimaryGenerator &operator=(const FairPrimaryGenerator &);

    /**  Nominal beam position at target in x [cm] */
    Double_t fBeamX0;
    /** Nominal beam position at target in y [cm]*/
    Double_t fBeamY0;
    /** Beam width (Gaussian) in x [cm]*/
    Double_t fBeamSigmaX;
    /**  Beam width (Gaussian) in y [cm]*/
    Double_t fBeamSigmaY;

    /**  Nominal beam angle at target in x [rad] */
    Double_t fBeamAngleX0;
    /**  Nominal beam angle at target in y [rad] */
    Double_t fBeamAngleY0;
    /**  Actual beam angle at target in x [rad] */
    Double_t fBeamAngleX;
    /**  Actual beam angle at target in y [rad] */
    Double_t fBeamAngleY;
    /** Beam angle width (Gaussian) in x [rad]*/
    Double_t fBeamAngleSigmaX;
    /** Beam angle width (Gaussian) in y [rad]*/
    Double_t fBeamAngleSigmaY;
    /** Actual beam direction at the vertex */
    TVector3 fBeamDirection;

    /** Lower limit for the event plane rotation angle [rad] */
    Double_t fPhiMin;
    /** Upper limit for the event plane rotation angle [rad] */
    Double_t fPhiMax;
    /** Actual event plane rotation angle [rad] */
    Double_t fPhi;

    /**  Nominal z position of center of targets [cm]*/
    Double_t *fTargetZ;   //!
    /**  Number of targets;*/
    Int_t fNrTargets;
    /**  Full target thickness [cm]*/
    Double_t fTargetDz;

    /** Vertex position of current event [cm]*/
    TVector3 fVertex;

    /** Number of primary tracks in current event*/
    Int_t fNTracks;

    /**  Flag for uniform vertex smearing in z*/
    Bool_t fSmearVertexZ;
    /**  Flag for gaus vertex smearing in z*/
    Bool_t fSmearGausVertexZ;
    /**  Flag for vertex smearing in xy*/
    Bool_t fSmearVertexXY;
    /**  Flag for gaus vertex smearing in xy*/
    Bool_t fSmearGausVertexXY;
    /**  Flag for beam gradient calculation*/
    Bool_t fBeamAngle;
    /**  Flag for event plane rotation*/
    Bool_t fEventPlane;

    /**  Pointer to MC stack*/
    FairGenericStack *fStack;   //!
    /**  List of registered generators */
    TObjArray *fGenList;
    /**  Iterator over generator list */
    TIterator *fListIter;   //!
    /**  Pointer to MCEventHeader */
    FairMCEventHeader *fEvent;   //!
    /** go to tracking  */
    Bool_t fdoTracking;   //!
    /** Number of MC tracks before a Generator is called, needed for MC index
     * update */
    Int_t fMCIndexOffset;   //!
    /** Number of all primaries of this run*/
    static Int_t fTotPrim;   //!
    /** Event number (Set by the primary generator if not set already by one of
      the specific generators
   **/
    Int_t fEventNr;

    /** Private method MakeVertex. If vertex smearing in xy is switched on,
      the event vertex is smeared Gaussianlike in x and y direction
      according to the mean beam positions and widths set by the
      SetBeam method. If vertex smearing in z is switched on, the z
      coordinate of the event vertex is flatly distributed over the
      extension of the target.
      To be called at the beginning of the event from the
      GenerateEvent method.
  **/
    virtual void MakeVertex();

    /** Private method MakeBeamAngle. If beam angle smearing in xy
  is switched on, all tracks in an event are rotated by a Gaussianlike
  angle distribution around the x and y axis according to the mean
  beam angle and angle widths set by the SetBeamAngle method.
  To be called at the beginning of the event from the GenerateEvent
  method.
  **/
    virtual void MakeBeamAngle();

    /** Private method MakeEventPlane. If the rotation of the event around the
      z-axis by a random angle is switched on, the complete event is rotated
      by the chosen angle. This function is called at the beginning of the
      event from the GenerateEvent method. The function pick a random
      rotation angle between fPhiMin and fPhiMax which are set using the
      function SetEventPlane.
  **/
    void MakeEventPlane();

    ClassDef(FairPrimaryGenerator, 5);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNIDGENERATOR_H
#define FAIRRUNIDGENERATOR_H

#include <time.h>   // IWYU pragma: keep for timespec
// IWYU pragma: no_include <sys/_structs.h>

typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
typedef unsigned char uuid_t[16];

class FairRunIdGenerator
{
    struct uuid
    {
        uint32_t time_low;
        uint16_t time_mid;
        uint16_t time_hi_and_version;
        uint16_t clock_seq;
        uint8_t node[6];
    };

    struct timespec fTimeSpec;

    int get_random_fd(void);
    void get_random_bytes(void*, int);
    int get_node_id(unsigned char*);
    int get_clock(uint32_t*, uint32_t*, uint16_t*);
    void uuid_generate_time(uuid_t);
    void uuid_generate_random(uuid_t);
    void uuid_generate(uuid_t);
    void uuid_pack(const struct uuid*, uuid_t);
    void uuid_unpack(const uuid_t, struct uuid*);

  public:
    struct timespec getTimeSpec() { return fTimeSpec; }
    struct timespec getTimeSpecFromTID(unsigned int ms);
    unsigned int getTID();

  public:
    FairRunIdGenerator()
        : fTimeSpec()
    {}
    ~FairRunIdGenerator() {}
    unsigned int generateId(void);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUME_H
#define FAIR_VOLUME_H

#include "FairModule.h"

#include <Rtypes.h>    // for Int_t, FairVolume::Class, etc
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString

class FairDetector;
class FairGeoNode;

/**
 * This Object is only used for internal book keeping!
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairVolume : public TNamed
{
  public:
    FairVolume();
    FairVolume(const TString& name, Int_t id = 0, Int_t modId = 0, FairModule* fMod = nullptr);
    ~FairVolume() override;

    void setRealName(TString name) { fRealName = name; }
    const char* getRealName() const { return fRealName.Data(); }
    Int_t getVolumeId() const { return fVolumeId; }
    Int_t getModId() const { return fModId; }
    void setModId(Int_t id) { fModId = id; }
    void setCopyNo(Int_t id) { fCopyNo = id; }
    void setVolumeId(Int_t id) { fVolumeId = id; }
    void setGeoNode(FairGeoNode* d) { fNode = d; }
    void setMotherId(Int_t fM) { fMotherId = fM; }
    void setMotherCopyNo(Int_t copyNo) { fMotherCopyNo = copyNo; }

    FairModule* GetModule() const { return fModule; }
    FairDetector* GetDetector() const { return fDetector; }
    void SetModule(FairModule* mod);

    Int_t getMCid() const { return fMCid; }
    Int_t getCopyNo() const { return fCopyNo; }
    void setMCid(Int_t id) { fMCid = id; }
    FairGeoNode* getGeoNode() const { return fNode; }
    Int_t getMotherId() const { return fMotherId; }
    Int_t getMotherCopyNo() const { return fMotherCopyNo; }

  private:
    FairVolume(const FairVolume&);
    FairVolume& operator=(const FairVolume&);

    TString fRealName{""};            /**Volume Name in ASCII file*/
    Int_t fVolumeId{-1};              /**Volume Id in GeoManager*/
    Int_t fModId{-1};                 /**Module Id in which this volume exist*/
    Int_t fMCid{-1};                  /**Volume Id in MC*/
    Int_t fCopyNo{-1};                /**Volume Copy No*/
    Int_t fMotherId{-1};              /**Mother Volume Id*/
    Int_t fMotherCopyNo{-1};          /**Mother Volume Copy No*/
    FairDetector* fDetector{nullptr}; /** The Detector which will proccess the hits for this volume*/
    FairModule* fModule{nullptr};     /**The Module in which the volume is */
    FairGeoNode* fNode{nullptr};      /**Node corresponding to this volume*/

    ClassDefOverride(FairVolume, 2);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUMELIST_H
#define FAIR_VOLUMELIST_H

#include "FairVolume.h"

#include <Rtypes.h>      // for Int_t, etc
#include <TObjArray.h>   // for TObjArray
#include <TObject.h>     // for TObject
#include <TString.h>     // for TString

// class FairVolume;

/**
 * This Object is only used for internal book keeping!
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairVolumeList : public TObject
{
  private:
    TObjArray* fData;
    FairVolumeList(const FairVolumeList&);
    FairVolumeList& operator=(const FairVolumeList&);

  public:
    FairVolumeList();
    virtual ~FairVolumeList();

    FairVolume* getVolume(TString* name);
    Int_t getVolumeId(TString* name);

    FairVolume* findObject(TString name);
    void addVolume(FairVolume* elem);

    Int_t getEntries() { return fData->GetEntries(); }
    FairVolume* At(Int_t pos) { return (dynamic_cast<FairVolume*>(fData->At(pos))); }

    ClassDef(FairVolumeList, 1);
};

#endif   // FAIR_VOLUMELIST_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairRootFileSink                      -----
// -----                    Created 22.12.2017 by R. Karabowicz            -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef __FAIRROOT__FairRootFileSink__
#define __FAIRROOT__FairRootFileSink__

#include "FairSink.h"

#include <Rtypes.h>
#include <TFile.h>
#include <TString.h>
#include <typeinfo>

class FairEventHeader;
class FairFileHeader;
class TBranch;
class TObjArray;
class TObject;
class TTree;
class TFolder;

class FairRootFileSink : public FairSink
{
  public:
    FairRootFileSink(TFile* f, const char* Title = "OutputRootFile");
    FairRootFileSink(const TString* RootFileName, const char* Title = "OutputRootFile");
    FairRootFileSink(const TString RootFileName, const char* Title = "OutputRootFile");
    //  FairRootFileSink(const FairRootFileSink& file);
    virtual ~FairRootFileSink();

    virtual Bool_t InitSink();
    virtual void Close();
    virtual void Reset();

    virtual Sink_Type GetSinkType() { return kFILESINK; }

    virtual void FillEventHeader(FairEventHeader* feh);

    virtual TFile* OpenRootFile(TString fileName = "");
    TFile* GetRootFile() { return fRootFile; }
    virtual TString GetFileName() { return (fRootFile ? fRootFile->GetName() : ""); }

    virtual void SetOutTree(TTree* fTree) { fOutTree = fTree; }
    TTree* GetOutTree() { return fOutTree; }

    virtual void Fill();

    virtual Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0);

    virtual void RegisterImpl(const char*, const char*, void*);
    virtual void RegisterAny(const char* brname, const std::type_info& oi, const std::type_info& pi, void* obj);

    virtual void WriteFolder();
    virtual bool CreatePersistentBranchesAny();

    virtual void WriteObject(TObject* f, const char*, Int_t option = 0);
    virtual void WriteGeometry();

    virtual FairSink* CloneSink();

  private:
    /** Title of input sink, could be input, background or signal*/
    TString fOutputTitle;
    /** ROOT file */
    TFile* fRootFile;
    /** Output Tree  */
    TTree* fOutTree;
    /**  list of folders from all input (and friends) files */
    TObjArray* fListFolder;   //!
    /** folder structure of output */
    TFolder* fCbmout;
    /** Initialization flag, true if initialized */
    Bool_t fIsInitialized;

    FairRootFileSink(const FairRootFileSink&);
    FairRootFileSink operator=(const FairRootFileSink&);

    void TruncateBranchNames();
    void TruncateBranchNames(TBranch* b, TString ffn);
    // bool CreatePersistentBranchesAny();

    /**File Header*/
    FairFileHeader* fFileHeader;   //!

    bool fPersistentBranchesDone{false};   //!

    ClassDef(FairRootFileSink, 1);
};

#endif /* defined(__FAIRROOT__FairRootFileSink__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairSink                              -----
// -----                    Created 22.12.2017 by R. Karabowicz            -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRSINK_H
#define FAIRSINK_H

#include <Rtypes.h>
#include <TString.h>
#include <map>        // map
#include <memory>     // unique_ptr
#include <string>     // string
#include <typeinfo>   // type_info

class TObject;
class TFolder;
class TTree;

enum Sink_Type
{
    kONLINESINK,
    kFILESINK
};

class FairSink
{
  public:
    FairSink();
    FairSink(const FairSink& sink);
    virtual ~FairSink();

    virtual Bool_t InitSink() = 0;
    virtual void Close() = 0;
    virtual void Reset() = 0;

    virtual Sink_Type GetSinkType() = 0;
    virtual TString GetFileName() { return ""; }

    void SetRunId(Int_t runId) { fRunId = runId; }
    Int_t GetRunId() const { return fRunId; }

    virtual void SetOutTree(TTree* fTree) = 0;

    virtual void Fill() = 0;

    virtual Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) = 0;

    virtual void RegisterImpl(const char*, const char*, void*) = 0;
    virtual void RegisterAny(const char* brname, const std::type_info& oi, const std::type_info& pi, void* obj) = 0;

    virtual void WriteFolder() = 0;
    virtual bool CreatePersistentBranchesAny() = 0;

    virtual void WriteObject(TObject* f, const char*, Int_t option = 0) = 0;
    virtual void WriteGeometry() = 0;

    virtual FairSink* CloneSink() = 0;

  protected:
    struct TypeAddressPair
    {
        TypeAddressPair(const std::type_info& oi, const std::type_info& pi, void* a)
            : origtypeinfo(oi)
            , persistenttypeinfo(pi)
            , ptraddr(a)
        {}
        const std::type_info& origtypeinfo;         // type_info of type addr points to
        const std::type_info& persistenttypeinfo;   // type_info of ROOT persistent branch (drops pointers)
        void* ptraddr;                              // address of a pointer (pointing to origtypeinfo);
    };

    Int_t fRunId;

    /**folder structure of output*/
    TFolder* fOutFolder;
    /// A map of branchnames to typeinformation + memory address;
    /// used for branches registered to bes stored; use of ptr here
    /// since type_info cannot be copied
    std::map<std::string, std::unique_ptr<TypeAddressPair const>> fPersistentBranchesMap;   //!

  public:
    ClassDef(FairSink, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

#ifndef __FAIRROOT__FairFileSourceBase__
#define __FAIRROOT__FairFileSourceBase__

#include "FairSource.h"

#include <TFile.h>
#include <list>
#include <map>

/**
 * \brief Internal base class for FairFileSource and FairMixedSource
 */
class FairFileSourceBase : public FairSource
{
  public:
    ~FairFileSourceBase() override;
    void Reset() override {}
    Source_Type GetSourceType() override { return kFILE; }
    void SetParUnpackers() override {}
    Bool_t InitUnpackers() override { return kTRUE; }
    Bool_t ReInitUnpackers() override { return kTRUE; }

    Bool_t CompareBranchList(TFile* fileHandle, TString inputLevel);

  protected:
    FairFileSourceBase()
        : FairSource(){};

    std::map<TString, std::list<TString>> fCheckInputBranches{};   //!

    ClassDefOverride(FairFileSourceBase, 0);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairFileSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairFileSource__
#define __FAIRROOT__FairFileSource__

#include "FairFileSourceBase.h"

#include <TArrayI.h>
#include <TChain.h>
#include <TF1.h>
#include <TFile.h>
#include <TFolder.h>
#include <TString.h>
#include <list>
#include <map>
#include <memory>

class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TTree;

class FairFileSource : public FairFileSourceBase
{
  public:
    FairFileSource(TFile* f, const char* Title = "InputRootFile", UInt_t identifier = 0);
    FairFileSource(const TString* RootFileName, const char* Title = "InputRootFile", UInt_t identifier = 0);
    FairFileSource(const TString RootFileName, const char* Title = "InputRootFile", UInt_t identifier = 0);
    // FairFileSource(const FairFileSource& file);
    ~FairFileSource() override;

    Bool_t Init() override;
    Int_t ReadEvent(UInt_t i = 0) override;
    void Close() override;

    /**Check the maximum event number we can run to*/
    Int_t CheckMaxEventNo(Int_t EvtEnd = 0) override;
    /**Read the tree entry on one branch**/
    void ReadBranchEvent(const char* BrName) override;
    /**Read specific tree entry on one branch**/
    void ReadBranchEvent(const char* BrName, Int_t Entry) override;
    void FillEventHeader(FairEventHeader* feh) override;

    const TFile* GetRootFile() { return fRootFile; }
    /** Add a friend file (input) by name)*/
    void AddFriend(TString FileName);
    /**Add ROOT file to input, the file will be chained to already added files*/
    void AddFile(TString FileName);
    void AddFriendsToChain();
    void PrintFriendList();
    void CheckFriendChains();
    void CreateNewFriendChain(TString inputFile, TString inputLevel);
    TTree* GetInTree() { return fInChain->GetTree(); }
    TChain* GetInChain() { return fInChain; }
    TFile* GetInFile() { return fRootFile; }
    void CloseInFile()
    {
        if (fRootFile) {
            fRootFile->Close();
        }
    }
    void SetInTree(TTree* tempTree);
    TObjArray* GetListOfFolders() { return fListFolder; }
    TFolder* GetBranchDescriptionFolder() { return fCbmroot; }
    UInt_t GetEntries() { return fNoOfEntries; }

    //    TList*              GetBranchNameList() {return fBranchNameList;}

    void SetInputFile(TString name);

    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime).
     * The total repetition time is beamTime + gapTime */
    void SetBeamTime(Double_t beamTime, Double_t gapTime);
    /** Set the min and max limit for event time in ns */
    void SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void SetEventMeanTime(Double_t mean);
    void SetEventTime();
    Double_t GetDeltaEventTime();
    void SetFileHeader(FairFileHeader* f) { fFileHeader = f; }
    Double_t GetEventTime();

    Bool_t ActivateObject(TObject** obj, const char* BrName) override;
    Bool_t ActivateObjectAny(void**, const std::type_info&, const char*) override;

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void SetEvtHeaderNew(Bool_t Status) { fEvtHeaderIsNew = Status; }
    Bool_t IsEvtHeaderNew() { return fEvtHeaderIsNew; }

    /** Allow to disable the testing the file layout when adding files to a chain.
     */
    void SetCheckFileLayout(Bool_t enable) { fCheckFileLayout = enable; }

    /**Read one event from source to find out which RunId to use*/
    Bool_t SpecifyRunId() override;

  private:
    /** Title of input source, could be input, background or signal*/
    TString fInputTitle;
    /**ROOT file*/
    TFile* fRootFile;
    /** Current Entry number */
    Int_t fCurrentEntryNr;   //!
    /** List of all files added with AddFriend */
    std::list<TString> fFriendFileList;                                 //!
    std::list<TString> fInputChainList;                                 //!
    std::map<TString, TChain*> fFriendTypeList;                         //!
    std::list<TString> fInputLevel;                                     //!
    std::map<TString, std::multimap<TString, TArrayI>> fRunIdInfoAll;   //!
    /**Input Chain */
    TChain* fInChain;
    /**Input Tree */
    TTree* fInTree;
    /** list of folders from all input (and friends) files*/
    TObjArray* fListFolder;   //!
    /**folder structure of output*/
    TFolder* fCbmout;
    /**folder structure of input*/
    TFolder* fCbmroot;
    /***/
    UInt_t fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t IsInitialized;

    FairFileSource(const FairFileSource&);
    FairFileSource operator=(const FairFileSource&);

    /** MC Event header */
    FairMCEventHeader* fMCHeader;   //!

    /**Event Header*/
    FairEventHeader* fEvtHeader;   //!

    /**File Header*/
    FairFileHeader* fFileHeader;   //!

    /** This is true if the event time used, came from simulation*/
    Bool_t fEventTimeInMCHeader;   //!
    /**This flag is true if the event header was created in this session
     * otherwise it is false which means the header was created in a previous data
     * level and used here (e.g. in the digi)
     */
    Bool_t fEvtHeaderIsNew;   //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t fCurrentEntryNo;   //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t fTimeforEntryNo;   //!

    /** min time for one event (ns) */
    Double_t fEventTimeMin;   //!
    /** max time for one Event (ns) */
    Double_t fEventTimeMax;   //!
    /** Time of event since th start (ns) */
    Double_t fEventTime;   //!
    /** Time of particles in beam (ns) */
    Double_t fBeamTime;   //!
    /** Time without particles in beam (gap) (ns) */
    Double_t fGapTime;   //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t fEventMeanTime;   //!
    /** used to generate random numbers for event time; */
    std::unique_ptr<TF1> fTimeProb;   //!
    /** True if the file layout should be checked when adding files to a chain.
     *  Default value is true.
     */
    Bool_t fCheckFileLayout;   //!

    ClassDefOverride(FairFileSource, 3);
};

#endif /* defined(__FAIRROOT__FairFileSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairMixedSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairMixedSource__
#define __FAIRROOT__FairMixedSource__

#include "FairFileSourceBase.h"

#include <TArrayI.h>
#include <TChain.h>
#include <TF1.h>
#include <TFile.h>
#include <list>
#include <map>
#include <memory>

class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TString;
class TFolder;
class TObject;

class FairRootManager;

class FairMixedSource : public FairFileSourceBase
{
  public:
    FairMixedSource(TFile* f, const char* Title = "InputRootFile", UInt_t identifier = 0);
    FairMixedSource(const TString* RootFileName, const char* Title = "InputRootFile", UInt_t identifier = 0);
    FairMixedSource(const TString RootFileName,
                    const Int_t signalId,
                    const char* Title = "InputRootFile",
                    UInt_t identifier = 0);
    //  FairMixedSource(const FairMixedSource& file);
    ~FairMixedSource() override;

    Bool_t Init() override;
    Int_t ReadEvent(UInt_t i = 0) override;
    void Close() override;

    /**Check the maximum event number we can run to*/
    Int_t CheckMaxEventNo(Int_t EvtEnd = 0) override;
    /**Read the tree entry on one branch**/
    void ReadBranchEvent(const char* BrName) override;
    /** Read specific tree entry on one branch**/
    void ReadBranchEvent(const char* BrName, Int_t Entry) override;

    void FillEventHeader(FairEventHeader* feh) override;

    const TFile* GetRootFile() { return fRootFile; }
    /** Add a friend file (input) by name)*/

    Bool_t ActivateObject(TObject** obj, const char* BrName) override;
    Bool_t ActivateObjectAny(void**, const std::type_info&, const char*) override;

    void ReadBKEvent(UInt_t i = 0);

    /**Set the input signal file
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file
     */
    void SetSignalFile(TString name, UInt_t identifier);
    /**Set the input background file by name*/
    void SetBackgroundFile(TString name);
    /**Add signal file to input
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file to which this signal should be added
     */
    void AddSignalFile(TString name, UInt_t identifier);
    void AddBackgroundFile(TString name);

    TChain* GetBGChain() { return fBackgroundChain; }
    TChain* GetSignalChainNo(UInt_t i);

    Bool_t OpenBackgroundChain();
    Bool_t OpenSignalChain();

    /**Set the signal to background ratio in event units
     *@param background :  Number of background Events for one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     */
    void BGWindowWidthNo(UInt_t background, UInt_t Signalid);
    /**Set the signal to background rate in time units
     *@param background :  Time of background Events before one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     */
    void BGWindowWidthTime(Double_t background, UInt_t Signalid);

    /** Set the min and max limit for event time in ns */
    void SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void SetEventMeanTime(Double_t mean);
    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime).
     * The total repetition time is beamTime + gapTime */
    void SetBeamTime(Double_t beamTime, Double_t gapTime);
    void SetEventTime();
    Double_t GetDeltaEventTime();
    void SetFileHeader(FairFileHeader* f) { fFileHeader = f; }
    Double_t GetEventTime();

    TObjArray* GetListOfFolders() { return fListFolder; }
    TFolder* GetBranchDescriptionFolder() { return fCbmroot; }
    UInt_t GetEntries() { return fNoOfEntries; }

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void SetEvtHeaderNew(Bool_t Status) { fEvtHeaderIsNew = Status; }
    Bool_t IsEvtHeaderNew() { return fEvtHeaderIsNew; }

    /** Use the Backgraund RunID to initialize the parameter for the run */
    void UseRunIdFromBG();
    /** Use the Backgraund RunID to initialize the parameter for the run
     *@param identifier: Signal file identifier to be used by default we take the first Signal
     */
    void UseRunIdfromSG(UInt_t identifier = 1);

  private:
    /**IO manager */
    FairRootManager* fRootManager;

    /** Title of input source, could be input, background or signal*/
    TString fInputTitle;
    /**ROOT file*/
    TFile* fRootFile;
    /** List of all files added with AddFriend */
    std::list<TString> fFriendFileList;                                 //!
    std::list<TString> fInputChainList;                                 //!
    std::map<TString, TChain*> fFriendTypeList;                         //!
    std::list<TString> fInputLevel;                                     //!
    std::map<TString, std::multimap<TString, TArrayI>> fRunIdInfoAll;   //!
    /** list of folders from all input (and friends) files*/
    TObjArray* fListFolder;   //!
    /**folder structure of output*/
    TFolder* fCbmout;
    /**folder structure of input*/
    TFolder* fCbmroot;
    /***/
    UInt_t fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t IsInitialized;

    /** MC Event header */
    FairMCEventHeader* fMCHeader;   //!

    /**Event Header*/
    FairEventHeader* fEvtHeader;   //!

    /**Output Event Header*/
    FairEventHeader* fOutHeader;   //!

    /**File Header*/
    FairFileHeader* fFileHeader;   //!

    /** This is true if the event time used, came from simulation*/
    Bool_t fEventTimeInMCHeader;   //!
    /**This flag is true if the event header was created in this session
     * otherwise it is false which means the header was created in a previous data
     * level and used here (e.g. in the digi)
     */
    Bool_t fEvtHeaderIsNew;   //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t fCurrentEntryNo;   //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t fTimeforEntryNo;   //!
    /* /\**No of entries in BG Chain*\/ */
    UInt_t fNoOfBGEntries;   //!
    /* /\**Hold the current entry for each input chain*\/ */
    std::map<UInt_t, UInt_t> fCurrentEntry;   //!

    /** min time for one event (ns) */
    Double_t fEventTimeMin;   //!
    /** max time for one Event (ns) */
    Double_t fEventTimeMax;   //!
    /** Time of event since th start (ns) */
    Double_t fEventTime;   //!
    /** Time of particles in beam (ns) */
    Double_t fBeamTime;   //!
    /** Time without particles in beam (gap) (ns) */
    Double_t fGapTime;   //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t fEventMeanTime;   //!
    /** used to generate random numbers for event time; */
    std::unique_ptr<TF1> fTimeProb;   //!

    /**holds the SB ratio by number*/
    std::map<UInt_t, Double_t> fSignalBGN;   //!
    /* /\**True for background window in entry units*\/ */
    Bool_t fSBRatiobyN;   //!
    /* /\**True for background window in time units (ns) *\/ */
    Bool_t fSBRatiobyT;   //!

    /**Actual identifier of the added signals, this is used to identify how many signals are added*/
    UInt_t fActualSignalIdentifier;   //!
    /** Total number of signals added (Types and not files!)*/
    UInt_t fNoOfSignals;   //!
    /** list of chains which has to be created for the different signals*/
    std::list<TString>* fSignalChainList;   //!
    /**Chain containing the background*/
    TChain* fBackgroundChain;                    //!
    std::map<UInt_t, TChain*> fSignalTypeList;   //!

    /**True if RunId is taken from Backgraund*/
    Bool_t fRunIdFromBG;   //!
    /**True if RunId is taken from Signal */
    Bool_t fRunIdFromSG;   //!
    /** Identifier of signal file for RunID
     * Zero if RunId is taken from BG.
     */
    UInt_t fRunIdFromSG_identifier;   //!

    /**Read one event from source to find out which RunId to use*/
    Bool_t SpecifyRunId() override;

    FairMixedSource(const FairMixedSource&);
    FairMixedSource& operator=(const FairMixedSource&);

  public:
    ClassDefOverride(FairMixedSource, 0);
};

#endif /* defined(__FAIRROOT__FairMixedSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairSource                            -----
// -----                    Created 01.11.2013 by F. Uhlig                 -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRSOURCE_H
#define FAIRSOURCE_H

#include "FairLogger.h"
#include "TClass.h"

#include <Rtypes.h>
#include <TObject.h>

class FairEventHeader;

enum Source_Type
{
    kONLINE,
    kFILE
};

class FairSource : public TObject
{
  public:
    FairSource();
    FairSource(const FairSource& source);
    virtual ~FairSource();
    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t = 0) = 0;
    virtual Bool_t SpecifyRunId() = 0;
    virtual void Close() = 0;
    virtual void Reset() = 0;
    virtual Bool_t ActivateObject(TObject**, const char*) { return kFALSE; }
    virtual Bool_t ActivateObjectAny(void**, const std::type_info&, const char*) { return kFALSE; }
    virtual Source_Type GetSourceType() = 0;
    virtual void SetParUnpackers() = 0;
    virtual Bool_t InitUnpackers() = 0;
    virtual Bool_t ReInitUnpackers() = 0;
    /**Check the maximum event number we can run to*/
    virtual Int_t CheckMaxEventNo(Int_t = 0) { return -1; }
    /**Read the tree entry on one branch**/
    virtual void ReadBranchEvent(const char*) { return; }
    virtual void ReadBranchEvent(const char*, Int_t) { return; }
    virtual void FillEventHeader(FairEventHeader* feh);
    void SetRunId(Int_t runId) { fRunId = runId; }
    Int_t GetRunId() const { return fRunId; }

  protected:
    Int_t fRunId;

  public:
    ClassDef(FairSource, 2);
};

namespace {

template<typename S>
bool ActivateObjectAnyImpl(S* source, void** obj, const std::type_info& info, const char* brname)
{
    // we check if the types match at all
    auto br = source->GetBranch(brname);
    if (!br) {
        // branch not found in source
        return false;
    }

    // look up the TClass and resulting typeid stored in this branch
    auto cl = TClass::GetClass(br->GetClassName());
    if (!cl) {
        // class not found
        return false;
    }

    auto storedtype = cl->GetTypeInfo();

    // check consistency of types
    if (info.hash_code() != storedtype->hash_code()) {
        LOG(info) << "Trying to read from branch " << brname << " with wrong type " << info.name()
                  << " (expected: " << storedtype->name() << ")\n";
        return false;
    }
    source->SetBranchStatus(brname, 1);
    // force to use the (void*) interface which is non-checking
    source->SetBranchAddress(brname, (void*)obj);
    return true;
}

}   // namespace

#endif
#ifndef FAIR_LINK_MANAGER_H
#define FAIR_LINK_MANAGER_H

#include <Rtypes.h>    // for Bool_t, Int_t, UInt_t, etc
#include <TMCtls.h>    // for multi-threading
#include <TObject.h>   // for TObject
#include <set>         // for set of branch types to ignore

class FairLogger;

class FairLinkManager : public TObject
{
  public:
    /**ctor*/
    FairLinkManager();
    /**dtor*/
    virtual ~FairLinkManager();

    /** static access method */
    static FairLinkManager* Instance();
    virtual void AddIgnoreType(Int_t type);   ///< Adds a BranchId (Type) to which links are not included in the link
                                              ///< list. Either ignore types or include types can be given.
    virtual Bool_t IsIgnoreType(Int_t type) const;

    virtual void AddIncludeType(Int_t type);   ///< Adds a BranchId (Type) to which links are included in the link list.
                                               ///< Either ignore types or include types can be given (XOR).

    std::set<Int_t> GetIgnoreTypes() const { return fIgnoreTypes; }

  private:
    /**private methods*/
    FairLinkManager(const FairLinkManager&);
    FairLinkManager& operator=(const FairLinkManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/

    std::set<Int_t> fIgnoreTypes;   //!
    Bool_t fIgnoreSetting;

    /**Singleton instance*/
    static TMCThreadLocal FairLinkManager* fgInstance;

    FairLogger* fLogger;   //!

    ClassDef(FairLinkManager, 1);
};

#endif   // FAIR_ROOT_MANAGER_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairRadGridManager source file             -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------
#ifndef FAIRRADGRIDMANAGER_H
#define FAIRRADGRIDMANAGER_H 1

#include <Rtypes.h>           // for Float_t, Double_t, Int_t, etc
#include <TLorentzVector.h>   // for TLorentzVector
#include <TObjArray.h>        // for TObjArray
#include <TString.h>          // for TString
#include <iostream>           // for basic_ostream::operator<<, etc

class FairMesh;
class TClonesArray;

/**
 * @class FairRadGridManager
 */

class FairRadGridManager
{
  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadGridManager class.
     */
    FairRadGridManager();
    /**
     * Destructor.
     */
    virtual ~FairRadGridManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadGridManager, 1);

  private:
    FairRadGridManager(const FairRadGridManager&);
    FairRadGridManager& operator=(const FairRadGridManager&);

    static FairRadGridManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray* fPointCollection;
    /**track index */
    Int_t fTrackID;   //!
    /**volume id */
    Int_t fVolumeID;   //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;   //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;   //!
    /**  momentum in*/
    TLorentzVector fMomIn;   //!
    /**  momentum out*/
    TLorentzVector fMomOut;   //!
    /**track time */
    Double_t fTime;   //!
    /**track length */
    Double_t fLength;   //!
    /** energy loss */
    Double_t fELoss;   //!
    /** mass umber*/
    Float_t fA;
    /** atomic number*/
    Float_t fZmat;
    /**  density */
    Float_t fDensity;
    /**radition length */
    Float_t fRadl;
    /**absorption length */
    Float_t fAbsl;
    /**estimator*/
    Int_t fEstimator;
    /** the mesh */
    TObjArray* fMeshList;
    /** output file name */
    TString fOutputFileName;

  public:
    TObjArray* GetMeshList() { return fMeshList; }
    void AddMeshList(TObjArray* list)
    {
        std::cout << " grid manag " << list->GetEntriesFast() << std::endl;
        fMeshList = list;
    }
    Bool_t IsTrackInside(TLorentzVector& vec, FairMesh* aMesh);
    Bool_t IsTrackEntering(TLorentzVector& vec1, TLorentzVector& vec2);
    /** fill the 2D mesh */
    void FillMeshList();
    /**initialize the manager*/
    void Init();
    /**reset*/
    void Reset();
    /**set output file name*/
    void SetOutputFileName(TString tempString) { fOutputFileName = tempString; }
    TString GetOutputFileName() { return fOutputFileName; }
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadGridManager object, created
     * with FairRadGridManager::FairRadGridManager().
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated("Maybe use FairMCApplcation::GetRadGridMan()")]] static FairRadGridManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenManager source file             -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADLENMANAGER_H
#define FAIRRADLENMANAGER_H 1

#include <Rtypes.h>           // for Float_t, Double_t, Int_t, etc
#include <TLorentzVector.h>   // for TLorentzVector

class TClonesArray;
class TVirtualMC;

/**
 * @class FairRadLenManager
 */

class FairRadLenManager
{
  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadLenManager class.
     */
    FairRadLenManager();

    /**
     * Destructor.
     */
    virtual ~FairRadLenManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadLenManager, 1);

  private:
    FairRadLenManager(const FairRadLenManager&);
    FairRadLenManager& operator=(const FairRadLenManager&);

    static FairRadLenManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray* fPointCollection;
    /**track index */
    Int_t fTrackID;   //!
    /**volume id */
    Int_t fVolumeID;   //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;   //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;   //!
    /**  momentum in*/
    TLorentzVector fMomIn;   //!
    /**  momentum out*/
    TLorentzVector fMomOut;   //!
    /**track time */
    Double_t fTime;   //!
    /**track length */
    Double_t fLength;   //!
    /** energy loss */
    Double_t fELoss;   //!
    /** mass umber*/
    Float_t fA;
    /** atomic number*/
    Float_t fZmat;
    /**  density */
    Float_t fDensity;
    /**radition length */
    Float_t fRadl;
    /**absorption length */
    Float_t fAbsl;

  public:
    /**Add point to collection*/
    void AddPoint(TVirtualMC* aMC, const Int_t ModuleId);
    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated("Use AddPoint(TVirtualMC*, ...)")]] void AddPoint(const Int_t ModuleId);
    /**initialize the manager*/
    void Init();
    /**reset*/
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadLenManager object, created
     * with FairRadLenManager::FairRadLenManager().
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] static FairRadLenManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadMapManager source file            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADMAPMANAGER_H
#define FAIRRADMAPMANAGER_H 1

#include <Rtypes.h>           // for Double_t, Float_t, Int_t, etc
#include <TLorentzVector.h>   // for TLorentzVector

class TClonesArray;
class TMap;
class TVirtualMC;

/**
 * @class FairRadMapManager
 */

class FairRadMapManager
{
  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadMapManager class.
     */
    FairRadMapManager();

    /**
     * Destructor.
     */
    virtual ~FairRadMapManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadMapManager, 1);

  private:
    FairRadMapManager(const FairRadMapManager&);
    FairRadMapManager& operator=(const FairRadMapManager&);

    static FairRadMapManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray* fPointCollection;
    /**track index */
    Int_t fTrackID;   //!
    /**volume id */
    Int_t fVolumeID;   //!
    /** pid */
    Int_t fPdg;   //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;   //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;   //!
    /**  momentum in*/
    TLorentzVector fMomIn;   //!
    /**  momentum out*/
    TLorentzVector fMomOut;   //!
    /**track time */
    Double_t fTime;   //!
    /**track length */
    Double_t fLength;   //!
    /**track setp */
    Double_t fStep;
    /** energy loss */
    Double_t fELoss;   //!
    /**dose */
    Double_t fDose;
    Double_t fDoseSL;
    /** mass umber*/
    Float_t fA;
    /** atomic number*/
    Float_t fZmat;
    /** radiation length*/
    Float_t fRadl;
    /**  density */
    Float_t fDensity;
    /**absorption length */
    Float_t fAbsl;
    //**volume, mass */
    Double_t fActVol;
    Double_t fActMass;

    TMap* fMassMap;

  public:
    /**Add point to collection*/
    void AddPoint(TVirtualMC* aMC, const Int_t);
    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated("Use AddPoint(TVirtualMC*, ...)")]] void AddPoint(const Int_t ModuleId);
    /**initialize the manager*/
    void Init();
    /**reset*/
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadMapManager object, created
     * with FairRadMapManager::FairRadMapManager().
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] static FairRadMapManager* Instance();
    //  void GetGeoManager();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairRingSorter.h
 *
 *  Created on: Jul 15, 2010
 *      Author: stockman
 */

#ifndef FairRingSorter_H_
#define FairRingSorter_H_

#include <Rtypes.h>    // for FairRingSorter::Class, etc
#include <TObject.h>   // for TObject
#include <iostream>    // for operator<<, ostream, etc
#include <map>         // for multimap
#include <utility>     // for pair
#include <vector>      // for vector

class FairTimeStamp;

class FairRingSorter : public TObject
{
  public:
    FairRingSorter(int size = 100, double width = 10)
        : TObject()
        , fRingBuffer(size)
        , fOutputData()
        , fLowerBoundPointer(0, 0)
        , fCellWidth(width)
        , fVerbose(0)
    {}

    virtual ~FairRingSorter(){};

    virtual FairTimeStamp* CreateElement(FairTimeStamp* data);

    virtual void AddElement(FairTimeStamp* digi, double timestamp);
    virtual void WriteOutElements(int index);   ///< writes out the entries from LowerBoundPointer up to index
    virtual void WriteOutElement(int index);    ///< writes out the entry at the index and clears it
    virtual void WriteOutAll() { WriteOutElements(fLowerBoundPointer.first); }
    virtual double GetBufferSize() { return fCellWidth * fRingBuffer.size(); }
    virtual std::vector<FairTimeStamp*> GetOutputData() { return fOutputData; }

    virtual void DeleteOutputData() { fOutputData.clear(); }
    virtual void SetLowerBound(double timestampOfHitToWrite);

    virtual void print(std::ostream& out = std::cout)
    {
        out << "RingSorter: Size " << fRingBuffer.size() << " CellWidth: " << fCellWidth << "\n";
        out << "LowerBoundPointer at index: " << fLowerBoundPointer.first << " Time: " << fLowerBoundPointer.second
            << "\n";
        out << "| ";
        for (unsigned int i = 0; i < fRingBuffer.size(); i++) {
            out << fRingBuffer[i].size() << " |";
        }
        out << std::endl;
    }

  private:
    int CalcIndex(double val);
    std::vector<std::multimap<double, FairTimeStamp*>> fRingBuffer;
    std::vector<FairTimeStamp*> fOutputData;
    std::pair<int, double> fLowerBoundPointer;
    double fCellWidth;
    int fVerbose;

    ClassDef(FairRingSorter, 1);
};

#endif /* FairRingSorter_H_ */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

/** FairRingSorterTask.h
 **
 **/

#ifndef FairRingSorterTask_H
#define FairRingSorterTask_H

#include "FairRingSorter.h"   // for FairRingSorter
#include "FairTask.h"         // for FairTask, InitStatus

#include <Rtypes.h>    // for Bool_t, Int_t, kTRUE, etc
#include <TString.h>   // for TString

class FairTimeStamp;
class TClonesArray;

class FairRingSorterTask : public FairTask
{
  public:
    /** Default constructor **/
    FairRingSorterTask()
        : FairTask("SorterTask")
        , fSorter(0)
        , fPersistance(kTRUE)
        , fDigiPixelMCInfo(kFALSE)
        , fNumberOfCells(1000)
        , fWidthOfCells(10)
        , fInputBranch()
        , fInputArray(0)
        , fOutputBranch()
        , fFolder()
        , fOutputArray(0)
        , fEntryNr(0)
    {
        SetVerbose(0);
    }

    /** Named constructor **/
    FairRingSorterTask(const char* name)
        : FairTask(name)
        , fSorter(0)
        , fPersistance(kTRUE)
        , fDigiPixelMCInfo(kFALSE)
        , fNumberOfCells(1000)
        , fWidthOfCells(10)
        , fInputBranch()
        , fInputArray(0)
        , fOutputBranch()
        , fFolder()
        , fOutputArray(0)
        , fEntryNr(0)
    {
        SetVerbose(0);
    }

    FairRingSorterTask(Int_t numberOfCells,
                       Double_t widthOfCells,
                       TString inputBranch,
                       TString outputBranch,
                       TString folderName)
        : FairTask("Sorter")
        , fSorter(0)
        , fPersistance(kTRUE)
        , fDigiPixelMCInfo(kFALSE)
        , fNumberOfCells(numberOfCells)
        , fWidthOfCells(widthOfCells)
        , fInputBranch(inputBranch)
        , fInputArray(0)
        , fOutputBranch(outputBranch)
        , fFolder(folderName)
        , fOutputArray(0)
        , fEntryNr(0)
    {
        SetVerbose(0);
    }

    /** Destructor **/
    ~FairRingSorterTask() override { delete fSorter; }

    /** Virtual method Init **/
    InitStatus Init() override;
    InitStatus ReInit() override;

    /** Virtual method Exec **/
    void Exec(Option_t* opt) override;
    void FinishEvent() override;
    void FinishTask() override;

    void SetPersistance(Bool_t p = kTRUE) { fPersistance = p; };
    Bool_t GetPersistance() { return fPersistance; };

    virtual void AddNewDataToTClonesArray(FairTimeStamp* data);
    virtual FairRingSorter* InitSorter(Int_t numberOfCells, Double_t widthOfCells) const;

  protected:
    FairRingSorter* fSorter;
    /** switch to turn on/off storing the arrays to a file*/
    Bool_t fPersistance;
    /** switch to turn on/off storing additional MC Info of Digis*/
    Bool_t fDigiPixelMCInfo;
    Int_t fNumberOfCells;
    Double_t fWidthOfCells;   // in ns
    /** Input array of PndSdsPixelDigis **/
    TString fInputBranch;
    TClonesArray* fInputArray;
    /** Output array of sorted PndSdsDigis **/
    TString fOutputBranch;
    TString fFolder;
    TClonesArray* fOutputArray;
    Int_t fEntryNr;
    FairRingSorterTask(const FairRingSorterTask&);
    FairRingSorterTask& operator=(const FairRingSorterTask&);

    ClassDefOverride(FairRingSorterTask, 2);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_ROOT_MANAGER_H
#define FAIR_ROOT_MANAGER_H

#include "FairLogger.h"
#include "FairSink.h"
#include "FairSource.h"

#include <Rtypes.h>      // for Bool_t, Int_t, UInt_t, etc
#include <TChain.h>      // for TChain
#include <TObject.h>     // for TObject
#include <TRefArray.h>   // for TRefArray
#include <TString.h>     // for TString, operator<
#include <map>           // for map, multimap, etc
#include <memory>
#include <string>
#include <type_traits>   // is_pointer, remove_pointer, is_const, remove...
#include <typeinfo>
#include <vector>

class BinaryFunctor;
class FairEventHeader;
class FairFileHeader;
class FairLink;
class FairTSBufferFunctional;
class FairWriteoutBuffer;
class TBranch;
class TClonesArray;
class TObjArray;
class TCollection;
class TFile;
class TFolder;
class TList;
class TNamed;
class TTree;

/**
 * I/O Manager class
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairRootManager : public TObject
{
  public:
    /**dtor*/
    ~FairRootManager() override;
    Bool_t AllDataProcessed();
    /** Add a branch name to the Branchlist and give it an id*/
    Int_t AddBranchToList(const char* name);
    /**
    Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist   */
    Int_t CheckBranch(const char* BrName);

    void CloseSink()
    {
        if (fSink) {
            fSink->Close();
        }
    }
    /**Create a new file and save the current TGeoManager object to it*/
    void CreateGeometryFile(const char* geofile);
    void Fill();
    void LastFill();
    TClonesArray* GetEmptyTClonesArray(TString branchName);
    TClonesArray* GetTClonesArray(TString branchName);
    /**Update the list of Memory branches from the source used*/
    void UpdateBranches();

    /**Return branch name by Id*/
    TString GetBranchName(Int_t id);
    /**Return Id of a branch named */
    Int_t GetBranchId(TString const& BrName);

    /**The MCTrack branch stands out since it is required by the framework algorithms**/
    Int_t GetMCTrackBranchId() const { return fMCTrackBranchId; }

    /**Return a TList of TObjString of branch names available in this session*/
    TList* GetBranchNameList() { return fBranchNameList; }

    /**  Get the Object (container) for the given branch name,
         this method can be used to access the data of
         a branch that was created from a different
         analysis task, and not written in the tree yet.
         the user have to cast this pointer to the right type.
         Return a pointer to the object (collection) saved in the fInChain branch named BrName*/
    TObject* GetObject(const char* BrName);

    /// Initializes and returns a default object for a branch or looks it up when it exists already.
    /// Returns nullptr when the branch does not exist or looking up with wrong type.
    /// The name Init indicates that this functions should be called only in Init sections of FairTasks.
    /// The returned default object will be filled with data by the framework.
    template<typename T>
    T InitObjectAs(const char* BrName);

    /** Return a pointer to the object (collection) saved in the fInTree branch named BrName*/
    Double_t GetEventTime();
    /** Returns a clone of the data object the link is pointing to. The clone has to be deleted in the calling code! */
    TObject* GetCloneOfLinkData(const FairLink link);
    /** Get the data of the given branch name,
     *  this method runs over multiple entries
     *  of the tree and selects the data according
     *  to the function and the parameter given.
     */

    TClonesArray* GetCloneOfTClonesArray(const FairLink link);

    void InitTSBuffer(TString branchName, BinaryFunctor* function);
    TClonesArray* GetData(TString branchName, BinaryFunctor* function, Double_t parameter);
    TClonesArray* GetData(TString branchName,
                          BinaryFunctor* startFunction,
                          Double_t startParameter,
                          BinaryFunctor* stopFunction,
                          Double_t stopParameter);
    void RegisterTSBuffer(TString branchName, FairTSBufferFunctional* functionalBuffer)
    {
        fTSBufferMap[branchName] = functionalBuffer;
    }
    void TerminateTSBuffer(TString branchName);
    void TerminateAllTSBuffer();
    FairTSBufferFunctional* GetTSBuffer(TString branchName) { return fTSBufferMap[branchName]; }

    /** static access method */
    static FairRootManager* Instance();

    /**Read a single entry from background chain*/
    Int_t ReadEvent(Int_t i = 0);
    /** Read a single entry from each branch that is not read via TSBuffers*/
    Int_t ReadNonTimeBasedEventFromBranches(Int_t i = 0);
    /**Read the tree entry on one branch**/
    void ReadBranchEvent(const char* BrName);
    /**Read the tree entry on one branch for a specific entry**/
    void ReadBranchEvent(const char* BrName, Int_t entry);

    /**Read all entries from input tree(s) with time stamp from current time to dt (time in ns)*/

    Int_t GetRunId();

    Bool_t ReadNextEvent(Double_t dt);
    /**create a new branch in the output tree
     *@param name            Name of the branch to create
     *@param Foldername      Folder name containing this branch (e.g Detector name)
     *@param obj             Pointer of type TNamed (e.g. MCStack object)
     *@param toFile          if kTRUE, branch will be saved to the tree*/
    void Register(const char* name, const char* Foldername, TNamed* obj, Bool_t toFile);
    /**create a new branch in the output tree
     *@param name            Name of the branch to create
     *@param Foldername      Folder name containing this branch (e.g Detector name)
     *@param obj             Pointer of type TCollection (e.g. TClonesArray of hits, points)
     *@param toFile          if kTRUE, branch will be saved to the tree*/
    void Register(const char* name, const char* Foldername, TCollection* obj, Bool_t toFile);

    /** create a new branch based on an arbitrary type T (for which a dictionary must exist) **/
    template<typename T>
    void RegisterAny(const char* name, T*& obj, Bool_t toFile);

    void RegisterInputObject(const char* name, TObject* obj);

    TClonesArray* Register(TString branchName, TString className, TString folderName, Bool_t toFile);
    /** Register a new FairWriteoutBuffer to the map. If a Buffer with the same map key already exists the given buffer
     * will be deleted and the old will be returned!*/
    FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer);
    /**Update the list of time based branches in the output file*/
    void UpdateListOfTimebasedBranches();
    /**Use time stamps to read data and not tree entries
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] void RunWithTimeStamps() {}

    /**Set the branch name list*/
    void SetBranchNameList(TList* list);
    /** Replace the time based branch name list*/
    void SetTimeBasedBranchNameList(TList* list);

    /** \deprecated Deprecated in v18.8, will be removed in v20. */
    [[deprecated]] void FillEventHeader(FairEventHeader* feh)
    {
        if (fSource)
            fSource->FillEventHeader(feh);
    }

    /**Enables a last Fill command after all events are processed to store any data which is still in Buffers*/
    void SetLastFill(Bool_t val = kTRUE) { fFillLastData = val; }
    /**When creating TTree from TFolder the fullpath of the objects is used as branch names
     * this method truncate the full path from the branch names
     */

    Int_t Write(const char* name = nullptr, Int_t option = 0, Int_t bufsize = 0) override;
    /** Write the current TGeoManager to file*/
    void WriteGeometry();
    /**Write the file header object to the output file*/
    void WriteFileHeader(FairFileHeader* f);
    /**Write the folder structure used to create the tree to the output file */
    void WriteFolder();

    /**Check the maximum event number we can run to*/
    Int_t CheckMaxEventNo(Int_t EvtEnd = 0);

    void StoreWriteoutBufferData(Double_t eventTime);
    void StoreAllWriteoutBufferData();
    void DeleteOldWriteoutBufferData();

    Int_t GetEntryNr() { return fEntryNr; }
    void SetEntryNr(Int_t val) { fEntryNr = val; }

    void SetUseFairLinks(Bool_t val) { fUseFairLinks = val; };
    Bool_t GetUseFairLinks() const { return fUseFairLinks; };

    /**
     * @param Status : if  true all inputs are mixed, i.e: each read event will take one entry from each input and put
     * them in one big event and send it to the next step
     */
    /* void SetMixAllInputs(Bool_t Status) { */
    /*    fMixAllInputs=kTRUE; */
    /* } */

    /** These methods have been moved to the FairFileSource */
    void SetSource(FairSource* tempSource) { fSource = tempSource; }
    FairSource* GetSource() { return fSource; }
    Bool_t InitSource();

    void SetSink(FairSink* tempSink) { fSink = tempSink; }
    FairSink* GetSink() { return fSink; }
    Bool_t InitSink();

    void SetListOfFolders(TObjArray* ta) { fListFolder = ta; }
    TChain* GetInChain() { return fSourceChain; }
    TChain* GetSignalChainNo(UInt_t i) { return fSignalChainList[i]; }
    TTree* GetInTree()
    {
        if (fSourceChain)
            return fSourceChain->GetTree();
        return 0;
    }
    const TFile* GetRootFile()
    {
        if (fSourceChain)
            return fSourceChain->GetFile();
        return 0;
    }
    TFile* GetInFile()
    {
        if (fSourceChain)
            return fSourceChain->GetFile();
        return 0;
    }
    void SetInChain(TChain* tempChain, Int_t ident = -1);
    /* /\**Set the input tree when running on PROOF worker*\/ */

    void SetFinishRun(Bool_t val = kTRUE) { fFinishRun = val; }
    Bool_t FinishRun() { return fFinishRun; }

    static void SetTreeName(const std::string& tname) { fTreeName = tname; }
    static void SetFolderName(const std::string& tname) { fFolderName = tname; }

    const static char* GetTreeName();
    const static char* GetFolderName();

    /**public Members for multi-threading */
    Int_t GetInstanceId() const { return fId; }
    void UpdateFileName(TString& fileName);

    /** Return a pointer to the output File of type TFile */
    TFile* GetOutFile();
    /** Return a pointer to the output tree of type TTree */
    TTree* GetOutTree();

    /**Read one event from source to find out which RunId to use*/
    Bool_t SpecifyRunId();

  private:
    // helper struct since std::pair has problems with type_info
    struct TypeAddressPair
    {
        TypeAddressPair(const std::type_info& oi, const std::type_info& pi, void* a)
            : origtypeinfo(oi)
            , persistenttypeinfo(pi)
            , ptraddr(a)
        {}
        const std::type_info& origtypeinfo;         // type_info of type addr points to
        const std::type_info& persistenttypeinfo;   // type_info of ROOT persistent branch (drops pointers)
        void* ptraddr;                              // address of a pointer (pointing to origtypeinfo);
    };

    /**private methods*/
    /**ctor*/
    FairRootManager();
    FairRootManager(const FairRootManager&);
    FairRootManager& operator=(const FairRootManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/
    TObject* ActivateBranch(const char* BrName);
    void AddFriends();
    /**Add a branch to memory, it will not be written to the output files*/
    void AddMemoryBranch(const char*, TObject*);

    template<typename T>
    void AddMemoryBranchAny(const char* name, T** obj);
    template<typename T>
    T GetMemoryBranchAny(const char* name) const;

    template<typename T>
    void RegisterImpl(const char* name, const char* Foldername, T* obj, Bool_t toFile);

    /** Internal Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist
    */
    Int_t CheckBranchSt(const char* BrName);
    /**Create the Map for the branch persistency status  */
    void CreatePerMap();
    TObject* GetMemoryBranch(const char*);
    //   void                GetRunIdInfo(TString fileName, TString inputLevel);

    FairWriteoutBuffer* GetWriteoutBuffer(TString branchName);

    // private helper function to emit a warning
    void EmitMemoryBranchWrongTypeWarning(const char* brname, const char* typen1, const char* typen2) const;

    /**private Members*/
    Int_t fOldEntryNr;
    /**folder structure of output*/
    TFolder* fOutFolder;
    /**folder structure of input*/
    TFolder* fRootFolder;
    /** current time in ns*/
    Double_t fCurrentTime;
    TObject** fObj2;   //!
    /** Counter for the number of branches activiated */
    Int_t fNObj;   //!
    /** A list which hold the pointer to the branch
     * and the name of the branch in memory, it contains all branches (TClonesArrays)
     * persistance and Memory only branches
     */
    std::map<TString, TObject*> fMap;   //!

    /**folder name variable*/
    static std::string fFolderName;   //!
    /**tree name variable*/
    static std::string fTreeName;   //!
    static std::string GetNameFromFile(const char* namekind);

    /// A map of branchnames to typeinformation + memory address;
    /// used for branches registered with RegisterAny; use of ptr here
    /// since type_info cannot be copied
    std::map<std::string, std::unique_ptr<TypeAddressPair const>> fAnyBranchMap;   //!

    /**Branch id for this run */
    Int_t fBranchSeqId;
    /**List of branch names as TObjString*/
    TList* fBranchNameList;   //!

    /**The branch ID for the special (required) MCTrack branch**/
    Int_t fMCTrackBranchId;   //!

    /**List of Time based branchs names as TObjString*/
    TList* fTimeBasedBranchNameList;   //!
    /** Internally used to compress empty slots in data buffer*/
    std::map<TString, TClonesArray*> fActiveContainer;
    /** Internally used to read time ordered data from branches*/
    std::map<TString, FairTSBufferFunctional*> fTSBufferMap;     //!
    std::map<TString, FairWriteoutBuffer*> fWriteoutBufferMap;   //!
    std::map<Int_t, TBranch*> fInputBranchMap;                   //!    //Map of input branch ID with TBranch pointer
    /**Flag for creation of Map for branch persistency list  */
    Bool_t fBranchPerMap;
    /** Map for branch persistency list */
    std::map<TString, Int_t> fBrPerMap;   //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t fCurrentEntryNo;   //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t fTimeforEntryNo;   //!
    Bool_t fFillLastData;     //!
    Int_t fEntryNr;           //!

    TObjArray* fListFolder;   //!

    FairSource* fSource;

    TChain* fSourceChain = nullptr;
    std::map<UInt_t, TChain*> fSignalChainList;   //!

    FairEventHeader* fEventHeader;

    FairSink* fSink;

    Bool_t fUseFairLinks;   //!
    Bool_t fFinishRun;      //!
    /** List of branches used with no-time stamp in time-based session */
    TRefArray fListOfNonTimebasedBranches{};   //!

    /**private Members for multi-threading */
    // global static data members
    static Int_t fgCounter;   // The counter of instances
    // data members
    Int_t fId;   // This manager ID

    ClassDefOverride(FairRootManager, 14);
};

// FIXME: move to source since we can make it non-template dependent
template<typename T>
void FairRootManager::AddMemoryBranchAny(const char* brname, T** obj)
{
    if (fAnyBranchMap.find(brname) == fAnyBranchMap.end()) {
        auto& ot = typeid(T*);
        auto& pt = typeid(T);
        fAnyBranchMap[brname] = std::unique_ptr<TypeAddressPair const>(new TypeAddressPair(ot, pt, (void*)obj));
    }
}

// try to retrieve an object address from the registered branches/names
template<typename T>
T FairRootManager::GetMemoryBranchAny(const char* brname) const
{
    static_assert(std::is_pointer<T>::value, "Return type of GetMemoryBranchAny has to be a pointer");
    using P = typename std::remove_pointer<T>::type;
    auto iter = fAnyBranchMap.find(brname);
    if (iter != fAnyBranchMap.end()) {
        // verify type consistency
        if (typeid(P).hash_code() != iter->second->origtypeinfo.hash_code()) {
            EmitMemoryBranchWrongTypeWarning(brname, typeid(P).name(), iter->second->origtypeinfo.name());
            return nullptr;
        }
        return static_cast<T>(iter->second->ptraddr);
    }
    return nullptr;
}

template<typename T>
void FairRootManager::RegisterAny(const char* brname, T*& obj, bool persistence)
{
    AddBranchToList(brname);
    // we are taking the address of the passed pointer
    AddMemoryBranchAny<T>(brname, &obj);
    if (persistence) {
        auto& ot = typeid(T*);
        auto& pt = typeid(T);
        if (fSink)
            fSink->RegisterAny(brname, ot, pt, &obj);
        else
            LOG(fatal) << "The sink does not exist to store persistent branches.";
    }
}

// this function serves as a factory (or lookup) for memory managed
// instances associated to branches
// it returns a pointer to unmodifiable instance of T
template<typename TPtr>
TPtr FairRootManager::InitObjectAs(const char* brname)
{
    static_assert(std::is_pointer<TPtr>::value, "Return type of GetObjectAs has to be a pointer");
    using X = typename std::remove_pointer<TPtr>::type;
    static_assert(std::is_const<X>::value, "Return type of GetObjectAs has to be pointer to const class");
    using T = typename std::remove_const<X>::type;

    // is there already an object associated to the branch in memory??
    // then just return
    T** obj = GetMemoryBranchAny<T**>(brname);
    // obj is some address/instance holding TPtr instances
    if (obj != nullptr)
        return *obj;

    if (!fSource) {
        return nullptr;
    }

    // it does not seem to be the case, let us create the pointer which will be initialized
    // with the data (pointer to T)
    T** addr = new T*;
    // init the pointee to a default obj which we can return
    (*addr) = new T;
    // try to find and activate in the source
    auto succeeded = fSource->ActivateObjectAny((void**)addr, typeid(T), brname);

    if (!succeeded) {
        delete (*addr);
        delete addr;
        return nullptr;
    }
    // add into branch list
    AddMemoryBranchAny<T>(brname, addr);

    // NOTE: ideally we would do proper resource management for addr and *addr
    // since the FairRootManager becomes owner of these pointers/instances; Unfortunately this
    // is quite a difficult task since we would have to store something like std::unique_ptr<T> in a member
    // container which we cannot know a priori; Some solutions we could think of in the future are
    // a) use the Destructor mechanism of ROOT::TClass since we still have the type info.
    // b) investigate if boost::any could be of help here
    // In any case, this problem is not very critical in the sense that FairRootManager is a singleton and hence
    // cannot really leak memory (Assuming that the destructors of T are not doing something non-trivial).
    return *addr;
}

#endif   // FAIR_ROOT_MANAGER_H
/********************************************************************************
 * Copyright (C) 2014-2023 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUN_H
#define FAIRRUN_H

#include "FairAlignmentHandler.h"
#include "FairEventHeader.h"
#include "FairSink.h"
#include "FairSource.h"

#include <Rtypes.h>   // for Int_t, Bool_t, etc
#include <TMCtls.h>   // for multi-threading
#include <TNamed.h>   // for TNamed
#include <TString.h>
#include <map>
#include <memory>
#include <string>

class FairEventHeader;
class FairFileHeader;
class FairRootManager;
class FairRuntimeDb;
class FairSink;
class FairTask;
class TFile;
class FairField;
class TGeoHMatrix;

/**
 * Configure the Simuation or Analysis
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairRun : public TNamed
{
    friend class FairMCApplication;

  public:
    /**
     * default ctor
     */
    FairRun(Bool_t isMaster = kTRUE);
    /**
     * default dtor
     */
    ~FairRun() override;
    /**
     * static instance
     */
    static FairRun* Instance();
    /**
     * Add a FAIRTask to the simulation or analysis
     */
    virtual void AddTask(FairTask* t);
    virtual void StoreTaskNames(const FairTask* t);
    virtual void SetTask(FairTask* t);
    /**
     * Initialize the Simulation or analysis
     */
    virtual void Init() = 0;
    /*
     * Get the magnetic field *
     */
    virtual FairField* GetField() = 0;
    /**
     * run the analysis or simulation
     */
    virtual void Run(Int_t NStart = 0, Int_t NStop = 0) = 0;
    /**
     *       Set the experiment dependent run header
     *       for each run
     */
    void SetEventHeader(FairEventHeader* EvHeader) { fEvtHeader = EvHeader; }
    /**
     * return a pointer to the RuntimeDB
     */
    FairRuntimeDb* GetRuntimeDb() { return fRtdb; }
    /**
     * Set the sink
     */
    void SetSink(std::unique_ptr<FairSink> newsink);
    void SetSink(FairSink* tempSink);
    /**
     * return a non-owning pointer to the sink
     */
    FairSink* GetSink() { return fSink.get(); }
    /**
     * return the run ID for the actul run
     */
    Int_t GetRunId() { return (static_cast<Int_t>(fRunId)); }

    /**
     * Set the Run ID
     */
    void SetRunId(UInt_t runId) { fRunId = runId; }

    /**Get the detector specific run header*/
    FairEventHeader* GetEventHeader();
    /**
     * return true for Anaylsis session
     */
    Bool_t IsAna() { return fAna; }
    /**
     *Get task by name
     */

    FairTask* GetTask(const char* taskName);
    /**
     *Get Main Task
     */
    FairTask* GetMainTask() { return fTask; }
    /**
     * Return the number of Tasks added to this Run
     */
    Int_t GetNTasks() { return fNTasks; }

    /**Create a new file and save the TGeoManager to it*/
    void CreateGeometryFile(const char* geofile);

    /**
     * Set if RunInfo file should be written
     * \deprecated Use SetGenerateRunInfo() instead.
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] void SetWriteRunInfoFile(Bool_t write);

    //** Set if RunInfo should be generated */
    void SetGenerateRunInfo(Bool_t write) { fGenerateRunInfo = write; }

    /**
     * Get info if RunInfo file is written
     * \deprecated Use \ref IsRunInfoGenerated() instead.
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] Bool_t GetWriteRunInfoFile();

    //** Get info if RunInfo file is written */
    Bool_t IsRunInfoGenerated() { return fGenerateRunInfo; }

    //** Switches the use of FairLinks */
    void SetUseFairLinks(Bool_t val);

    //** Get info if run on master */
    Bool_t GetIsMaster() const { return fIsMaster; }

    //** Mark/Unmark event to be filled into output. Default is TRUE. */
    void MarkFill(Bool_t flag) { fMarkFill = flag; }

    //** Get option string */
    TString GetOptions() { return fOptions; };

    //** Set option string */
    void SetOptions(const TString& s) { fOptions = s; };

    /**
     * Set the output file name for analysis or simulation
     * \deprecated Use \ref FairSink and \ref SetSink().
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] virtual void SetOutputFile(const char* fname);
    /**
     * Set the output file for analysis or simulation
     * \deprecated Use \ref FairSink and \ref SetSink().
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] virtual void SetOutputFile(TFile* f);
    /**
     * Set the  output file name without creating the file
     * \deprecated Use \ref FairSink and \ref SetSink().
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] void SetOutputFileName(const TString& name);
    /**
     * \deprecated Use \ref FairSink and \ref SetSink().
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] TFile* GetOutputFile();

    /**
     * New functions which allow to postpone creating a new Sink in MT
     * to be kept after clean-up of deprecated functions above
     */
    void SetUserOutputFileName(const TString& name);
    TString GetUserOutputFileName() const;

    void AddAlignmentMatrices(const std::map<std::string, TGeoHMatrix>& alignmentMatrices, bool invertMatrices = false);

    /**
     * \brief Set the input signal file
     *
     * Takes an owning pointer!
     */
    virtual void SetSource(FairSource* tempSource);
    /** Return non-owning pointer to source **/
    FairSource* GetSource() { return fSource.get(); }
    FairRootManager& GetRootManager() { return *fRootManager; }
    FairRootManager const& GetRootManager() const { return *fRootManager; }

  private:
    FairRun(const FairRun& M);
    FairRun& operator=(const FairRun&) { return *this; }
    /** Number of Tasks added*/
    Int_t fNTasks;

  protected:
    /** static pointer to this run*/
    static TMCThreadLocal FairRun* fRunInstance;
    /** RuntimeDb*/
    FairRuntimeDb* fRtdb;
    /** Tasks used*/
    FairTask* fTask;
    /**IO manager */
    FairRootManager* fRootManager;
    /**Output sink*/
    std::unique_ptr<FairSink> fSink{};   //!
    /**Output file name set by user*/
    TString fUserOutputFileName;
    /**Options for derived classes, to be set & parsed by user*/
    TString fOptions;
    /**Run Id*/
    UInt_t fRunId;   //!
    /** true for Anaylsis session*/
    Bool_t fAna;   //!
    /** MC Event Header */
    FairEventHeader* fEvtHeader;   //!
    /** File  Header */
    FairFileHeader* fFileHeader;
    /** true if RunInfo file should be written*/
    Bool_t fGenerateRunInfo;   //!
    /** true if on master*/
    Bool_t fIsMaster;   //!

    Bool_t fMarkFill;   //!

    FairAlignmentHandler fAlignmentHandler;

    std::unique_ptr<FairSource> fSource{};   //!

    void AlignGeometry() const;
    /**
     * Call FillEventHeader on the source
     */
    void FillEventHeader()
    {
        if (fSource)
            fSource->FillEventHeader(fEvtHeader);
    }

    /**
     * Get the RunId of the Event Header
     */
    UInt_t GetEvtHeaderRunId() const { return fEvtHeader->GetRunId(); }

    ClassDefOverride(FairRun, 5);
};
#endif   // FAIRRUN_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANA_H
#define FAIRRUNANA_H

/**
 * Configure and manage the  Analysis
 * @author M. Al-Turany D. Bertini
 * @version 0.1
 * @since 28.02.05
 */

#include "FairRootManager.h"   // for FairRootManager
#include "FairRun.h"           // for FairRun
#include "FairRunInfo.h"       // for FairRunInfo

#include <Rtypes.h>    // for Bool_t, Double_t, UInt_t, etc
#include <TString.h>   // for TString

class FairField;
class TF1;
class TFile;

class FairSource;
class FairFileSource;
class FairMixedSource;

class FairRunAna : public FairRun
{

  public:
    static FairRunAna* Instance();
    virtual ~FairRunAna();
    FairRunAna();
    /**initialize the run manager*/
    void Init() override;
    /**Run from event number NStart to event number NStop */
    void Run(Int_t NStart = 0, Int_t NStop = 0) override;
    /**Run over the whole input file with timpe window delta_t as unit (entry)*/
    void Run(Double_t delta_t);
    /**Run for the given single entry*/
    void Run(Long64_t entry);
    /**Run event reconstruction from event number NStart to event number NStop */
    void RunEventReco(Int_t NStart, Int_t NStop);
    /**Run over all TSBuffers until the data is processed*/
    void RunTSBuffers();
    /** the dummy run does not check the evt header or the parameters!! */
    void DummyRun(Int_t NStart, Int_t NStop);
    /** This methode is only needed and used with ZeroMQ
     * it read a certain event and call the task exec, but no output is written
     * @param entry : entry number in the tree
     */
    void RunMQ(Long64_t entry);
    /** Run on a list of lmd files*/
    void RunOnLmdFiles(UInt_t NStart = 0, UInt_t NStop = 0);

    void RunOnTBData();
    /** finish tasks, write output*/
    void TerminateRun();

    /** Switch On/Off the storing of FairEventHeader in output file*/
    void SetEventHeaderPersistence(Bool_t flag) { fStoreEventHeader = flag; }

    void Reinit(UInt_t runId);
    UInt_t getRunId() { return fRunId; }
    /** Get the magnetic field **/
    FairField* GetField() override { return fField; }
    /** Set the magnetic Field */
    void SetField(FairField* ffield) { fField = ffield; }
    /** Set external geometry file */
    void SetGeomFile(const char* GeoFileName);
    /** Return a pointer to the geometry file */
    TFile* GetGeoFile() { return fInputGeoFile; }
    /** Initialization of parameter container is set to static, i.e: the run id is
     *  is not checked anymore after initialization
     */

    void SetContainerStatic(Bool_t tempBool = kTRUE);
    Bool_t GetContainerStatic() { return fStatic; };
    void RunWithTimeStamps();
    Bool_t IsTimeStamp() { return fTimeStamps; }

    /** Set the flag for proccessing lmd files */
    void StopProcessingLMD(void) { fFinishProcessingLMDFile = kTRUE; }
    /** Get the status of lmd file proccessing */
    Bool_t GetLMDProcessingStatus(void) { return fFinishProcessingLMDFile; }

  protected:
    /**
     * Virtual function which calls the Fill function of the IOManager.
     * Allows to override the function with an experiment specific version.
     **/
    virtual void Fill();

  private:
    FairRunAna(const FairRunAna& M);
    FairRunAna& operator=(const FairRunAna&) { return *this; }

    FairRunInfo fRunInfo;   //!

  protected:
    /** This variable became true after Init is called*/
    Bool_t fIsInitialized;
    TFile* fInputGeoFile;
    static FairRunAna* fgRinstance;
    Bool_t fLoadGeo;
    /** true for static initialisation of parameters */
    Bool_t fStatic;   //!
    FairField* fField;
    Bool_t fTimeStamps;
    Bool_t fInFileIsOpen;   //!
    /** min time for one event (ns) */
    Double_t fEventTimeMin;   //!
    /** max time for one Event (ns) */
    Double_t fEventTimeMax;   //!
    /** Time of event since th start (ns) */
    Double_t fEventTime;   //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t fEventMeanTime;   //!
    /** used to generate random numbers for event time; */
    TF1* fTimeProb;   //!
    /** Flag for proccessing lmd-files*/
    Bool_t fFinishProcessingLMDFile;   //!

    /** Temporary member to preserve old functionality without setting source in macro */
    FairFileSource* fFileSource;   //!
    /** Temporary member to preserve old functionality without setting source in macro */
    FairMixedSource* fMixedSource;   //!
    /** Flag for Event Header Persistency */
    Bool_t fStoreEventHeader;   //!

    ClassDefOverride(FairRunAna, 6);
};

#endif   // FAIRRUNANA_H
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNSIM_H
#define FAIRRUNSIM_H

#include "FairGenericVMCConfig.h"
#include "FairIon.h"             // for FairIon
#include "FairMCApplication.h"   // for FairMCApplication
#include "FairParticle.h"        // for FairParticle
#include "FairRun.h"             // for FairRun

#include <Rtypes.h>      // for Bool_t, Double_t, Int_t, etc
#include <TMCtls.h>      // for multi-threading
#include <TObjArray.h>   // for TObjArray
#include <TString.h>     // for TString
#include <functional>
#include <memory>
#include <utility>

class FairField;
class FairMCEventHeader;
class FairMesh;
class FairModule;
class FairPrimaryGenerator;

/**
 * \brief Configure the Simulation session
 * \ingroup base_steer
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairRunSim : public FairRun
{
  public:
    /** default ctor*/
    FairRunSim(Bool_t isMaster = kTRUE);
    /** default dtor*/
    ~FairRunSim() override;
    /** Singelton instance*/
    static FairRunSim* Instance();
    /**
     *       Add a module to the simulation (e.g. PIPE, Magnet, ..etc)
     */
    void AddModule(FairModule* Mod);
    /**
     *       Add a user defined ion to the simulation
     */
    void AddNewIon(FairIon* ion) { fIons->Add(ion); }
    /**
     *       Add a user defined ion to the simulation
     */
    void AddNewParticle(FairParticle* Particle) { fParticles->Add(Particle); }
    /**
     *       this method is used by the FAIRMCApplication
     */
    TObjArray* GetUserDefIons();
    /**
     *       this method is used by the FAIRMCApplication
     */
    TObjArray* GetUserDefParticles();

    /**
     *       Initialize the Simulation
     */
    void Init() override;
    /**
     *       run the  simulation
     */
    void Run(Int_t NEvents = 0, Int_t NotUsed = 0) override;
    /**
     *       Set the magnetic that has to be used for simulation field
     */
    void SetField(FairField* field);
    /**
     *       Set the event generator that has to be used for simulation field
     */
    void SetGenerator(FairPrimaryGenerator* Gen);

    /**
     *       Set the experiment dependent event header
     *       for each Monte Carlo Event
     */
    void SetMCEventHeader(FairMCEventHeader* McHeader) { fMCEvHead = McHeader; }

    /** Set the material file name to be used */
    void SetMaterials(const char* MatFileName);

    /**switch On/Off the track visualisation */
    void SetStoreTraj(Bool_t storeTraj = kTRUE) { fStoreTraj = storeTraj; }

    /**Return the switch for the track visualisation */
    Bool_t GetStoreTraj() const { return fStoreTraj; }

    /**switch On/Off the debug mode */
    void SetTrackingDebugMode(Bool_t set)
    {
        if (fApp) {
            fApp->SetTrackingDebugMode(set);
        }
    }

    /**Set geometry builder*/
    void SetGeoModel(const char* name);

    /**return the geometry loader used in this session*/
    TString* GetGeoModel() { return &fLoaderName; }

    /**Get the field used in simulation*/
    FairField* GetField() override { return fField; }

    /**Get the detector specific event header*/
    FairMCEventHeader* GetMCEventHeader();

    /**return the full list of modules used in simulation*/
    TObjArray* GetListOfModules() { return ListOfModules; }

    /**Get the used primary generator*/
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    FairPrimaryGenerator* GetPrimaryGenerator() { return fGen; }
#pragma GCC diagnostic pop

    /**switch On/Off external decayer (Pythia) */
    void SetPythiaDecayer(Bool_t decayer) { fPythiaDecayer = decayer; }

    /**switch On external decayer (Pythia). Config macro will be used */
    void SetPythiaDecayer(const TString& Config);

    /**switch On user defined decay, Config  macro will be called  */
    void SetUserDecay(const TString& Config);

    /**switch On/Off user defined decay if true gconfig/UserDecay.C macro will be called  */
    void SetUserDecay(Bool_t decay) { fUserDecay = decay; }

    /**Flag for external decayer*/
    Bool_t IsExtDecayer() { return fPythiaDecayer; }

    /**Flag for User decay*/
    Bool_t IsUserDecay() { return fUserDecay; }

    /**Switch on/off Radiation length register */
    void SetRadLenRegister(Bool_t value) { fRadLength = value; }

    void SetRadMapRegister(Bool_t value) { fRadMap = value; }

    void SetRadGridRegister(Bool_t value) { fRadGrid = value; }

    void AddMesh(FairMesh* Mesh);

    void SetUserConfig(const TString& Config) { fUserConfig = Config; }
    TString GetUserConfig() { return fUserConfig; }

    void SetUserCuts(const TString& Cuts) { fUserCuts = Cuts; }
    TString GetUserCuts() { return fUserCuts; }

    /** Set Beam energy in GeV/c */
    void SetBeamMom(Double_t BeamMom)
    {
        fBeamMom = BeamMom;
        fUseBeamMom = kTRUE;
    }

    /** Get the Beam energy */
    Double_t GetBeamMom() { return fBeamMom; }

    /**Get beam energy flag */
    Bool_t UseBeamMom() { return fUseBeamMom; }
    void SetFieldContainer();

    void SetSimSetup(std::function<void()> f)
    {
        fSimSetup = f;
        fUseSimSetupFunction = true;
    }
    void SetSimSetupPostInit(std::function<void()> f)
    {
        fSimSetupPostInit = f;
        fUseSimSetupPostInitFunction = true;
    }

    void SetSimulationConfig(std::unique_ptr<FairGenericVMCConfig> tconf) { fSimulationConfig = std::move(tconf); }
    /**
     * Get non-owning pointer
     */
    FairGenericVMCConfig* GetSimulationConfig() { return fSimulationConfig.get(); }

    void SetIsMT(Bool_t isMT) { fIsMT = isMT; }
    Bool_t IsMT() const { return fIsMT; }

    void SetImportTGeoToVMC(Bool_t v) { fImportTGeoToVMC = v; }
    Bool_t IsImportTGeoToVMC() const { return fImportTGeoToVMC; }

    void StopMCRun() { fApp->StopMCRun(); }

    /**
     * Get non-owning pointer to FairMCApplication
     */
    auto GetMCApplication() { return fApp; }

  private:
    FairRunSim(const FairRunSim& M);
    FairRunSim& operator=(const FairRunSim&) { return *this; }
    void SetMCConfig();
    void CheckFlukaExec();

  protected:
    Int_t count{0};                     //!< Internal counter
    FairMCApplication* fApp{nullptr};   //!< Main VMC application
    Double_t fBeamMom{0};               //!< Beam Energy in GeV/c
    Bool_t fUseBeamMom{kFALSE};         //!< flag for use Beam Energy
    /**
     * Primary Event Generator
     *
     * \deprecated Use \ref GetPrimaryGenerator() / \ref SetGenerator()
     * \deprecated Deprecated in v18.8, will be removed in v19.2.
     */
    [[deprecated("Use Setter/Getter")]] FairPrimaryGenerator* fGen{nullptr};   //!

    FairMCEventHeader* fMCEvHead;                   //!                          /** MC Event Header */
    static TMCThreadLocal FairRunSim* fginstance;   //!              /** Singleton Instance */
    FairField* fField;                              /** Magnetic Field */
    TObjArray* fIons;                               //!                              /** Array of user defined ions */
    TObjArray* fParticles;                          //!                         /** Array of user defined particles*/
    TObjArray* ListOfModules;                       //!                       /** Array of used modules */
    TString MatFname;                               //!                           /** Material file name */
    Bool_t fStoreTraj;                              //!                       /** Trajectory store flags */
    TString fLoaderName{"TGeo"};                    //!< Geometry Model (TGeo or G3)
    Bool_t fPythiaDecayer;                          //!                    /** flag for using Pythia decayer*/
    TString fPythiaDecayerConfig;                   //!               /** Macro for Pythia decay configuration*/
    Bool_t fUserDecay;                              /** flag for setting user decay */
    TString fUserDecayConfig;                       //!                   /** Macro for decay configuration*/
    Bool_t fRadLength;                              //!                       /** flag for registring radiation length*/
    Bool_t fRadMap;                                 //!                            /** flag for RadiationMapManager
    Bool_t fRadGrid;                                //!
    TObjArray* fMeshList;                           //!                          /** radiation grid scoring
    TString fUserConfig;                            //!                        /** Macro for geant configuration*/
    TString fUserCuts;                              //!                          /** Macro for geant cuts*/
    Bool_t fIsMT;                                   //!                              /** MT mode option (Geant4 only)*/
    Bool_t fImportTGeoToVMC;                        //!                   /** Allow importing TGeometry to VMC */
    std::function<void()> fSimSetup;   //!                          /** A user provided function to do sim setup /
                                       //!                          instead of using macros **/
    bool fUseSimSetupFunction = false;
    std::function<void()> fSimSetupPostInit;   //!                          /** A user provided function to do sim setup
                                               //!                          / instead of using macros **/
    bool fUseSimSetupPostInitFunction = false;
    std::unique_ptr<FairGenericVMCConfig> fSimulationConfig{};   //!                 /** Simulation configuration */

    ClassDefOverride(FairRunSim, 2);
};

#endif   // FAIRRUNSIM_H
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairTask header file                      -----
// -----          Created 12/01/04  by M. Al-Turany / D. Bertini       -----
// -------------------------------------------------------------------------

/** FairTask
 * @author M. Al-Turany, Denis Bertini
 * @since 12.01.04
 **
 ** Base class for tasks in the cbmroot framework.
 ** Derived classes should implement the Exec method.
 **/

#ifndef FAIRTASK_H
#define FAIRTASK_H

#include <Rtypes.h>    // for Int_t, FairTask::Class, etc
#include <TString.h>   // for TString
#include <TTask.h>     // for TTask
#include <map>

class FairLogger;

enum InitStatus
{
    kSUCCESS,
    kERROR,
    kFATAL
};

/**
 * \ingroup base_steer
 */
class FairTask : public TTask
{
  public:
    /** Default constructor **/
    FairTask();

    /** Standard constructor
     *@param name        Name of task
     *@param iVerbose    Verbosity level
     **/
    FairTask(const char* name, Int_t iVerbose = 1);

    FairTask(const FairTask&) = delete;
    FairTask& operator=(const FairTask&) = delete;
    FairTask(FairTask&&) = delete;
    FairTask& operator=(FairTask&&) = delete;

    /** Destructor **/
    ~FairTask() override;

    /** Initialisation at begin of run. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void InitTask();

    /** Reinitialisation. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void ReInitTask();

    /** Set parameters. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void SetParTask();

    /** Action at end of run. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    virtual void FinishTask();

    /** Action at end of event. For this task and all of the subtasks. **/
    virtual void FinishEvent();

    /** Set verbosity level. For this task and all of the subtasks. **/
    void SetVerbose(Int_t iVerbose);

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] void SetInputPersistance(Bool_t val) { fInputPersistance = val; }
#pragma GCC diagnostic pop

    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] void CheckInputPersistance(TString branchName);

    void ExecuteTask(Option_t* option = "0") override;   // *MENU*

    /** Set persistency of branch with given name true or false
     *  In case is is set to false the branch will not be written to the output.
     **/
    void SetOutputBranchPersistent(TString, Bool_t);

    /** Check if the branch with the given name is persistent.
     *  If the branch is not in the map, the default return value is true.
     **/
    Bool_t IsOutputBranchPersistent(TString);

    void SetStreamProcessing(Bool_t val = kTRUE) { fStreamProcessing = val; }

  protected:
    Int_t fVerbose;                           //  Verbosity level
    [[deprecated]] Int_t fInputPersistance;   ///< \deprecated Deprecated in v18.8, will be removed in v20.
    FairLogger* fLogger;                      //!
    Bool_t fStreamProcessing;

    /** Intialisation at begin of run. To be implemented in the derived class.
     * \retval  kSUCCESS   If not kSUCCESS, task will be set inactive.
     **/
    virtual InitStatus Init() { return kSUCCESS; };

    /** Reinitialisation. To be implemented in the derived class.
     * \retval  kSUCCESS   If not kSUCCESS, task will be set inactive.
     **/
    virtual InitStatus ReInit() { return kSUCCESS; };

    /** Intialise parameter containers.
        To be implemented in the derived class.
    **/
    virtual void SetParContainers(){};

    /** Action at end of run. For this task and all of the subtasks.
        To be implemented in the derived class.
    **/
    virtual void Finish(){};

    /** Recursive intialisation of subtasks at begin of run **/
    void InitTasks();

    /** Recursive reinitialisation of subtasks **/
    void ReInitTasks();

    void ExecuteTasks(Option_t* option) override;

    /** Recursive parameter initialisation for subtasks **/
    void SetParTasks();

    /** Recursive finish of subtasks **/
    void FinishTasks();

    /** Recursive FinishEvent of subtasks **/
    void FinishEvents();

  private:
    std::map<TString, Bool_t> fOutputPersistance;

    ClassDefOverride(FairTask, 4);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// ********************************************* //
// ***        D. Kresan   2004-Sep-14        *** //
// ***        D.Kresan@gsi.de                *** //
// ********************************************* //

#ifndef FAIR_TRAJ_FILTER_H
#define FAIR_TRAJ_FILTER_H 1

#include <Rtypes.h>      // for Double_t, Bool_t, Int_t, etc
#include <TGeoTrack.h>   // IWYU pragma: keep needed by cint // TODO: is this still relevant for CINT?
#include <TMCtls.h>      // for multi-threading
#include <TMath.h>       // for Pi, TwoPi
#include <TString.h>     // for TString

class TClonesArray;
class TParticle;

/**
 * @class FairTrajFilter
 * The filter for storing of the trajectories.
 * This singleton class controls storing of trajectories
 * in the gGeoManager list during the simulation.
 * It is created, if FairRun::SetStoreTraj(kTRUE) was called
 * in the run macro
 * before the initialisation. The cuts should be applied
 * after initialisation and before run via
 * FairTrajFilter::Instance()->Set...Cut(...) methods.
 * Three modes of momentum cut (phase space, polar and decart reference systems),
 * are self-excluded. The last that was set, is applied in the simulation.
 * All other cuts are combined together.
 * @author D. Kresan
 * @version 0.1
 * @since 2004-Sep-15
 */

class FairTrajFilter
{
  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairTrajFilter class.
     * The pointer to this object can be reached via FairTrajFilter::Instance().
     */
    FairTrajFilter();

    /**
     * Destructor.
     */
    virtual ~FairTrajFilter();

    /**
     * Class definition.
     */
    ClassDef(FairTrajFilter, 1);

  private:
    FairTrajFilter(const FairTrajFilter&);
    FairTrajFilter& operator=(const FairTrajFilter&);

    static TMCThreadLocal FairTrajFilter* fgInstance;

    Double_t fVxMin;
    Double_t fVxMax;
    Double_t fVyMin;
    Double_t fVyMax;
    Double_t fVzMin;
    Double_t fVzMax;

    Double_t fPMin;
    Double_t fPMax;
    Double_t fThetaMin;
    Double_t fThetaMax;
    Double_t fPhiMin;
    Double_t fPhiMax;

    Double_t fPxMin;
    Double_t fPxMax;
    Double_t fPyMin;
    Double_t fPyMax;
    Double_t fPzMin;
    Double_t fPzMax;

    Double_t fPtMin;
    Double_t fPtMax;
    Double_t fRapidityMin;
    Double_t fRapidityMax;

    Int_t fKinCutType;

    Double_t fEtotMin;
    Double_t fEtotMax;

    Bool_t fStorePrim;
    Bool_t fStoreSec;

    Double_t fStepSizeMin;

    /**
     * collection of tracks
     */
    TClonesArray* fTrackCollection;

    TGeoTrack* fCurrentTrk;

  public:
    TGeoTrack* AddTrack(Int_t trackId, Int_t pdgCode);
    TGeoTrack* AddTrack(TParticle* p);
    TGeoTrack* CheckAddTrack(Int_t trackId, TParticle* p);
    TGeoTrack* GetCurrentTrk() { return fCurrentTrk; }

    void Init(TString brName = "GeoTracks", TString folderName = "MCGeoTrack");
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairTrajFilter object, created
     * with FairTrajFilter::FairTrajFilter().
     */
    static FairTrajFilter* Instance();

    /**
     * This function applies all availible cuts on different variables.
     * @param p - pointer to the TParticle object.
     * @return kTRUE - if particle survives the cuts. Otherwise - kFALSE.
     */
    Bool_t IsAccepted(const TParticle* p) const;

    /**
     * This function enables the vertex cut.
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param Box in coordinate space. Only trajectories, created inside this box
     * will be stored. Default values - the cave dimensions.
     */
    void SetVertexCut(Double_t vxMin = -2000.,
                      Double_t vyMin = -2000.,
                      Double_t vzMin = -2000.,
                      Double_t vxMax = 2000.,
                      Double_t vyMax = 2000.,
                      Double_t vzMax = 2000.);

    /**
     * This function enables the momentum cut (polar reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (polar reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutP(Double_t pMin = 0.,
                         Double_t thetaMin = 0.,
                         Double_t phiMin = 0.,
                         Double_t pMax = 1e10,
                         Double_t thetaMax = TMath::Pi(),
                         Double_t phiMax = TMath::TwoPi());

    /**
     * This function enables the momentum cut (decart reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (decart reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutD(Double_t pxMin = -1e10,
                         Double_t pyMin = -1e10,
                         Double_t pzMin = -1e10,
                         Double_t pxMax = 1e10,
                         Double_t pyMax = 1e10,
                         Double_t pzMax = 1e10);

    /**
     * This function enables the cut in phase space (pt-rapidity).
     * @param The region in phase space (pt-rapidity). Only particles
     * inside this region will be stored.
     * Default values - whole pt-rapidity range.
     */
    void SetPtRapidityCut(Double_t ptMin = 0.,
                          Double_t ptMax = 1e10,
                          Double_t rapidityMin = -1e10,
                          Double_t rapidityMax = 1e10);

    /**
     * This function enables the cut on total energy.
     * @param Total energy range. Only particles with total energy value
     * inside this range will be stored. Deafult values - whole energy range.
     */
    void SetEnergyCut(Double_t etotMin = 0., Double_t etotMax = 1e10);

    /**
     * This function controls the storing of primaries.
     * @param storePrim - boolean flag to control the storing of primaries.
     */
    inline void SetStorePrimaries(Bool_t storePrim = kTRUE) { fStorePrim = storePrim; };

    /**
     * This function controls the storing of secondaries.
     * @param storeSec - boolean flag to control the storing of secondaries.
     */
    inline void SetStoreSecondaries(Bool_t storeSec = kTRUE) { fStoreSec = storeSec; };

    /**
     * This function controls the process of adding the points to the trajectory.
     * @param stepSizeMin - minimum value of step size, wich will be added to
     * the trajectory.
     */
    void SetStepSizeCut(Double_t stepSizeMin = 0.);

    /**
     * This is the getter for the vertex cut.
     * @param References to the variables where return values should be stored.
     */
    void GetVertexCut(Double_t& vxMin,
                      Double_t& vyMin,
                      Double_t& vzMin,
                      Double_t& vxMax,
                      Double_t& vyMax,
                      Double_t& vzMax) const;

    /**
     * This is the getter for the momentum cut (polar reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutP(Double_t& pMin,
                         Double_t& thetaMin,
                         Double_t& phiMin,
                         Double_t& pMax,
                         Double_t& thetaMax,
                         Double_t& phiMax) const;

    /**
     * This is the getter for the momentum cut (decart reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutD(Double_t& pxMin,
                         Double_t& pyMin,
                         Double_t& pzMin,
                         Double_t& pxMax,
                         Double_t& pyMax,
                         Double_t& pzMax) const;

    /**
     * This is the getter for the space phase cut.
     * @param References to the variables where return values should be stored.
     */
    void GetPtRapidityCut(Double_t& ptMin, Double_t& ptMax, Double_t& rapidityMin, Double_t& rapidityMax) const;

    /**
     * This is the getter for the total energy cut.
     * @param References to the variables where return values should be stored.
     */
    void GetEnergyCut(Double_t& etotMin, Double_t& etotMax) const;

    /**
     * This is the getter for flag of storing of primaries.
     * @return kTRUE if primaries should be stored.
     */
    inline Bool_t IsPrimariesStored() const { return fStorePrim; };

    /**
     * This is the getter for flag of storing of secondaries.
     * @return kTRUE if secondaries should be stored.
     */
    inline Bool_t IsSecondariesStored() const { return fStoreSec; };

    /**
     * This is the getter for the step size cut.
     * @return The minimum value of the step size wich still should be
     * added to the trajectory.
     */
    inline Double_t GetStepSizeCut() const { return fStepSizeMin; };

    TGeoTrack* GetTrack(Int_t trackId);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairTSBufferFunctionalFunctional_H_
#define FairTSBufferFunctionalFunctional_H_

#include "FairTimeStamp.h"   // for FairTimeStamp

#include <Rtypes.h>     // for Int_t, Bool_t, Double_t, etc
#include <TObject.h>    // for TObject
#include <TString.h>    // for TString
#include <functional>   // for binary_function
#include <iostream>     // for operator<<, basic_ostream, etc

class TBranch;
class TClonesArray;
class TTree;

/**
 * \class BinaryFunctor
 * \brief Base class for all functors which are used in the FairTSBufferFunctional
 * \see FairTSBufferFunctional
 *
 * The class is a base class to control which data is extracted by the FairTSBufferFunctional class for processing.
 * The important method to overwrite is Call. It gets the actual data which is read in from the tree and a parameter.
 * If the actual data is not anymore part of the data you want to have Call returns true to stop the reading of data.
 * Otherwise it should return false.
 * The method TimeOut is used to break the processing if for example always the same data is requested.
 */

class BinaryFunctor
{
  public:
    using first_argument_type = FairTimeStamp*;
    using second_argument_type = double;
    using result_type = bool;

    virtual bool operator()(FairTimeStamp* a, double b) { return Call(a, b); };
    virtual bool Call(FairTimeStamp* a, double b) = 0;
    virtual bool TimeOut() { return false; }
    virtual void ResetTimeOut(){};

    virtual ~BinaryFunctor(){};
};

/**
 * \class StopTime
 * Gives you all the data which is older than the given parameter StopTime.
 * It does not return the data requested before.
 */

class StopTime : public BinaryFunctor
{
  public:
    StopTime()
        : fRequestTime(-1)
        , fOldTime(-1)
        , fSameTimeRequestCounter(0){};

    /**
     * \parameter b: StopTime: All data older than StopTime is returned
     */
    bool Call(FairTimeStamp* a, double b) override
    {
        fRequestTime = b;
        // std::cout << "StopTime: " << a->GetTimeStamp() << " > " <<  b << std::endl;
        return a->GetTimeStamp() > b;
    };

    bool TimeOut() override
    {
        if (fRequestTime != fOldTime) {
            fOldTime = fRequestTime;
            fSameTimeRequestCounter = 0;
            // std::cout << "RequestedTime: " << fRequestTime << std::endl;
            return false;
        } else if (fRequestTime == fOldTime) {
            std::cout << "-I- FairTSBufferFunctional StopTime has requested the same data as before: " << fRequestTime
                      << std::endl;
            fSameTimeRequestCounter++;
        } else {
            std::cout << "-E- FairTSBufferFunctional StopTime Functor has requested time " << fRequestTime
                      << " smaller than old time " << fOldTime << std::endl;
            return true;
        }
        return fSameTimeRequestCounter > 9;
    }

    void ResetTimeOut() override { fSameTimeRequestCounter = 0; }

  private:
    double fRequestTime;
    double fOldTime;
    int fSameTimeRequestCounter;
};

/**
 * \class TimeGap
 * Returns you all the data between two time gaps of a given length.
 */

class TimeGap : public BinaryFunctor
{
  public:
    TimeGap()
        : fOldTime(-1.){};

    /**
     * \parameter b : TimeGap: All data between two time gaps which are larger than TimeGap are returned
     */
    bool Call(FairTimeStamp* a, double b) override
    {
        double aTime = a->GetTimeStamp();

        if (fOldTime < 0) {
            fOldTime = aTime;
            return false;
        }
        if (aTime - fOldTime > b) {
            fOldTime = aTime;
            return true;
        } else {
            fOldTime = aTime;
            return false;
        }
    };

  private:
    double fOldTime;
};

/**
 * \class FairTSBufferFunctional
 * \brief A class to access time ordered data in a root branch
 *
 * In the constructor of the class one has to give the branch name of the data, the tree the data is stored in
 * and a BinaryFunctor which contains the method how the data should be extracted. Several example functors already
 * exists. To extract the data one has to call GetData with a parameter which fits to the selected functor. GetData
 * returns a TClonesArray which contains the data.
 *
 *
 * Be careful! The buffer runs through the time ordered data in one time direction only. This means that you cannot
 * request data which is older than the data you have requested before.
 *
 * Addition: This is not true anymore. GetData(Double_t, Double_t) is able to get also data which is older but this only
 * works if you request a fixed time via StopTime functor. For other functors the behavior is unpredictable.
 *
 *  Created on: Feb 18, 201
 *      Author: stockman
 */

class FairTSBufferFunctional : public TObject
{
  public:
    FairTSBufferFunctional(TString branchName,
                           TTree* sourceTree,
                           BinaryFunctor* stopFunction,
                           BinaryFunctor* startFunction = 0);

    ~FairTSBufferFunctional() override {}
    TClonesArray* GetData(Double_t stopParameter);
    TClonesArray* GetData(Double_t startParameter, Double_t stopParameter);
    Int_t GetBranchIndex() { return fBranchIndex; }

    void SetBranchIndex(const Int_t val) { fBranchIndex = val; }
    void SetStartFunction(BinaryFunctor* function) { fStartFunction = function; }
    void SetStopFunction(BinaryFunctor* function) { fStopFunction = function; }
    Bool_t AllDataProcessed();
    void Terminate() { fTerminate = kTRUE; }

    Bool_t TimeOut()
    {
        Bool_t stopTimeOut = fStopFunction->TimeOut();
        Bool_t startTimeOut = kTRUE;
        if (fStartFunction != 0) {
            startTimeOut = fStartFunction->TimeOut();
            //        if (startTimeOut == kTRUE && stopTimeOut == kFALSE){
            //          fStartFunction->ResetTimeOut();
            //        }
            //        else if (startTimeOut == kFALSE && stopTimeOut == kTRUE){
            //          fStopFunction->ResetTimeOut();
            //        }
        }
        return (stopTimeOut && startTimeOut);
    }

    Int_t FindStartIndex(Double_t startParameter);

  private:
    void ReadInNextFilledEntry();
    Int_t ReadInPreviousFilledEntry(Int_t startEntry);
    void ReadInNextEntry();   //** used only if no function is given and input data is directly passed through to the
                              // OutputArray
    void ReadInEntry(Int_t number);
    void AbsorbDataBufferArray();   //< Absorbs the complete data from fInputArray to fBufferArray

    TClonesArray* fOutputArray;
    TClonesArray* fBufferArray;
    TClonesArray* fInputArray;

    BinaryFunctor* fStartFunction;
    BinaryFunctor* fStopFunction;

    TBranch* fBranch;
    Int_t fBranchIndex;

    Bool_t fTerminate;

    Int_t fVerbose;

    FairTSBufferFunctional(const FairTSBufferFunctional&);
    FairTSBufferFunctional& operator=(const FairTSBufferFunctional&);

    ClassDefOverride(FairTSBufferFunctional, 0);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * @class FairWriteoutBuffer
 *
 * @author Tobias Stockmanns
 * @brief A container class to store digi data during events
 *
 * The FairWriteoutBuffer class provides a container which handles the storage of data between
 * events. The data has to be given with an active time, the absolute time the data is active in the
 * detector and can influence the output of the data.
 * FillNewData is used to put new data into the container.
 * WriteOutData with a given actual time stores the data which has an active time older than the given time
 * in the corresponding TClonesArray of the FairRootManager.
 * At the end of the task WriteOutAllData has to be called to store the data which is still in the buffer.
 * If one adds data via FillNewData into the buffer which is already present in the buffer, Modify is called.
 * The standard behavior of Modify is that the new data is ignored to simulate pile-up. If a different behavior
 * is wanted one has to overwrite Modify in a derived class.
 *
 * The data which should be stored in the buffer has to be derived from FairTimeStamp.
 * It needs an operator< and a method equal if the same detector element is hit.
 *
 * To use this buffer one has to derive his own buffer class from FairWriteoutBuffer and overwrite the pure virtual
 * functions.
 */

#ifndef FairWriteoutBuffer_H_
#define FairWriteoutBuffer_H_

#include "FairLogger.h"        // for FairLogger
#include "FairRootManager.h"   // for FairRootManager
#include "FairTimeStamp.h"     // for FairTimeStamp

#include <Rtypes.h>         // for Bool_t, Int_t, etc
#include <TClonesArray.h>   // for TClonesArray
#include <TObject.h>        // for TObject
#include <TString.h>        // for TString
#include <iostream>         // for cout, ostream
#include <map>              // for multimap
#include <utility>          // for pair
#include <vector>           // for vector

class FairWriteoutBuffer : public TObject
{
  public:
    FairWriteoutBuffer()
        : TObject()
        , fStartTime_map()
        , fDeadTime_map()
        , fBranchName()
        , fClassName()
        , fTreeSave(false)
        , fActivateBuffering(kFALSE)
        , fVerbose(0)
        , fLogger(FairLogger::GetLogger()){};
    FairWriteoutBuffer(TString branchName, TString className, TString folderName, Bool_t persistance);
    ~FairWriteoutBuffer() override {}

    virtual void SaveDataToTree(Bool_t val = kTRUE)
    {
        fTreeSave = val;   ///< If SaveDataToTree is set the data is stored at the end of the buffering into the given
                           ///< TClonesArray.
    }
    virtual void ActivateBuffering(Bool_t val = kTRUE)
    {
        fActivateBuffering = val;   ///< fActivateBuffering has to be set to kTRUE to use the buffering. Otherwise the
                                    ///< data is directly stored in the given TClonesArray.
    }

    Bool_t IsBufferingActivated() { return fActivateBuffering; }

    /// Fills a pointer to a data object into the buffer. StartTime gives the time when the data can influence later
    /// data, activeTime gives the time how long the data can influence later data. Both time data has to be given as an
    /// absolute time!
    virtual void FillNewData(FairTimeStamp* data, double startTime, double activeTime);

    virtual Int_t GetNData() { return fDeadTime_map.size(); }
    virtual std::vector<FairTimeStamp*> GetRemoveOldData(double time);
    virtual std::vector<FairTimeStamp*> GetAllData();

    virtual void SetVerbose(Int_t val) { fVerbose = val; }

    virtual void DeleteOldData()
    {
        if (fBranchName.Length() > 0) {
            TClonesArray* myArray = FairRootManager::Instance()->GetTClonesArray(fBranchName);
            myArray->Delete();
        }
    }

    virtual void WriteOutData(double time);
    virtual void WriteOutAllData();

  protected:
    virtual void AddNewDataToTClonesArray(
        FairTimeStamp* data) = 0;   ///< store the data from the FairTimeStamp pointer in a TClonesArray (you have to
                                    ///< cast it to your type of data)
    virtual double FindTimeForData(
        FairTimeStamp* data) = 0;   ///< if the same data object (like a pad or a pixel) is already present in the
                                    ///< buffer, the time of this object has to be returned otherwise -1
    virtual void FillDataMap(FairTimeStamp* data, double activeTime) = 0;   ///< add a new element in the search buffer
    virtual void EraseDataFromDataMap(
        FairTimeStamp* data) = 0;   ///< delete the element from the search buffer (see PndSdsDigiPixelWriteoutBuffer)

    /// Modify defines the behavior of the buffer if data should be stored which is already in the buffer. Parameters
    /// are the old data with the active time, the new data with an active time. Modify returns than a vector with the
    /// new data which should be stored.
    virtual std::vector<std::pair<double, FairTimeStamp*>> Modify(std::pair<double, FairTimeStamp*> oldData,
                                                                  std::pair<double, FairTimeStamp*>)
    {
        std::vector<std::pair<double, FairTimeStamp*>> result;
        result.push_back(oldData);
        return result;
    }

    virtual void WriteOutDataDeadTimeMap(double time);
    virtual void MoveDataFromStartTimeMapToDeadTimeMap(double time);
    virtual void FillDataToDeadTimeMap(FairTimeStamp* data, double activeTime, double startTime);

    virtual void PrintData(FairTimeStamp* data)
    {
        std::cout << data->GetTimeStamp();
    };   ///< Method should be overwritten in derived classes to print the data of an object stored in the buffer
    virtual void PrintDeadTimeMap();
    virtual void PrintStartTimeMap();

    std::multimap<double, std::pair<double, FairTimeStamp*>> fStartTime_map;
    std::multimap<double, FairTimeStamp*> fDeadTime_map;

    TString fBranchName;
    TString fClassName;
    Bool_t fTreeSave;
    Bool_t fActivateBuffering;
    Int_t fVerbose;
    FairLogger* fLogger;   //! /// FairLogger

  private:
    FairWriteoutBuffer(const FairWriteoutBuffer&);
    FairWriteoutBuffer& operator=(const FairWriteoutBuffer&);

    ClassDefOverride(FairWriteoutBuffer, 1);
};

#endif /* FairWriteoutBuffer_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----            FairAnaSelector header file                        -----
// -----            Created 14/10/11  by R. Karabowicz                 -----
// -----            Updated 01/02/12  by R. Karabowicz                 -----
// -------------------------------------------------------------------------

#ifndef FAIRANASELECTOR_H
#define FAIRANASELECTOR_H

#include "FairLogger.h"   // for FairLogger, MESSAGE_ORIGIN

#include <Rtypes.h>          // for Int_t, Bool_t, etc
#include <TSelector.h>       // for TSelector
#include <TSelectorList.h>   // for TSelectorList
#include <TString.h>         // for TString
#include <TTree.h>           // for TTree

class FairFileSource;
class FairRunAnaProof;

class TFile;
class TList;
class TObject;
class TProofOutputFile;

class FairAnaSelector : public TSelector
{
  public:
    TProofOutputFile* fProofFile;
    TFile* fFile;
    TTree* fChain;   //! pointer to the analyzed TTree or TChain
    FairRunAnaProof* fRunAna;

    FairAnaSelector(TTree* /*tree*/ = 0)
        : fProofFile(0)
        , fFile(0)
        , fChain(0)
        , fRunAna(nullptr)
        , fProofSource(0)
        , fCurrentDirectory("")
    {}

    ~FairAnaSelector() override {}
    Int_t Version() const override { return 1; }
    void Begin(TTree* tree) override;
    void SlaveBegin(TTree* tree) override;
    void Init(TTree* tree) override;
    Bool_t Notify() override;
    Bool_t Process(Long64_t entry) override;
    Int_t GetEntry(Long64_t entry, Int_t getall = 0) override
    {
        return fChain ? fChain->GetTree()->GetEntry(entry, getall) : 0;
    }
    void SetOption(const char* option) override { fOption = option; }
    void SetObject(TObject* obj) override { fObject = obj; }
    void SetInputList(TList* input) override { fInput = input; }
    TList* GetOutputList() const override { return fOutput; }
    void SlaveTerminate() override;
    void Terminate() override;

    void SetFairRunAnaProof(FairRunAnaProof* runAna) { fRunAna = runAna; }

  private:
    FairAnaSelector(const FairAnaSelector&);
    FairAnaSelector operator=(const FairAnaSelector&);

    FairFileSource* fProofSource;

    TString fCurrentDirectory;

    ClassDefOverride(FairAnaSelector, 0);
};

#endif   // FAIRANASELECTOR_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANAPROOF_H
#define FAIRRUNANAPROOF_H

/**
 * Configure and manage the  Analysis on proof
 * @author R. Karabowicz
 * @version 0.1
 * @since 30.04.2013
 */

#include "FairFileSource.h"   // FairRunAnaProof can only accept FairFileSource as source
#include "FairRunAna.h"

#include <Rtypes.h>
#include <TProof.h>

class FairRunAnaProof : public FairRunAna
{
  public:
    /** \deprecated Deprecated in v18.8, will be removed in v20. */
    [[deprecated]] static FairRunAnaProof* Instance();
    virtual ~FairRunAnaProof();
    FairRunAnaProof(const char* proofName = "");

    /**initialize the run manager*/
    void Init() override;

    /** Init containers executed on PROOF, which is part of Init when running locally*/
    void InitContainers();

    /**Run from event number NStart to event number NStop */
    void Run(Int_t NStart = 0, Int_t NStop = 0) override;
    /**Run for one event, used on PROOF nodes*/
    void RunOneEvent(Long64_t entry);
    /**Run on proof from event NStart to event NStop*/
    void RunOnProof(Int_t NStart, Int_t NStop);

    /** set the input tree of fRootManager when running on PROOF worker*/
    /* void        SetInTree (TTree* tempTree)   { */
    /*   fRootManager->SetInTree (tempTree); */
    /* } */

    /** GetProof */
    TProof* GetProof() { return fProof; }

    /** To be set to kTRUE only when running on PROOF worker, only by TSelector */
    void SetRunOnProofWorker(Bool_t tb = kTRUE) { fRunOnProofWorker = tb; }
    /** Set PROOF ARchive (PAR) file name*/
    void SetProofParName(TString parName) { fProofParName = parName; }
    /** Set directory for storing output files*/
    void SetOutputDirectory(TString dirName) { fOutputDirectory = dirName; }
    /** Set PROOF output status, possibilities: "copy","merge"*/
    void SetProofOutputStatus(TString outStat) { fProofOutputStatus = outStat; }

    void SetSource(FairSource* tempSource) override;

  protected:
    static FairRunAnaProof* fRAPInstance;

    /** PROOF **/
    TProof* fProof;
    /** executing on PROOF worker*/
    Bool_t fRunOnProofWorker;   //!
    /** PROOF server name*/
    TString fProofServerName;   //!
    /** PROOF ARchive (PAR) file name*/
    TString fProofParName;   //!
    /** Output directory*/
    TString fOutputDirectory;   //!
    /** Output status indicator: "copy","merge","dataset"*/
    TString fProofOutputStatus;

  private:
    FairRunAnaProof(const FairRunAnaProof&);
    FairRunAnaProof operator=(const FairRunAnaProof&);

    FairFileSource* fProofFileSource;

    ClassDefOverride(FairRunAnaProof, 1);
};

#endif   // FAIRRUNANAPROOF_H

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from G__Base dictionary payload:42:
In file included from /home/physics/fair_install/FairRootInstall/include/FairWriteoutBuffer.h:37:
In file included from /home/physics/fair_install/FairRootInstall/include/FairTimeStamp.h:11:
In file included from /home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData_Interface.h:11:
/home/physics/fair_install/FairRootInstall/include/FairLink.h:104:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<<(std::ostream& out, const FairLink& link)
                         ^
/home/physics/fair_install/FairRootInstall/include/FairLink.h:104:26: note: previous definition is here
    friend std::ostream& operator<<(std::ostream& out, const FairLink& link)
                         ^
In file included from G__Base dictionary payload:42:
In file included from /home/physics/fair_install/FairRootInstall/include/FairWriteoutBuffer.h:37:
In file included from /home/physics/fair_install/FairRootInstall/include/FairTimeStamp.h:11:
In file included from /home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData_Interface.h:12:
/home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData.h:128:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData& data)
                         ^
/home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData.h:128:26: note: previous definition is here
    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData& data)
                         ^
In file included from G__Base dictionary payload:42:
In file included from /home/physics/fair_install/FairRootInstall/include/FairWriteoutBuffer.h:37:
In file included from /home/physics/fair_install/FairRootInstall/include/FairTimeStamp.h:11:
/home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData_Interface.h:79:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData_Interface& data)
                         ^
/home/physics/fair_install/FairRootInstall/include/FairMultiLinkedData_Interface.h:79:26: note: previous definition is here
    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData_Interface& data)
                         ^
In file included from G__Base dictionary payload:42:
In file included from /home/physics/fair_install/FairRootInstall/include/FairWriteoutBuffer.h:37:
/home/physics/fair_install/FairRootInstall/include/FairTimeStamp.h:69:26: error: redefinition of 'operator<<'
    friend std::ostream& operator<<(std::ostream& out, const FairTimeStamp& link)
                         ^
/home/physics/fair_install/FairRootInstall/include/FairTimeStamp.h:69:26: note: previous definition is here
    friend std::ostream& operator<<(std::ostream& out, const FairTimeStamp& link)
                         ^
G__Base dictionary payload:2694:18: error: no viable overloaded '='
    fFSTrackIter = fFSTrackMap.find(iTrack);   // check if point created by FastSimulation
    ~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~
G__Base dictionary payload:2696:30: error: member reference type 'std::map<Int_t, Int_t>::iterator' (aka '_Rb_tree_iterator<std::pair<const int, int> >') is not a pointer; did you mean to use '.'?
        iTrack = fFSTrackIter->second;
                 ~~~~~~~~~~~~^~
                             .
G__Base dictionary payload:2696:32: error: no member named 'second' in 'std::_Rb_tree_iterator<std::pair<const int, int> >'
        iTrack = fFSTrackIter->second;
                 ~~~~~~~~~~~~  ^
G__Base dictionary payload:6517:19: error: no viable overloaded '='
        fSimSetup = f;
        ~~~~~~~~~ ^ ~
/usr/include/c++/11/bits/std_function.h:487:7: note: candidate function not viable: no known conversion from 'std::function<void ()>' to 'std::function<void ()> &&' for 1st argument
      operator=(function&& __x) noexcept
      ^
/usr/include/c++/11/bits/std_function.h:501:7: note: candidate function not viable: no known conversion from 'std::function<void ()>' to 'std::nullptr_t' (aka 'nullptr_t') for 1st argument
      operator=(nullptr_t) noexcept
      ^
/usr/include/c++/11/type_traits:2205:46: note: candidate template ignored: disabled by 'enable_if' [with _Functor = std::function<void ()> &]
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;
                                             ^
/usr/include/c++/11/bits/std_function.h:540:2: note: candidate template ignored: could not match 'reference_wrapper' against 'function'
        operator=(reference_wrapper<_Functor> __f) noexcept
        ^
G__Base dictionary payload:6522:27: error: no viable overloaded '='
        fSimSetupPostInit = f;
        ~~~~~~~~~~~~~~~~~ ^ ~
/usr/include/c++/11/bits/std_function.h:487:7: note: candidate function not viable: no known conversion from 'std::function<void ()>' to 'std::function<void ()> &&' for 1st argument
      operator=(function&& __x) noexcept
      ^
/usr/include/c++/11/bits/std_function.h:501:7: note: candidate function not viable: no known conversion from 'std::function<void ()>' to 'std::nullptr_t' (aka 'nullptr_t') for 1st argument
      operator=(nullptr_t) noexcept
      ^
/usr/include/c++/11/type_traits:2205:46: note: candidate template ignored: disabled by 'enable_if' [with _Functor = std::function<void ()> &]
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;
                                             ^
/usr/include/c++/11/bits/std_function.h:540:2: note: candidate template ignored: could not match 'reference_wrapper' against 'function'
        operator=(reference_wrapper<_Functor> __f) noexcept
        ^
In file included from /home/physics/fair_install/FairSoft/build/Build/root/input_line_4:2:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/Rtypes.h:191:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/TGenericClassInfo.h:22:
In file included from /usr/include/c++/11/vector:67:
/usr/include/c++/11/bits/stl_vector.h:680:30: error: no member named '_M_start' in 'std::_Vector_base<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_Vector_impl'
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                      ~~~~~~~~~~~~~ ^
G__Base dictionary payload:5257:5: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::~vector' requested here
    FairRingSorter(int size = 100, double width = 10)
    ^
In file included from /home/physics/fair_install/FairSoft/build/Build/root/input_line_4:2:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/Rtypes.h:191:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/TGenericClassInfo.h:22:
In file included from /usr/include/c++/11/vector:67:
/usr/include/c++/11/bits/stl_vector.h:557:16: error: no member named '_M_finish' in 'std::_Vector_base<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_Vector_impl'
        this->_M_impl._M_finish =
        ~~~~~~~~~~~~~ ^
G__Base dictionary payload:5275:66: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::vector' requested here
    virtual std::vector<FairTimeStamp*> GetOutputData() { return fOutputData; }
                                                                 ^
In file included from /home/physics/fair_install/FairSoft/build/Build/root/input_line_4:2:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/Rtypes.h:191:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/TGenericClassInfo.h:22:
In file included from /usr/include/c++/11/vector:67:
/usr/include/c++/11/bits/stl_vector.h:919:40: error: no member named '_M_finish' in 'std::_Vector_base<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_Vector_impl'
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
                         ~~~~~~~~~~~~~ ^
/usr/include/c++/11/bits/stl_vector.h:554:19: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::size' requested here
      : _Base(__x.size(),
                  ^
G__Base dictionary payload:5275:66: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::vector' requested here
    virtual std::vector<FairTimeStamp*> GetOutputData() { return fOutputData; }
                                                                 ^
In file included from /home/physics/fair_install/FairSoft/build/Build/root/input_line_4:2:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/Rtypes.h:191:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/TGenericClassInfo.h:22:
In file included from /usr/include/c++/11/vector:67:
/usr/include/c++/11/bits/stl_vector.h:1499:39: error: no member named '_M_start' in 'std::_Vector_base<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_Vector_impl'
      { _M_erase_at_end(this->_M_impl._M_start); }
                        ~~~~~~~~~~~~~ ^
G__Base dictionary payload:5277:51: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::clear' requested here
    virtual void DeleteOutputData() { fOutputData.clear(); }
                                                  ^
In file included from /home/physics/fair_install/FairSoft/build/Build/root/input_line_4:2:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/Rtypes.h:191:
In file included from /home/physics/fair_install/FairSoft/build/Build/root/include/TGenericClassInfo.h:22:
In file included from /usr/include/c++/11/vector:67:
/usr/include/c++/11/bits/stl_vector.h:1794:36: error: no member named '_M_finish' in 'std::_Vector_base<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_Vector_impl'
        if (size_type __n = this->_M_impl._M_finish - __pos)
                            ~~~~~~~~~~~~~ ^
/usr/include/c++/11/bits/stl_vector.h:1499:9: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::_M_erase_at_end' requested here
      { _M_erase_at_end(this->_M_impl._M_start); }
        ^
G__Base dictionary payload:5277:51: note: in instantiation of member function 'std::vector<FairTimeStamp *, std::allocator<FairTimeStamp *> >::clear' requested here
    virtual void DeleteOutputData() { fOutputData.clear(); }
                                                  ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class FairRootFileSink with content:

#line 1 "G__Base dictionary payload"

#ifndef BUILD_PROOF_SUPPORT
  #define BUILD_PROOF_SUPPORT 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilder header file                -----
// -----                  Created 23/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------

/** FairEventBuilder
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 23/09/2013
 *@version 1.0
 **
 ** FairRoot base task for the event buffers.
 ** The tasks may:
 ** 1. analyze data to reconstruct event times or other characteristics
 **    in the function TClonesArray* FindEvents(), that returns
 **    TClonesArray of FairRecoEvents
 ** 2. identify the data that could belong to event in the
 **    function and insert this identified data to the output TClonesArrays
 **    in the function StoreEventData(event)
 ** The implementations may be using any or both of the above functions.
 **/

#ifndef FAIREVENTBUILDER_H
#define FAIREVENTBUILDER_H 1

#include "FairRecoEventHeader.h"
#include "FairWriteoutBuffer.h"

#include <Rtypes.h>
#include <TStopwatch.h>
#include <TString.h>
#include <utility>   // pair
#include <vector>

class TClonesArray;
// class FairRecoEventHeader;

class FairEventBuilder : public FairWriteoutBuffer
{
  public:
    /** Default constructor **/
    FairEventBuilder();

    /** Constructor with task name **/
    FairEventBuilder(TString branchName, TString className, TString folderName, Bool_t persistance);

    /** Destructor **/
    virtual ~FairEventBuilder();

    virtual void WriteOutAllDeadTimeData();

    virtual std::vector<std::pair<double, FairRecoEventHeader*>> FindEvents() = 0;
    virtual void StoreEventData(FairRecoEventHeader* /*recoEvent*/) = 0;

    void SetIdentifier(Int_t ident) { fIdentifier = ident; }
    Int_t GetIdentifier() { return fIdentifier; }

    virtual Bool_t Init() = 0;

    virtual void Print(Option_t* option = "") const = 0;

    /** Finish at the end of each event **/
    virtual void Finish();

    Double_t AllowedTime() { return fMaxAllowedEventCreationTime; };
    void SetMaxAllowedTime(Double_t td) { fMaxAllowedEventCreationTime = td; };

    void SetBuilderName(const char* name) { fBuilderName = name; }
    TString GetBuilderName() { return fBuilderName; }

  private:
    TString fBuilderName;

    TStopwatch fTimer;
    Double_t fExecTime;

    Int_t fIdentifier;
    Double_t fMaxAllowedEventCreationTime;

    ClassDef(FairEventBuilder, 1);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//* $Id: */

// -------------------------------------------------------------------------
// -----                     FairEventBuilderManager header file              -----
// -----                  Created 20/09/2013 by R. Karabowicz          -----
// -------------------------------------------------------------------------

/** FairEventBuilderManager
 *@author Radoslaw Karabowicz <r.karabowicz@gsi.de>
 *@since 20/09/2013
 *@version 1.0
 **
 ** FairRoot general task for recreating events in Time-Based reconstruction mode.
 ** Various experiments should implement their own version of Event Builder.
 ** The main member of the task is vector of reconstructed events fRecoEvents.
 ** It also contains a vector of implementations of FairEventBuilders, that are
 ** responsible for feeding fRecoEvents vector via FindEvents() function.
 **
 ** The heart of the experiment-specific implemenations is
 ** the AnalyzeAndExtractEvents() function, which should interpret
 ** the experimental data to reconstruct events.
 **/

#ifndef FAIREVENTBUILDERMANAGER_H
#define FAIREVENTBUILDERMANAGER_H 1

#include "FairEventBuilder.h"
#include "FairTask.h"

#include <Rtypes.h>   // ClassDef
#include <vector>

class TClonesArray;

class FairEventBuilderManager : public FairTask
{
  public:
    /** Default constructor **/
    FairEventBuilderManager();

    /** Constructor with task name **/
    FairEventBuilderManager(const char* name, Int_t iVerbose = 1);

    /** Destructor **/
    virtual ~FairEventBuilderManager();

    /** Execution **/
    virtual void Exec(Option_t* opt);

    /** Adding FairEventBuilder **/
    virtual void AddEventBuilder(FairEventBuilder* eventBuilder);

  protected:
    std::vector<FairEventBuilder*> fEventBuilders;
    std::vector<std::vector<std::pair<double, FairRecoEventHeader*>>> fPossibleEvents;

    /** Fill events from various builders **/
    virtual Double_t FillEventVectors();

    /** Analyze and extract events - experiment specific **/
    virtual void AnalyzeAndExtractEvents(Double_t maxEventTimeAllowed) = 0;

    /** Create output tree structure **/
    virtual void CreateAndFillEvent(FairRecoEventHeader* recoEvent);

  private:
    /** Intialisation **/
    virtual InitStatus Init();

    /** Reinitialisation **/
    virtual InitStatus ReInit();

    /** Finish at the end of each event **/
    virtual void Finish();

    ClassDef(FairEventBuilderManager, 1);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2023 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairEventHeader header file                      -----
// -----          Created 08/09/04                 D.Bertini           -----
// -------------------------------------------------------------------------

#ifndef FAIREVENTHEADER_H
#define FAIREVENTHEADER_H

#include <Rtypes.h>   // for Int_t, Double_t, UInt_t, ClassDef, etc
#include <TNamed.h>   // for TNamed

/**
 *  Event Header Class
 **@author D.Bertini <d.bertini@gsi.de>
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairEventHeader : public TNamed
{
  public:
    /** Default constructor */
    FairEventHeader() = default;

    /**
     * Destructor
     */
    ~FairEventHeader() override = default;

    /** Get the run ID for this run*/
    UInt_t GetRunId() const { return fRunId; }

    /** Get the MC time for this event*/
    Double_t GetEventTime() const { return fEventTime; }

    /** Get the MC input file Id for this event*/
    Int_t GetInputFileId() const { return fInputFileId; }

    /**The entry number in the original MC chain */
    Int_t GetMCEntryNumber() const { return fMCEntryNo; }

    /** Set the run ID for this run
     * @param runid : unique run id
     */
    void SetRunId(UInt_t runid) { fRunId = runid; }

    /** Set the MC time for this event
     * @param time : time in ns
     */
    void SetEventTime(Double_t time) { fEventTime = time; }

    /** Set the Signal file Id for this event*/
    void SetInputFileId(Int_t id) { fInputFileId = id; }

    /**The entry number in the original MC chain */
    void SetMCEntryNumber(Int_t id) { fMCEntryNo = id; }

    virtual void Register(Bool_t Persistance = kTRUE);

  protected:
    /** Run Id */
    UInt_t fRunId{0};
    /** Event Time **/
    Double_t fEventTime{-1.};
    /** Input file identifier, the file description is in the File header*/
    Int_t fInputFileId{0};
    /**MC entry number from input chain*/
    Int_t fMCEntryNo{0};

    ClassDefOverride(FairEventHeader, 3);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                         FairFileHeader source file           -----
// -----            Created 20/04/11                 M.Al-Turany        -----
// -------------------------------------------------------------------------

#ifndef FAIRFILEHEADER_H
#define FAIRFILEHEADER_H

#include <Rtypes.h>    // for UInt_t, etc
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString

class FairFileInfo;
class TFile;
class TList;

/**
 *  File Header Class
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairFileHeader : public TNamed
{
  public:
    /** Default constructor */
    FairFileHeader();

    /**Add a class name of a task*/
    void AddTaskClassName(TString taskname);

    /** Set the run ID for this run
     * @param runid : unique run id
     */
    void SetRunId(UInt_t runid) { fRunId = runid; }

    /** Get the run ID for this run*/
    UInt_t GetRunId() { return fRunId; }

    /** Return the list of tasks class names */
    TList* GetListOfTasks() { return fTaskList; }

    void AddInputFile(TFile* f, UInt_t id, UInt_t ChId);

    /**
     * Destructor
     */
    virtual ~FairFileHeader();

    FairFileInfo* GetFileInfo(UInt_t id, UInt_t ChId);

  protected:
    /** Run Id */
    UInt_t fRunId;

    /**list of TObjStrings presenting the class names of tasks used to produce this file */
    TList* fTaskList;

    /**list of TObjStrings presenting the input files used to produce this file*/
    TList* fFileList;

  private:
    FairFileHeader(const FairFileHeader&);
    FairFileHeader& operator=(const FairFileHeader&);

    ClassDef(FairFileHeader, 2);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//  FairFileInfo.h
//  Created by Mohammad Al-Turany on 6/21/11.
//
#ifndef FAIRFILEINFO_H
#define FAIRFILEINFO_H

#include <Rtypes.h>    // for UInt_t, FairFileInfo::Class, etc
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString

class TFile;

class FairFileInfo : public TNamed
{
  public:
    FairFileInfo();
    FairFileInfo(TFile* file, UInt_t id, UInt_t ChId);
    virtual ~FairFileInfo();

    TString GetPath() { return fPath; }
    UInt_t GetSize() { return fSize; }
    UInt_t GetIdentifier() { return fIdentifier; }
    UInt_t GetOrderInChain() { return fInChainId; }

    void Print(Option_t* option = "") const;

    void SetPath(TString path) { fPath = path; }
    void SetSize(UInt_t size) { fSize = size; }
    void SetIdentifier(UInt_t id) { fIdentifier = id; }
    void SetOrderInChain(UInt_t id) { fInChainId = id; }

  protected:
    /** Full path of file*/
    TString fPath;
    /** size of file in bytes*/
    UInt_t fSize;
    /** Signal file identifier used*/
    UInt_t fIdentifier;
    /** file order in the chain*/
    UInt_t fInChainId;

  private:
    FairFileInfo(const FairFileInfo&);
    FairFileInfo& operator=(const FairFileInfo&);

    ClassDef(FairFileInfo, 1);
};

#endif   // FAIRFILEINFO_H
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRHIT_H
#define FAIRHIT_H

#include "FairTimeStamp.h"   // for FairTimeStamp

#include <Rtypes.h>     // for Double_t, Int_t, Double32_t, etc
#include <TVector3.h>   // for TVector3

/**
 * Abstract base class for reconstructed hits in the FAIR detectors.
 **@author V.Friese <v.friese@gsi.de>
 **@author D.Bertini <d.bertini@gsi.de>
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairHit : public FairTimeStamp
{
  public:
    /** Default constructor **/
    FairHit();

    /** Constructor with hit parameters **/
    FairHit(Int_t detID, const TVector3& pos, const TVector3& dpos, Int_t index);

    /** Destructor **/
    virtual ~FairHit();

    /** Accessors **/
    Double_t GetDx() const { return fDx; };
    Double_t GetDy() const { return fDy; };
    Double_t GetDz() const { return fDz; };
    Int_t GetRefIndex() const { return fRefIndex; };
    void PositionError(TVector3& dpos) const;
    Int_t GetDetectorID() const { return fDetectorID; };
    Double_t GetX() const { return fX; };
    Double_t GetY() const { return fY; };
    Double_t GetZ() const { return fZ; };
    void Position(TVector3& pos) const;

    /** Modifiers **/
    void SetDx(Double_t dx) { fDx = dx; }
    void SetDy(Double_t dy) { fDy = dy; }
    void SetDz(Double_t dz) { fDz = dz; }
    void SetDxyz(Double_t dx, Double_t dy, Double_t dz);
    void SetPositionError(const TVector3& dpos);
    void SetRefIndex(Int_t index) { fRefIndex = index; }
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);

    /*** Output to screen */
    virtual void Print(const Option_t*) const { ; }

  protected:
    Double32_t fDx, fDy, fDz;   ///< Errors of position [cm]
    Int_t fRefIndex;            ///< Index of FairMCPoint for this hit
    Int_t fDetectorID;          ///< Detector unique identifier
    Double32_t fX, fY, fZ;      ///< Position of hit [cm]

    ClassDef(FairHit, 3);
};

inline void FairHit::PositionError(TVector3& dpos) const { dpos.SetXYZ(fDx, fDy, fDz); }

inline void FairHit::SetDxyz(Double_t dx, Double_t dy, Double_t dz)
{
    fDx = dx;
    fDy = dy;
    fDz = dz;
}

inline void FairHit::SetPositionError(const TVector3& dpos)
{
    fDx = dpos.X();
    fDy = dpos.Y();
    fDz = dpos.Z();
}

inline void FairHit::Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); }

inline void FairHit::SetXYZ(Double_t x, Double_t y, Double_t z)
{
    fX = x;
    fY = y;
    fZ = z;
}

inline void FairHit::SetPosition(const TVector3& pos)
{
    fX = pos.X();
    fY = pos.Y();
    fZ = pos.Z();
}

#endif   // FAIRHIT_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairLink.h
 *
 *  Created on: Dec 23, 2009
 *      Author: stockman
 *      "Pointer" to any data structure inside a root file with a tree structure
 *      Contains four information:
 *      	File : in which file is the data written (-1 : actual number; 254 : maximum number)
 *      	Entry: entry number in branch of a tree (-1 : actual entry)
 *      	Type : branch inside the tree (-1 : FairLink not set; 65534 : maximum number)
 *      	Index: position inside a container stored in the given branch and entry
 *      	Weight: weighting factor to describe probabilities of a MC truth match
 *
 */

#ifndef FAIRLINK_H_
#define FAIRLINK_H_

#include <Rtypes.h>   // for Int_t, Float_t, etc, ClassDefNV
#include <iostream>   // for ostream, cout

class FairLink
{
  public:
    FairLink();
    FairLink(Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(TString branchName, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.);
    FairLink(Int_t file, Int_t entry, TString branchName, Int_t index, Float_t weight = 1.);
    ~FairLink(){};

    void SetLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight = 1.)
    {
        SetFile(file);
        SetEntry(entry);
        SetType(type);
        SetIndex(index);
        SetWeight(weight);
    };
    void SetLink(Int_t type, Int_t index, Float_t weight = 1.)
    {
        SetFile(-1);
        SetEntry(-1);
        SetType(type);
        SetIndex(index);
        SetWeight(weight);
    };
    int GetFile() const;
    int GetEntry() const { return fEntry; }
    int GetType() const;
    int GetIndex() const { return fIndex; }
    float GetWeight() const { return fWeight; }

    void SetFile(int file);
    void SetEntry(int entry) { fEntry = entry; };
    void SetType(int type);
    void SetIndex(int index) { fIndex = index; };

    void SetWeight(Float_t weight) { fWeight = weight; }
    void AddWeight(Float_t weight) { fWeight += weight; }

    void PrintLinkInfo(std::ostream& out = std::cout) const;

    bool operator==(const FairLink& link) const
    {
        return (GetFile() == link.GetFile() || link.GetFile() == -1)
               && (GetEntry() == link.GetEntry() || link.GetEntry() == -1) && GetType() == link.GetType()
               && GetIndex() == link.GetIndex();
    }

    bool operator<(const FairLink& link) const
    {
        if (GetFile() != -1 && link.GetFile() != -1) {
            if (GetFile() < link.GetFile())
                return true;
            else if (link.GetFile() < GetFile())
                return false;
        }
        if (GetEntry() != -1 && link.GetEntry() != -1) {
            if (GetEntry() < link.GetEntry())
                return true;
            else if (link.GetEntry() < GetEntry())
                return false;
        }
        if (GetType() < link.GetType())
            return true;
        else if (link.GetType() < GetType())
            return false;
        if (GetIndex() < link.GetIndex())
            return true;
        else if (link.GetIndex() < GetIndex())
            return false;

        return false;
    }

    friend std::ostream& operator<<(std::ostream& out, const FairLink& link)
    {
        link.PrintLinkInfo(out);
        return out;
    }

    ClassDefNV(FairLink, 5);

    template<class Archive>
    void serialize(Archive& ar, const unsigned int)
    {
        ar& fFile;
        ar& fType;
        ar& fEntry;
        ar& fIndex;
        ar& fWeight;
    }

  private:
    unsigned char fFile;
    unsigned short fType;
    int fEntry;
    int fIndex;
    float fWeight;
};

inline FairLink::FairLink()
    : fFile(0)
    , fType(0)
    , fEntry(-1)
    , fIndex(-1)
    , fWeight(1.0)
{}

inline FairLink::FairLink(Int_t type, Int_t index, Float_t weight)
    : fFile(0)
    , fType(0)
    , fEntry(-1)
    , fIndex(index)
    , fWeight(weight)
{
    SetType(type);
}

inline FairLink::FairLink(Int_t file, Int_t entry, Int_t type, Int_t index, Float_t weight)
    : fFile(0)
    , fType(0)
    , fEntry(entry)
    , fIndex(index)
    , fWeight(weight)
{
    SetFile(file);
    SetType(type);
}

inline void FairLink::SetType(int type)
{
    if (type < -1)
        return;
    fType = type + 1;
}

inline int FairLink::GetType() const
{
    int type = fType;
    return type - 1;
}

inline void FairLink::SetFile(int file)
{
    if (file < -1)
        return;
    fFile = file + 1;
}

inline int FairLink::GetFile() const
{
    int file = fFile;
    return file - 1;
}

#endif /* FAIRLINK_H_ */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/** FairMCEventHeader.h
 *@author V.Friese <v.friese@gsi.de>
 ** Data class (level MC) containing information about the input event.
 ** 15.05.2008 change the event time to ns (M. Al-Turany)
 **/

#ifndef FAIRMCEVENTHEADER_H
#define FAIRMCEVENTHEADER_H 1

#include <Rtypes.h>     // for Double_t, UInt_t, etc
#include <TNamed.h>     // for TNamed
#include <TVector3.h>   // for TVector3
#include <limits>       // for std::numeric_limits

class FairMCEventHeader : public TNamed
{
  public:
    /// Alias name for event id type
    using EventID = UInt_t;

    /// Sentinel value for the event id, meaning no event id stored
    static constexpr EventID NoEventID = std::numeric_limits<EventID>::max();

    /** Default constructor **/
    FairMCEventHeader();

    /** Constructor with all members
     **
     *@param iEvent   event identifier
     *@param x,y,z    vertex oordinates [cm]
     *@param t        event time [ns]
     *@param b        impact parameter [fm] (if relevant)
     *@param nPrim    number of input tracks
     **/
    FairMCEventHeader(EventID iEvent, Double_t x, Double_t y, Double_t z, Double_t t, Double_t b, Int_t nPrim);

    /** Standard constructor with run identifier **/
    FairMCEventHeader(UInt_t runId);

    /** Destructor **/
    virtual ~FairMCEventHeader();

    /** Accessors **/
    UInt_t GetRunID() const { return fRunId; }        /// run identifier
    EventID GetEventID() const { return fEventId; }   /// event identifier
    /// check whether an event id is set
    Bool_t HasEventID() const { return fEventId != NoEventID; }
    Double_t GetX() const { return fX; }         /// vertex x [cm]
    Double_t GetY() const { return fY; }         /// vertex y [cm]
    Double_t GetZ() const { return fZ; }         /// vertex z [cm]
    Double_t GetT() const { return fT; }         /// event time [ns]
    Double_t GetB() const { return fB; }         /// impact parameter [fm]
    Int_t GetNPrim() const { return fNPrim; }    /// number of input tracks
    Bool_t IsSet() const { return fIsSet; }      /// Flag
    Double_t GetRotX() const { return fRotX; }   /// rot. around x-axis [rad]
    Double_t GetRotY() const { return fRotY; }   /// rot. around y-axis [rad]
    Double_t GetRotZ() const { return fRotZ; }   /// rot. around z-axis [rad]

    void GetVertex(TVector3& vertex) { vertex.SetXYZ(fX, fY, fZ); }

    /** Modifiers **/
    void SetEventID(EventID eventId) { fEventId = eventId; }
    void SetRunID(UInt_t runId) { fRunId = runId; }
    void SetTime(Double_t t) { fT = t; }
    void SetB(Double_t b) { fB = b; }
    void SetNPrim(Int_t nPrim) { fNPrim = nPrim; }
    void MarkSet(Bool_t isSet) { fIsSet = isSet; }
    void SetVertex(Double_t x, Double_t y, Double_t z);
    void SetVertex(const TVector3& vertex);
    void SetRotX(Double_t rotx) { fRotX = rotx; }
    void SetRotY(Double_t roty) { fRotY = roty; }
    void SetRotZ(Double_t rotz) { fRotZ = rotz; }

    /** Reset all members **/
    void Reset();

    /** Register the class as data branch to the output */
    virtual void Register();

  protected:
    UInt_t fRunId;                 ///  Run identifier
    EventID fEventId{NoEventID};   ///  Event identifier
    Double32_t fX;                 ///  Primary vertex x [cm]
    Double32_t fY;                 ///  Primary vertex y [cm]
    Double32_t fZ;                 ///  Primary vertex z [cm]
    Double32_t fT;                 ///  Event time [s]
    Double32_t fB;                 ///  Impact parameter [fm] (if relevant)
    Int_t fNPrim;                  ///  Number of input tracks
    Bool_t fIsSet;                 ///  Flag whether variables are filled
    Double32_t fRotX;              ///  Rotation around x-axis (beam tilt) [rad]
    Double32_t fRotY;              ///  Rotation around y-axis (beam tilt) [rad]
    Double32_t fRotZ;              ///  Rotation around z-axis (event plane) [rad]

    ClassDef(FairMCEventHeader, 2);
};

inline void FairMCEventHeader::SetVertex(Double_t x, Double_t y, Double_t z)
{
    fX = x;
    fY = y;
    fZ = z;
}

inline void FairMCEventHeader::SetVertex(const TVector3& vertex)
{
    fX = vertex.X();
    fY = vertex.Y();
    fZ = vertex.Z();
}

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**  FairMCPoint.h
 * This is the base class for all MC Points generated by the transport of
 * tracks through active detectors.
 **/

#ifndef FAIRMCPOINT_H
#define FAIRMCPOINT_H

#include "FairMultiLinkedData_Interface.h"   // for FairMultiLinkedData

#include <Rtypes.h>     // for Double_t, Double32_t, Int_t, etc
#include <TVector3.h>   // for TVector3

class FairMCPoint : public FairMultiLinkedData_Interface
{
  public:
    /** Default constructor **/
    FairMCPoint();

    /** Constructor with arguments
     *@param trackID  Index of MCTrack
     *@param detID    Detector ID
     *@param pos      Point coordinates [cm]
     *@param mom      Momentum of track at MCPoint [GeV]
     *@param tof      Time since event start [ns]
     *@param length   Track length since creation [cm]
     *@param eLoss    Energy deposit [GeV]
     *@param EventId  MC event id
     **/
    FairMCPoint(Int_t trackID,
                Int_t detID,
                TVector3 pos,
                TVector3 mom,
                Double_t tof,
                Double_t length,
                Double_t eLoss,
                UInt_t EventId = 0);

    /** Destructor **/
    virtual ~FairMCPoint();

    /** Accessors */
    UInt_t GetEventID() const { return fEventId; }   /// event identifier
    Int_t GetTrackID() const { return fTrackID; }
    Double_t GetPx() const { return fPx; }
    Double_t GetPy() const { return fPy; }
    Double_t GetPz() const { return fPz; }
    Double_t GetTime() const { return fTime; }
    Double_t GetLength() const { return fLength; }
    Double_t GetEnergyLoss() const { return fELoss; }
    void Momentum(TVector3& mom) const { mom.SetXYZ(fPx, fPy, fPz); }
    Int_t GetDetectorID() const { return fDetectorID; };
    Double_t GetX() const { return fX; };
    Double_t GetY() const { return fY; };
    Double_t GetZ() const { return fZ; };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); }

    /** Modifiers **/
    void SetEventID(UInt_t eventId) { fEventId = eventId; }
    virtual void SetTrackID(Int_t id) { fTrackID = id; }
    void SetTime(Double_t time) { fTime = time; }
    void SetLength(Double_t length) { fLength = length; }
    void SetEnergyLoss(Double_t eLoss) { fELoss = eLoss; }
    void SetMomentum(const TVector3& mom);
    void SetDetectorID(Int_t detID) { fDetectorID = detID; }
    void SetX(Double_t x) { fX = x; }
    void SetY(Double_t y) { fY = y; }
    void SetZ(Double_t z) { fZ = z; }
    void SetXYZ(Double_t x, Double_t y, Double_t z);
    void SetPosition(const TVector3& pos);

    /** Output to screen **/
    virtual void Print(const Option_t* opt = 0) const;

  protected:
    Int_t fTrackID;             ///< Track index
    UInt_t fEventId;            ///< MC Event id
    Double32_t fPx, fPy, fPz;   ///< Momentum components [GeV]
    Double32_t fTime;           ///< Time since event start [ns]
    Double32_t fLength;         ///< Track length since creation [cm]
    Double32_t fELoss;          ///< Energy loss at this point [GeV]
    Int_t fDetectorID;          ///< Detector unique identifier
    Double32_t fX, fY, fZ;      ///< Position of hit [cm]

    ClassDef(FairMCPoint, 5);
};

inline void FairMCPoint::SetMomentum(const TVector3& mom)
{
    fPx = mom.Px();
    fPy = mom.Py();
    fPz = mom.Pz();
}

inline void FairMCPoint::SetXYZ(Double_t x, Double_t y, Double_t z)
{
    fX = x;
    fY = y;
    fZ = z;
}

inline void FairMCPoint::SetPosition(const TVector3& pos)
{
    fX = pos.X();
    fY = pos.Y();
    fZ = pos.Z();
}

#endif   // FAIRMCPOINT_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairMesh header file                    -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------

#ifndef FAIRMESH_H
#define FAIRMESH_H

#include <Rtypes.h>    // for Double_t, Int_t, etc
#include <TH2.h>       // for TH2D
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString

/**
 * Abstract base class for Mesh Objects.
 **@author D.Bertini <d.bertini@gsi.de>
 */
class FairMesh : public TObject
{
  public:
    /** Default constructor **/
    FairMesh();
    FairMesh(const char*);

    /** Destructor **/
    virtual ~FairMesh();

    /** Accessors **/
    Double_t GetXmin() const { return fXmin; };
    Double_t GetYmin() const { return fYmin; };
    Double_t GetZmin() const { return fZmin; };

    Double_t GetXmax() const { return fXmax; };
    Double_t GetYmax() const { return fYmax; };
    Double_t GetZmax() const { return fZmax; };

    /** Modifiers **/
    void SetX(Double_t xmin, Double_t xmax, Int_t nbin)
    {
        fXmin = xmin;
        fXmax = xmax;
        NXbin = nbin;
    }
    void SetY(Double_t ymin, Double_t ymax, Int_t nbin)
    {
        fYmin = ymin;
        fYmax = ymax;
        NYbin = nbin;
    }
    void SetZ(Double_t zmin, Double_t zmax, Int_t nbin)
    {
        fZmin = zmin;
        fZmax = zmax;
        NZbin = nbin;
    }

    TH2D* GetMeshTid() { return fMeshTid; }
    TH2D* GetMeshFlu() { return fMeshFlu; }
    TH2D* GetMeshSEU() { return fMeshSEU; }
    /*** Output to screen */
    // virtual void Print(const Option_t* opt = 0) const {;}

    Double_t GetDiag() { return fDiag; }
    Double_t GetBinVolume() { return fBinVolume; }

    void fillTID(Double_t x, Double_t y, Double_t we) { fMeshTid->Fill(x, y, we); }
    void fillFluence(Double_t x, Double_t y, Double_t we) { fMeshFlu->Fill(x, y, we); }
    void fillSEU(Double_t x, Double_t y, Double_t we) { fMeshSEU->Fill(x, y, we); }
    void Scale(Double_t fac)
    {
        fMeshTid->Scale(fac);
        fMeshFlu->Scale(fac);
        fMeshSEU->Scale(fac);
    }

    void calculate();

    void print();

  protected:
    Double_t fXmin, fYmin, fZmin;
    Double_t fXmax, fYmax, fZmax;
    Int_t NXbin, NYbin, NZbin;
    Double_t fBinVolume;
    Double_t fDiag;
    TH2D* fMeshTid;   // !mesh
    TH2D* fMeshFlu;   // !mesh
    TH2D* fMeshSEU;   // !mesh
    TString fhname;   // !mesh

  private:
    FairMesh(const FairMesh&);
    FairMesh& operator=(const FairMesh&);

    ClassDef(FairMesh, 1);
};

#endif
/**
 * FairMultiLinkedData_Interface.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FairMultiLinkedData_Interface_H_
#define FairMultiLinkedData_Interface_H_

#include "FairLink.h"   // for FairLink
#include "FairMultiLinkedData.h"

#include <Rtypes.h>    // for Int_t, Bool_t, kFALSE, etc
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString
#include <iostream>    // for operator<<, ostream, cout
#include <memory>      // for std::unique_ptr
#include <set>         // for set
#include <vector>      // for vector

class FairMultiLinkedData_Interface : public TObject
{
  public:
    FairMultiLinkedData_Interface() = default;   ///< Default constructor
    FairMultiLinkedData_Interface(FairMultiLinkedData& links, Bool_t persistanceCheck = kTRUE);   ///< Constructor
    FairMultiLinkedData_Interface(TString dataType,
                                  std::vector<Int_t> links,
                                  Int_t fileId = -1,
                                  Int_t evtId = -1,
                                  Bool_t persistanceCheck = kTRUE,
                                  Bool_t bypass = kFALSE,
                                  Float_t mult = 1.0);   ///< Constructor
    FairMultiLinkedData_Interface(Int_t dataType,
                                  std::vector<Int_t> links,
                                  Int_t fileId = -1,
                                  Int_t evtId = -1,
                                  Bool_t persistanceCheck = kTRUE,
                                  Bool_t bypass = kFALSE,
                                  Float_t mult = 1.0);   ///< Constructor
    FairMultiLinkedData_Interface(const FairMultiLinkedData_Interface& toCopy);

    ~FairMultiLinkedData_Interface() = default;

    FairMultiLinkedData_Interface& operator=(const FairMultiLinkedData_Interface& rhs);

    std::set<FairLink> GetLinks() const;                      ///< returns stored links as FairLinks
    Int_t GetNLinks() const;                                  ///< returns the number of stored links
    FairLink GetLink(Int_t pos) const;                        ///< returns the FairLink at the given position
    FairMultiLinkedData GetLinksWithType(Int_t type) const;   ///< returns all FairLinks with the corresponding type
    FairLink GetEntryNr() const;
    FairMultiLinkedData* GetPointerToLinks() const { return fLink.get(); }   ///< returns non-owning pointer

    std::vector<FairLink> GetSortedMCTracks();

    void SetLinks(FairMultiLinkedData links);   ///< Sets the links as vector of FairLink
    void SetLink(FairLink link);                ///< Sets the Links with a single FairLink
    void SetInsertHistory(Bool_t val);
    void SetEntryNr(FairLink val);
    ///< @param[in] links transfers ownership
    void SetPointerToLinks(FairMultiLinkedData* links) { fLink.reset(links); }
    void SetPointerToLinks(std::unique_ptr<FairMultiLinkedData> links) { fLink = std::move(links); }

    void AddLinks(FairMultiLinkedData links,
                  Float_t mult = 1.0);   ///< Adds a List of FairLinks (FairMultiLinkedData_Interface) to fLinks
    void AddLink(FairLink link);   ///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link is allowed
                                   ///< more than once otherwise
    void AddInterfaceData(FairMultiLinkedData_Interface* data);

    void ResetLinks();

    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const
    {
        if (GetPointerToLinks() != 0)
            GetPointerToLinks()->PrintLinkInfo(out);
        return out;
    }   ///< Output

    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData_Interface& data)
    {
        data.PrintLinkInfo(out);
        return out;
    }   ///< Output

  protected:
    std::unique_ptr<FairMultiLinkedData> fLink;
    FairMultiLinkedData* CreateFairMultiLinkedData();   ///< returns non-owning pointer

    ClassDef(FairMultiLinkedData_Interface, 6);
};

/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is
 * stored
 */

/**\fn virtual void FairMultiLinkedData_Interface::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is
 * stored
 */

#endif /* FairMultiLinkedData_Interface_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * FairMultiLinkedData.h
 *
 * \date Dec 7, 2009
 * \author T.Stockmanns <t.stockmanns@fz-juelich.de>
 */

#ifndef FAIRMULTILINKEDDATA_H_
#define FAIRMULTILINKEDDATA_H_

#include "FairLink.h"   // for FairLink

#include <Rtypes.h>    // for Int_t, Bool_t, kFALSE, etc
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString
#include <iosfwd>      // for ostream
#include <iostream>    // for operator<<, ostream, cout
#include <set>         // for set
#include <vector>      // for vector

class FairMultiLinkedData : public TObject
{
  public:
    FairMultiLinkedData();                                                                   ///< Default constructor
    FairMultiLinkedData(const std::set<FairLink>& links, Bool_t persistanceCheck = kTRUE);   ///< Constructor
    FairMultiLinkedData(TString dataType,
                        const std::vector<Int_t>& links,
                        Int_t fileId = -1,
                        Int_t evtId = -1,
                        Bool_t persistanceCheck = kTRUE,
                        Bool_t bypass = kFALSE,
                        Float_t mult = 1.0);   ///< Constructor
    FairMultiLinkedData(Int_t dataType,
                        const std::vector<Int_t>& links,
                        Int_t fileId = -1,
                        Int_t evtId = -1,
                        Bool_t persistanceCheck = kTRUE,
                        Bool_t bypass = kFALSE,
                        Float_t mult = 1.0);   ///< Constructor

    virtual ~FairMultiLinkedData(){};

    virtual std::set<FairLink> GetLinks() const { return fLinks; }   ///< returns stored links as FairLinks
    virtual FairLink GetEntryNr() const { return fEntryNr; }         ///< gives back the entryNr
    virtual Int_t GetNLinks() const { return fLinks.size(); }        ///< returns the number of stored links
    virtual FairLink GetLink(Int_t pos) const;                       ///< returns the FairLink at the given position
    virtual FairMultiLinkedData GetLinksWithType(
        Int_t type) const;   ///< Gives you a list of links which contain the given type
    virtual std::vector<FairLink>
        GetSortedMCTracks();   ///< Gives you a list of all FairLinks pointing to a "MCTrack" sorted by their weight
    TObject* GetData(FairLink& myLink);   ///< Get the TObject the Link is pointing to
    virtual Int_t GetDefaultType() { return fDefaultType; }
    Bool_t GetPersistanceCheck() { return fPersistanceCheck; }   ///< Returns the value of PersistanceCheck
    Int_t GetVerbose() { return fVerbose; }                      ///< Returns the verbosity level
    virtual void SetDefaultType(Int_t type) { fDefaultType = type; }
    virtual void SetPersistanceCheck(Bool_t check)
    {
        fPersistanceCheck = check;
    }   ///< Controls if a persistance check of a link is done or not
    virtual void SetVerbose(Int_t level) { fVerbose = level; }   ///< Sets the verbosity level
    virtual void SetInsertHistory(Bool_t val)
    {
        fInsertHistory = val;
    }   ///< Toggles if history of a link is inserted or not
    Bool_t GetInsertHistory() const { return fInsertHistory; }

    virtual void SetEntryNr(FairLink entry) { fEntryNr = entry; }
    virtual void SetLinks(FairMultiLinkedData links, Float_t mult = 1.0);   ///< Sets the links as vector of FairLink
    virtual void SetLink(FairLink link,
                         Bool_t bypass = kFALSE,
                         Float_t mult = 1.0);   ///< Sets the Links with a single FairLink

    virtual void AddLinks(FairMultiLinkedData links,
                          Float_t mult = 1.0);   ///< Adds a List of FairLinks (FairMultiLinkedData) to fLinks
    virtual void AddLink(FairLink link,
                         Bool_t bypass = kFALSE,
                         Float_t mult = 1.0);   ///< Adds a FairLink link at the end of fLinks. If multi is kTRUE a link
                                                ///< is allowed more than once otherwise it is stored only once

    virtual void InsertLink(FairLink link);   ///< Inserts a link into the list of links without persistance checking
    virtual void InsertHistory(
        FairLink link);   ///< Adds the FairLinks of the inserted link to the set of links of this object

    virtual void AddAllWeights(Double_t weight);        ///< Adds weight to all Links
    virtual void SetAllWeights(Double_t weight);        ///< Sets a common weight for Links
    virtual void MultiplyAllWeights(Double_t weight);   ///< Multiplies all Links with weight

    virtual Bool_t IsLinkInList(FairLink link)
    {
        return IsLinkInList(link.GetType(), link.GetIndex());
    }   ///< Test if a given link is in fLinks
    virtual Bool_t IsLinkInList(
        Int_t type,
        Int_t index);   ///< Same as IsLinkInList(FairLink) just with type and index given separately
    virtual Int_t LinkPosInList(FairLink link)
    {
        return LinkPosInList(link.GetType(), link.GetIndex());
    }   ///< returns position of link in fLinks. If it is not in the list -1 is returned
    virtual Int_t LinkPosInList(Int_t type, Int_t index);   ///< Same as LinkPosInList(FairLink)

    virtual void DeleteLink(FairLink link)
    {
        DeleteLink(link.GetType(), link.GetIndex());
    }                                                   ///< Deletes a link ouf of fLinks
    virtual void DeleteLink(Int_t type, Int_t index);   ///< Deletes a link ouf of fLinks

    virtual void Reset() { ResetLinks(); }
    virtual void ResetLinks() { fLinks.clear(); }   ///< Clears fLinks

    std::ostream& PrintLinkInfo(std::ostream& out = std::cout) const
    {
        out << GetEntryNr() << " -> [";
        for (Int_t i = 0; i < GetNLinks(); i++) {
            GetLink(i).PrintLinkInfo(out);
            out << " ";
        }
        out << "]";
        return out;
    }   ///< Output

    friend std::ostream& operator<<(std::ostream& out, const FairMultiLinkedData& data)
    {
        data.PrintLinkInfo(out);
        return out;
    }   ///< Output

  protected:
    std::set<FairLink> fLinks;
    FairLink fEntryNr;
    Bool_t fPersistanceCheck;   //!
    Bool_t fInsertHistory;      //!
    Int_t fVerbose;             //!

    virtual void SimpleAddLinks(Int_t fileId,
                                Int_t evtId,
                                Int_t dataType,
                                const std::vector<Int_t>& links,
                                Bool_t,
                                Float_t)
    {
        for (UInt_t i = 0; i < links.size(); i++) {
            fLinks.insert(FairLink(fileId, evtId, dataType, links[i]));
        }
    }
    Int_t fDefaultType;

    ClassDef(FairMultiLinkedData, 4);
};

/**\fn virtual void FairMultiLinkedData::SetLinks(Int_t type, std::vector<Int_t> links)
 * \param type as Int_t gives one type of source data for all indices
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is
 * stored
 */

/**\fn virtual void FairMultiLinkedData::SetLinks(std::vector<Int_t> type, std::vector<Int_t> links)
 * \param type as vector<Int_t> gives the type of source data (TClonesArray)
 * \param links as vector<Int_t> gives the vector of indices at which position in the TClonesArray the source data is
 * stored
 */

#endif /* FAIRMULTILinkedData_H_ */
// -------------------------------------------------------------------------
// -----                 FairPrintFairLinks header file             -----
// -----                  Created 20/03/07  by R.Kliemt               -----
// -------------------------------------------------------------------------

/** FairPrintFairLinks.h
 *@author T.Stockmanns <t.stockmanns@fz-juelich.de>
 **
 ** Prints all FairLinks of a given branch to the screen
 **/

#ifndef FairPrintFairLinks_H
#define FairPrintFairLinks_H

// framework includes
#include "FairTask.h"
#include "TObjString.h"

#include <map>

class TClonesArray;

class FairPrintFairLinks : public FairTask
{
  public:
    /** Default constructor **/
    FairPrintFairLinks();

    /** Destructor **/
    virtual ~FairPrintFairLinks();

    virtual void AddBranchName(const TString& name) { fSelectedBranches->AddLast(new TObjString(name.Data())); }

    virtual void PrintBranchNameList(TList* branches);

    virtual InitStatus Init();

    /** Virtual method Exec **/
    virtual void Exec(Option_t* opt);

    virtual void Finish();

  protected:
    void InitBranchList(TList* branches);

  private:
    std::map<Int_t, TClonesArray*> fBranches;
    TList* fSelectedBranches;

    void Register();
    void Reset();
    void ProduceHits();

    ClassDef(FairPrintFairLinks, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenPoint header file               -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------

/**  FairRadLenPoint.h
 *@author M. Al-Turany
 *
 */

#ifndef FAIRRADLENPOINT_H
#define FAIRRADLENPOINT_H

#include "FairMCPoint.h"   // for FairMCPoint

#include <Rtypes.h>     // for Double_t, Float_t, etc
#include <TVector3.h>   // for TVector3

class FairRadLenPoint : public FairMCPoint
{
  public:
    /** Default constructor **/
    FairRadLenPoint();

    FairRadLenPoint(Int_t trackID,
                    Int_t detID,
                    TVector3 pos,
                    TVector3 mom,
                    Double_t tof,
                    Double_t length,
                    Double_t eLoss,
                    TVector3 posOut,
                    TVector3 momOut,
                    Float_t fA,
                    Float_t fZ,
                    Float_t fDensity,
                    Float_t fRadLen);

    /** Destructor **/
    virtual ~FairRadLenPoint();

    /** Accessors **/
    Float_t GetA() { return fA; }
    Float_t GetZm() { return fZmat; }
    Float_t GetRadLength() { return fRadLen; }
    Float_t GetDensity() { return fDensity; }

    /** Modifiers **/
    void SetA(Double_t A) { fA = A; }
    void SetZm(Double_t Z) { fZmat = Z; }
    void SetRadLength(Double_t length) { fRadLen = length; }
    void SetDensity(Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Double_t GetXOut() const { return fXOut; };
    Double_t GetYOut() const { return fYOut; };
    Double_t GetZOut() const { return fZOut; };

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ); }
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut); }

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut); };
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut, fPyOut, fPzOut); }

  protected:
    Float_t fA;         // A of material
    Float_t fZmat;      // Z of material
    Float_t fDensity;   // density of material
    Float_t fRadLen;    // radiation length

    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;

    ClassDef(FairRadLenPoint, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairRadMapPoint header file               -----
// -------------------------------------------------------------------------

/**  FairRadMapPoint.h
 *@author O.N. Hartmann
 *
 */

#ifndef FAIRRADMAPPOINT_H
#define FAIRRADMAPPOINT_H

#include "FairMCPoint.h"   // for FairMCPoint

#include <Rtypes.h>     // for Double_t, Float_t, Int_t, etc
#include <TVector3.h>   // for TVector3

class FairRadMapPoint : public FairMCPoint
{
  public:
    /** Default constructor **/
    FairRadMapPoint();

    FairRadMapPoint(Int_t trackID,
                    Int_t detID,
                    TVector3 pos,
                    TVector3 mom,
                    Double_t tof,
                    Double_t length,
                    Double_t eLoss,
                    TVector3 posOut,
                    TVector3 momOut,
                    Float_t fA,
                    Float_t fZ,
                    Float_t fDensity,
                    Double_t fVolMass,
                    Double_t fStep,
                    Double_t fDose,
                    Double_t fDoseSL,
                    Int_t fPdg);

    /** Destructor **/
    virtual ~FairRadMapPoint();

    /** Accessors **/
    Float_t GetA() { return fA; }
    Float_t GetZm() { return fZmat; }
    Float_t GetMass() { return fVolMass; }
    Float_t GetDensity() { return fDensity; }

    /** Modifiers **/
    void SetA(Double_t A) { fA = A; }
    void SetZm(Double_t Z) { fZmat = Z; }
    void SetMass(Double_t vmass) { fVolMass = vmass; }
    void SetDensity(Double_t Density) { fDensity = Density; }

    /** Output to screen **/
    virtual void Print(const Option_t* opt) const;

    Int_t GetPdg() const { return fPdg; };

    Double_t GetXOut() const { return fXOut; }
    Double_t GetYOut() const { return fYOut; }
    Double_t GetZOut() const { return fZOut; }

    Double_t GetPxOut() const { return fPxOut; }
    Double_t GetPyOut() const { return fPyOut; }
    Double_t GetPzOut() const { return fPzOut; }

    Double_t GetDose() const { return fDose; }
    Double_t GetDoseSL() const { return fDoseSL; }

    TVector3 GetPosition() const { return TVector3(fX, fY, fZ); }
    TVector3 GetPositionOut() const { return TVector3(fXOut, fYOut, fZOut); }

    void PositionOut(TVector3& pos) const { pos.SetXYZ(fXOut, fYOut, fZOut); };
    void MomentumOut(TVector3& mom) const { mom.SetXYZ(fPxOut, fPyOut, fPzOut); }

  protected:
    // Int_t detID; // detector ID or volume ID
    Int_t fPdg;          // track PID
    Float_t fA;          // A of material
    Float_t fZmat;       // Z of material
    Float_t fDensity;    // density of material
    Double_t fVolMass;   // radiation length

    Double_t fStep, fDose, fDoseSL;
    Double_t fXOut, fYOut, fZOut;
    Double_t fPxOut, fPyOut, fPzOut;

    ClassDef(FairRadMapPoint, 3);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----          FairRecoEventHeader header file                      -----
// -----          Created 20/09/13                 R.Karabowicz        -----
// -------------------------------------------------------------------------

#ifndef FAIRRECOEVENTHEADER_H
#define FAIRRECOEVENTHEADER_H

#include <TNamed.h>

/**
 *  Event Header Class
 **@author D.Bertini <d.bertini@gsi.de>
 **@author M.Al-Turany <m.al-turany@gsi.de>
 **@author R.Karabowicz <r.karabowicz@gsi.de>
 */
class FairRecoEventHeader : public TNamed
{
  public:
    /** Default constructor */
    FairRecoEventHeader();

    /** Get the run ID for this run*/
    UInt_t GetRunId() const { return fRunId; }

    /** Get the MC time for this event*/
    Double_t GetEventTime() const { return fEventTime; }

    /** Get the error of MC time for this event*/
    Double_t GetEventTimeError() const { return fEventTimeError; }

    /** Get identifier*/
    Int_t GetIdentifier() const { return fIdentifier; }

    /** Set the run ID for this run
     * @param runid : unique run id
     */
    void SetRunId(UInt_t runid) { fRunId = runid; }

    /** Set the MC time for this event
     * @param time : time in ns
     * @param terr : time error in ns
     */
    void SetEventTime(Double_t time, Double_t terr)
    {
        fEventTime = time;
        fEventTimeError = terr;
    }

    /** Set the run ID for this run
     * @param ident : identifier
     */
    void SetIdentifier(Int_t ident) { fIdentifier = ident; }

    virtual bool operator<(const FairRecoEventHeader& tempObj) const
    {
        if (fEventTime < tempObj.GetEventTime()) {
            return true;
        } else if (fEventTime > tempObj.GetEventTime()) {
            return false;
        }
        return false;
    }

    virtual bool operator>(const FairRecoEventHeader& tempObj) const
    {
        if (fEventTime > tempObj.GetEventTime()) {
            return true;
        } else if (fEventTime < tempObj.GetEventTime()) {
            return false;
        }
        return false;
    }

    virtual bool operator==(const FairRecoEventHeader& tempObj) const { return fEventTime == tempObj.GetEventTime(); }

    /**
     * Destructor
     */
    virtual ~FairRecoEventHeader();

  protected:
    /** Run Id */
    UInt_t fRunId;
    /** Identifier */
    Int_t fIdentifier;
    /** Event Time **/
    Double_t fEventTime;
    /** Event Time Error **/
    Double_t fEventTimeError;

    ClassDef(FairRecoEventHeader, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNINFO_H
#define FAIRRUNINFO_H

#include <Rtypes.h>       // for Double_t, Long_t, etc
#include <TObject.h>      // for TObject
#include <TSystem.h>      // for CpuInfo_t, MemInfo_t, etc
#include <TTimeStamp.h>   // for TTimeStamp
#include <vector>         // for vector

class TList;

class FairRunInfo : public TObject
{
  public:
    FairRunInfo();
    ~FairRunInfo();

    void StoreInfo();
    void WriteInfo();
    void Reset();

  private:
    TTimeStamp fTimeStamp;                 //!
    CpuInfo_t fCpuInfo;                    //!
    MemInfo_t fMemInfo;                    //!
    ProcInfo_t fProcInfo;                  //!
    std::vector<Double_t> fTimeDiff;       //!
    std::vector<Double_t> fTime;           //!
    std::vector<Long_t> fResidentMemory;   //!
    std::vector<Long_t> fVirtualMemory;    //!

    void CalculateTimeDifference();
    void PrintInfo();
    void GetInfo();
    void CreateAndFillHistograms(TList* histoList);
    void WriteHistosToFile(TList* histoList);

    FairRunInfo(const FairRunInfo&);
    FairRunInfo& operator=(const FairRunInfo&);

    ClassDef(FairRunInfo, 2);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRTIMESTAMP_H
#define FAIRTIMESTAMP_H

#include "FairMultiLinkedData_Interface.h"   // for FairMultiLinkedData

#include <Rtypes.h>   // for Double_t, etc
#include <iosfwd>     // for ostream
#include <iostream>   // for ostream, cout

class TObject;

/**
 * Base class for Time stamp information
 ** Aug. 2010
 **@author M.Al-Turany <m.al-turany@gsi.de>
 */
class FairTimeStamp : public FairMultiLinkedData_Interface
{
  public:
    /** Default constructor **/
    FairTimeStamp();
    /** Constructor with time **/
    FairTimeStamp(Double_t time);
    /** Constructor with time and time error **/
    FairTimeStamp(Double_t time, Double_t timeerror);

    /** Destructor **/
    virtual ~FairTimeStamp(){};
    /** Accessors **/
    Double_t GetTimeStamp() const { return fTimeStamp; }
    Double_t GetTimeStampError() const { return fTimeStampError; }
    /** Modifiers **/
    void SetTimeStamp(Double_t t) { fTimeStamp = t; }
    void SetTimeStampError(Double_t t) { fTimeStampError = t; }
    virtual Int_t Compare(const TObject* obj) const
    {
        if (this == obj) {
            return 0;
        }
        FairTimeStamp* tsobj = static_cast<FairTimeStamp*>(const_cast<TObject*>(obj));
        Double_t ts = tsobj->GetTimeStamp();
        Double_t tserror = tsobj->GetTimeStampError();
        if (fTimeStamp < ts) {
            return -1;
        } else if (fTimeStamp == ts && fTimeStampError < tserror) {
            return -1;
        } else if (fTimeStamp == ts && fTimeStampError == tserror) {
            return 0;
        } else {
            return 1;
        }
    }

    virtual std::ostream& PrintTimeInfo(std::ostream& out = std::cout) const;
    virtual Bool_t IsSortable() const { return kTRUE; };

    virtual bool equal(FairTimeStamp* data)
    {
        return (fTimeStamp == data->GetTimeStamp() && fTimeStampError == data->GetTimeStampError());
    }

    friend std::ostream& operator<<(std::ostream& out, const FairTimeStamp& link)
    {
        link.PrintTimeInfo(out);
        return out;
    }

    virtual bool operator<(const FairTimeStamp* rValue) const { return GetTimeStamp() < rValue->GetTimeStamp(); }

  protected:
    Double_t fTimeStamp;      /** Time of digit or Hit  [ns] */
    Double_t fTimeStampError; /** Error on time stamp */

    ClassDef(FairTimeStamp, 4);
};

// -----   Default constructor   -------------------------------------------
inline FairTimeStamp::FairTimeStamp()
    : FairMultiLinkedData_Interface()
    , fTimeStamp(-1)
    , fTimeStampError(-1)
{}

// -----   Standard constructor   ------------------------------------------
inline FairTimeStamp::FairTimeStamp(Double_t time)
    : FairMultiLinkedData_Interface()
    , fTimeStamp(time)
    , fTimeStampError(-1)
{}

inline FairTimeStamp::FairTimeStamp(Double_t time, Double_t timeerror)
    : FairMultiLinkedData_Interface()
    , fTimeStamp(time)
    , fTimeStampError(timeerror)
{}

#endif   // FAIRTIMESTAMP_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                     FairTrackParam header file                 -----
// -----                  Created 27/01/05  by V. Friese               -----
// -------------------------------------------------------------------------

/**  FairTrackParam.h
 *@author V.Friese <v.friese@gsi.de>
 **
 ** Parameters (x, y, tx, ty, q/p) of a track
 ** resulting from the track fit. The z coordinate is not a parameter.
 ** The 5x5 covariance matrix can be set and accessed by either an array
 ** of size 15, the TMatrixFSym class or elementwise. Note that TMatrixFSym
 ** should not be used when performance is an issue.
 ** The internal representation of the covariance matrix elements is
 ** an array of double.
 **/

#ifndef FAIRSTSTRACKPARAM
#define FAIRSTSTRACKPARAM 1

#include <Rtypes.h>           // for Double_t, Double32_t, Int_t, etc
#include <TMatrixFSymfwd.h>   // for TMatrixFSym
#include <TObject.h>          // for TObject
#include <TVector3.h>         // for TVector3

class FairTrackParam : public TObject
{
  public:
    /** Constructor **/
    FairTrackParam();

    /** Constructor with all variables **/
    FairTrackParam(Double_t x,
                   Double_t y,
                   Double_t z,
                   Double_t tx,
                   Double_t ty,
                   Double_t qp,
                   const TMatrixFSym& covMat);

    /** Copy constructor **/
    FairTrackParam(const FairTrackParam& param);

    /** Destructor **/
    virtual ~FairTrackParam();

    /** Output to screen **/
    void Print(Option_t* option = "") const;

    /** Accessors **/
    Double_t GetX() const { return fX; };
    Double_t GetY() const { return fY; };
    Double_t GetZ() const { return fZ; };
    Double_t GetTx() const { return fTx; };
    Double_t GetTy() const { return fTy; };
    Double_t GetQp() const { return fQp; };
    void Position(TVector3& pos) const { pos.SetXYZ(fX, fY, fZ); };
    void Momentum(TVector3& mom) const;
    void CovMatrix(Double_t cov[]) const;
    void CovMatrix(TMatrixFSym& covMat) const;
    Double_t GetCovariance(Int_t i, Int_t j) const;

    /** Modifiers **/
    void SetX(Double_t x) { fX = x; };
    void SetY(Double_t y) { fY = y; };
    void SetZ(Double_t z) { fZ = z; };
    void SetTx(Double_t tx) { fTx = tx; };
    void SetTy(Double_t ty) { fTy = ty; };
    void SetQp(Double_t qp) { fQp = qp; };
    void SetPosition(const TVector3& pos);
    void SetCovMatrix(Double_t cov[]);
    void SetCovMatrix(const TMatrixFSym& covMat);
    void SetCovariance(Int_t i, Int_t j, Double_t val);

    /** Assignment operator  **/
    FairTrackParam& operator=(const FairTrackParam& par);

  private:
    /** Position of track at given z [cm] **/
    Double32_t fX, fY, fZ;

    /** Direction of track tx = dx/dz; ty = dy/dz **/
    Double32_t fTx, fTy;

    /** Charge over momentum [1/GeV] **/
    Double32_t fQp;

    /** Covariance matrix for the variables x, y, tx, ty, q/p
     ** The 15 elements of the upper triangle of the symmetric matrix
     ** are stored in an array of floats. The sequence of the array is
     ** a[0,0..4], a[1,1..4], a[2,2..4], a[3,3..4], a[4,4].
     **/

    Double32_t fCovMatrix[15];

    ClassDef(FairTrackParam, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairField header file                     -----
// -----                Created 06/01/04  by M. Al-Turany              -----
// -----                Redesign 13/02/06  by V. Friese                -----
// -----                Redesign 04/08/06  by M. Al-Turany               -----
// -------------------------------------------------------------------------

/** FairField.h
 ** @author M.Al-Turany <m.al/turany@gsi.de>
 ** @author V.Friese <v.friese@gsi.de>
 ** @since 06.01.2004
 ** @version 1.0
 **
 ** Abstract base class for magnetic fields in FAIR
 ** Concrete field should implement the pure virtual methods
 ** GetBx, GetBy and GetBz and/or  GetBxyz
 **
 ** Note: Field values should be returned in kG (thanks to Geant3)
 **/

#ifndef FAIRFIELD_H
#define FAIRFIELD_H 1

#include "FairLogger.h"

#include <Rtypes.h>   // for Double_t, Bool_t, etc
#include <TVirtualMagField.h>

class FairField : public TVirtualMagField
{
  public:
    /** Default constructor **/
    FairField();

    /** Constructor with name and title **/
    FairField(const char* name, const char* title = "FAIR Magnetic Field");

    FairField& operator=(const FairField&) { return *this; }

    /** Destructor **/
    virtual ~FairField();

    /** Intialisation. E.g. read in the field map. If needed, to be
     ** implemented in the concrete class.
     **/
    virtual void Init(){};

    /** Test whether field type is Constant **/
    Bool_t IsConst();

    /** Test whether field typ is Map **/
    Bool_t IsMap();

    /** Field type ( 0=constant, 1=map, 2=map sym2, 3 = map sym3 ) **/
    Int_t GetType() const { return fType; }

    /** Get x component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBx([[maybe_unused]] Double_t x, [[maybe_unused]] Double_t y, [[maybe_unused]] Double_t z)
    {
        LOG(warn) << "FairField::GetBx Should be implemented in User class";
        return 0;
    }

    /** Get y component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBy([[maybe_unused]] Double_t x, [[maybe_unused]] Double_t y, [[maybe_unused]] Double_t z)
    {
        LOG(warn) << "FairField::GetBy Should be implemented in User class";
        return 0;
    }

    /** Get z component of magnetic field [kG]
     ** @param x,y,z    Position [cm]
     **/
    virtual Double_t GetBz([[maybe_unused]] Double_t x, [[maybe_unused]] Double_t y, [[maybe_unused]] Double_t z)
    {
        LOG(warn) << "FairField::GetBz Should be implemented in User class";
        return 0;
    }

    /** Get magnetic field. For use of Geant3
     ** @param point            Coordinates [cm]
     ** @param bField (return)  Field components [kG]
     **/
    virtual void GetFieldValue(const Double_t point[3], Double_t* bField);

    void Field(const Double_t point[3], Double_t* B) { GetFieldValue(point, B); }

    /** Screen output. To be implemented in the concrete class. **/
    virtual void Print(Option_t*) const { ; }
    virtual void GetBxyz(const Double_t[3], Double_t*)
    {
        LOG(warn) << "FairField::GetBxyz Should be implemented in User class";
    }

    /**Fill Paramater*/
    virtual void FillParContainer() { LOG(warn) << "FairField::FillParContainer Should be implemented in User class"; }

  protected:
    /** Field type. 1 = constant field, 2 = field map. **/
    Int_t fType;

  private:
    FairField(const FairField&);
    //    FairField& operator=(const FairField&);
    // TODO: Check why the htrack needs this

    ClassDef(FairField, 4);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairFieldFactory header file                  -----
// -----                Created 15/01/07  by M. Al-Turany              -----
// -------------------------------------------------------------------------

#ifndef FAIRFIELDFACTORY_H
#define FAIRFIELDFACTORY_H

#include <Rtypes.h>   // for FairFieldFactory::Class, etc

class FairField;

class FairFieldFactory
{
  public:
    static FairFieldFactory* Instance();
    FairFieldFactory();
    virtual ~FairFieldFactory();
    virtual FairField* createFairField() = 0;
    virtual void SetParm() {}

  protected:
    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] FairFieldFactory* fCreator;
    static FairFieldFactory* fgRinstance;

    ClassDef(FairFieldFactory, 1);

  private:
    FairFieldFactory(const FairFieldFactory& M);
    FairFieldFactory& operator=(const FairFieldFactory&) { return *this; }
};

#endif   // FAIRFIELDFACTORY_H
/********************************************************************************
 * Copyright (C) 2014-2023 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASECONTFACT_H
#define FAIRBASECONTFACT_H

#include "FairContFact.h"   // for FairContFact, etc

#include <Rtypes.h>   // for FairBaseContFact::Class, etc

class FairParSet;

class FairBaseContFact : public FairContFact
{
    /** Factory for all Base parameter containers */
  public:
    /**default ctor*/
    FairBaseContFact();
    /**default dtor*/
    ~FairBaseContFact() override {}
    /** Calls the constructor of the corresponding parameter container.
     * For an actual context, which is not an empty string and not the default context
     * of this container, the name is concatinated with the context. */
    FairParSet* createContainer(FairContainer*) override;
    ClassDefOverride(FairBaseContFact, 0);
};

#endif /* !FAIRBASECONTFACT_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRBASEPARSET_H
#define FAIRBASEPARSET_H

/**
 * Parameter class for run
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"   // for FairParGenericSet

#include <Rtypes.h>        // for Double_t, etc
#include <TGeoManager.h>   // IWYU pragma: keep needed by cint

class FairParamList;
class FairPrimaryGenerator;
class TObjArray;

class FairBaseParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
     * @param title:  Parameter set title
     * @param context:  Parameter set context
     */

    FairBaseParSet(const char* name = "FairBaseParSet",
                   const char* title = "Class for base parameter io",
                   const char* context = "BaseDefaultContext");
    /** dtor*/
    ~FairBaseParSet() override;
    /** clear*/
    void clear() override;
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
     */
    void putParams(FairParamList*) override;
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*) override;
    /**
     * Set the detector list used in the simulation
     * @param array: TObjArray of detector
     */
    void SetDetList(TObjArray* array) { fDetList = array; }
    /**
     * Set the Generator used in the simulation
     * @param gen: Primary generator used in simulation
     */
    void SetGen(FairPrimaryGenerator* gen) { fPriGen = gen; }
    /**
     * Set the beam momentum (if any) used in the simulation
     * @param BMom: Beam Momentum in GeV/c
     */
    void SetBeamMom(Double_t BMom) { fBeamMom = BMom; }
    /**
     * Set the list of parameter containers used in a run
     * @param array: TObjArray of containers
     */
    void SetContListStr(TObjArray* list) { fContNameList = list; }
    /**
     * Set the random seed used in a run
     * @param RndSeed: Random Seed
     */
    void SetRndSeed(UInt_t RndSeed) { fRandomSeed = RndSeed; }
    /**
     *  Get the detector list used in the simulation
     */
    TObjArray* GetDetList() { return fDetList; }
    /**
     *  Get the Primery generator used in the simulation
     */
    FairPrimaryGenerator* GetPriGen() { return fPriGen; }
    /**
     *  Get the Beam Momentum used in the simulation (GeV/c)
     */
    Double_t GetBeamMom() { return fBeamMom; }
    /**
     *  Get the parameter container list used in this run
     */
    TObjArray* GetContList() { return fContNameList; }
    /**
     *  Get the Random Seed used in this run
     */
    UInt_t GetRndSeed() { return fRandomSeed; }

  protected:
    /// Detectors used in the simulation
    TObjArray* fDetList;
    /// Generator used for simulation
    FairPrimaryGenerator* fPriGen;
    /// Beam momentum (GeV/c)
    Double_t fBeamMom;
    /// List of parameter container names in the RUN
    TObjArray* fContNameList;
    /// Random Seed from gRandom
    UInt_t fRandomSeed;

    ClassDefOverride(FairBaseParSet, 6);

  private:
    FairBaseParSet(const FairBaseParSet& L);
    FairBaseParSet& operator=(const FairBaseParSet&) { return *this; }
};

#endif /* !FAIRBASEPARSET_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETECTOR_H
#define FAIRDETECTOR_H

#include "FairModule.h"   // for FairModule

#include <Rtypes.h>   // for Int_t, Bool_t, etc

class FairLogger;
class FairVolume;
class TClonesArray;

/**
 * Base class for constructing detecors
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairDetector : public FairModule
{
  public:
    /**
      constructor
      Name :  Detector Name
      Active: kTRUE for active detectors  (ProcessHits() will be called)
              kFALSE for inactive detectors
    */
    FairDetector(const char* Name, Bool_t Active, Int_t DetId = 0);
    /**
      default constructor
    */
    FairDetector();
    /**
      destructor
    */
    virtual ~FairDetector();
    /**
      Initialization of the detector is done here
    */
    virtual void Initialize();
    /**
      this method is called for each step during simulation (see FairMCApplication::Stepping())
    */
    virtual Bool_t ProcessHits(FairVolume* v = 0) = 0;
    /**
      this is called at the end of an event after the call to tree fill in the FairRootManager
    */
    virtual void EndOfEvent() {}
    /**
      Registers the produced collections in FAIRRootManager.
    */
    virtual void Register() = 0;

    /**
     Gets the produced collections
    */
    virtual TClonesArray* GetCollection(Int_t iColl) const = 0;
    /**
      has to be called after each event to reset the containers
    */
    virtual void Reset() = 0;

    virtual void CopyClones(TClonesArray*, TClonesArray*, Int_t) {}
    /**
     User actions after finishing of a primary track
    */
    virtual void FinishPrimary() {}
    /**
     Finish MC Run
    */
    virtual void FinishRun() {}
    /**
     User actions at beginning of a primary track
    */
    virtual void BeginPrimary() {}
    /**
     User actions after finishing of each track
    */
    virtual void PostTrack() {}
    /**
     User actions at beginning of each track
    */
    virtual void PreTrack() {}
    /**
     User actions at beginning of event
    */
    virtual void BeginEvent() {}
    /**
     this is called at the end of an event before the call to tree fill in the FairRootManager
    */
    virtual void FinishEvent() {}

    void SaveGeoParams();
    Int_t GetDetId() { return fDetId; }

  protected:
    /** Copy constructor */
    FairDetector(const FairDetector&);
    /** Assignment operator */
    FairDetector& operator=(const FairDetector&);

    void DefineSensitiveVolumes();

    Int_t fDetId;          // Detector Id has to be set from ctr.
    FairLogger* fLogger;   //! /// FairLogger

    ClassDef(FairDetector, 1);
};
#endif   // FAIRDETECTOR_H
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairGeaneApplication header file                   -----
// -----            Created 10/11/10  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_GEANE_APPLICATION_H
#define FAIR_GEANE_APPLICATION_H

#include <Rtypes.h>                  // for Bool_t, etc
#include <TLorentzVector.h>          // for TLorentzVector
#include <TVirtualMCApplication.h>   // for TVirtualMCApplication

class FairField;

/**
 * The Main Application for GEANE
 * @author M. Al-Turany
 * @version 0.1
 * @since 10.11.10
 */

class FairGeaneApplication : public TVirtualMCApplication
{
  public:
    /** default constructor */
    FairGeaneApplication();
    /** Special constructor, used for initializing G3 for Geane track propagation
     *@param Debug    true to print step info*/
    FairGeaneApplication(Bool_t Debug);
    /** default destructor */
    ~FairGeaneApplication() override;
    /** Return Field used in simulation*/
    FairField* GetField() { return fxField; }
    /** Initialize MC engine */
    void InitMC(const char* setup, const char* cuts);
    /**
     * Set the magnetic field for simulation or Geane
     * @param field: magnetic field
     */
    void SetField(FairField* field);
    /** Define action at each step, dispatch the action to the corresponding detectors */
    void GeaneStepping() override;   // MC Application
    void ConstructGeometry() override;
    /**
     * Singelton instance
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] static FairGeaneApplication* Instance()
    {
        return static_cast<FairGeaneApplication*>(TVirtualMCApplication::Instance());
    }

    /**pure virtual functions that hasve to be implimented */

    void InitGeometry() override { ; }
    void GeneratePrimaries() override { ; }
    void BeginEvent() override { ; }
    void BeginPrimary() override { ; }
    void PreTrack() override { ; }
    void PostTrack() override { ; }
    void FinishPrimary() override { ; }
    void FinishEvent() override { ; }
    void Stepping() override { ; }
    void StopRun() { ; }

  private:
    // data members
    /**Magnetic Field Pointer*/
    FairField* fxField;   //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t fMcVersion;   // mc Version
    /** Debug flag*/
    Bool_t fDebug;            //!
    TLorentzVector fTrkPos;   //!

    // Interface to MonteCarlo application
    ClassDefOverride(FairGeaneApplication, 1);

  private:
    FairGeaneApplication(const FairGeaneApplication&);
    FairGeaneApplication& operator=(const FairGeaneApplication&);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairGenerator header file                   -----
// -----          Created 09/06/04  by D. Bertini / V. Friese          -----
// -------------------------------------------------------------------------

/** FairGenerator.h
 *@author D.Bertini <d.bertini@gsi.de>
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairGenerator is the abtract base class for the generators used to
generate input for the transport simulation.Each concrete generator class
derived from this one must implement the abtract method ReadEvent,
which has to use the method FairPrimaryGenerator::AddTrack.
**/

#ifndef FAIRGENERATOR_H
#define FAIRGENERATOR_H

#include <Rtypes.h>   // for Bool_t, etc
#include <TNamed.h>   // for TNamed

class FairPrimaryGenerator;

class FairGenerator : public TNamed
{
  public:
    /** Default constructor. **/
    FairGenerator();

    /** Constructor with name and title **/
    FairGenerator(const char* name, const char* title = "FAIR Generator");

    /** Destructor. **/
    virtual ~FairGenerator();

    /** Abstract method ReadEvent must be implemented by any derived class.
        It has to handle the generation of input tracks (reading from input
        file) and the handing of the tracks to the FairPrimaryGenerator. I
        t is called from FairMCApplication.
        *@param pStack The stack
        *@return kTRUE if successful, kFALSE if not
    **/
    virtual Bool_t ReadEvent(FairPrimaryGenerator* primGen) = 0;

    /**Initialize the generator if needed */
    virtual Bool_t Init() { return kTRUE; }

    /**Finalize the generator if needed */
    virtual void Finish() { return; }

    /** Clone this object (used in MT mode only) */
    virtual FairGenerator* CloneGenerator() const;

  protected:
    /** Copy constructor */
    FairGenerator(const FairGenerator&);
    /** Assignment operator */
    FairGenerator& operator=(const FairGenerator&);

    ClassDef(FairGenerator, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairGenericStack header file            -----
// -----           Created 10/08/04  by D. Bertini                     -----
// -------------------------------------------------------------------------

/** FairGenericStack.h
 *@author D.Bertini <d.bertini@gsi.de>
 * Generic MC stack class
 **/

#ifndef FAIRGENERICSTACK_H
#define FAIRGENERICSTACK_H

#include <Rtypes.h>   // for Double_t, Int_t, etc
#include <TClonesArray.h>
#include <TMCProcess.h>        // for TMCProcess
#include <TVirtualMCStack.h>   // for TVirtualMCStack
#include <map>
#include <tuple>

class FairLogger;
class TParticle;
class TRefArray;
class TIterator;

class FairGenericStack : public TVirtualMCStack
{
  public:
    /** Default constructor  **/
    FairGenericStack();

    /** Destructor with estimated array size  **/
    FairGenericStack(Int_t size);

    /** Destructor  **/
    virtual ~FairGenericStack();

    /** Virtual method PushTrack.
     ** Add a TParticle to the stack.
     ** This function has an extra argument wrt to the function defined in the base class.
     *@param toBeDone         Flag for tracking
     *@param parentID         Index of mother particle
     *@param pdgCode          Particle type (PDG encoding)
     *@param px,py,pz         Momentum components at start vertex [GeV]
     *@param e                Total energy at start vertex [GeV]
     *@param vx,vy,vz         Coordinates of start vertex [cm]
     *@param time             Start time of track [s]
     *@param polx,poly,polz   Polarisation vector
     *@param proc             Production mechanism (VMC encoding)
     *@param ntr              Track number (filled by the stack)
     *@param weight           Particle weight
     *@param is               Generation status code (whatever that means)
     *@param secondparentID   used fot the index of mother of primery in the list
     **/
    virtual void PushTrack(Int_t toBeDone,
                           Int_t parentID,
                           Int_t pdgCode,
                           Double_t px,
                           Double_t py,
                           Double_t pz,
                           Double_t e,
                           Double_t vx,
                           Double_t vy,
                           Double_t vz,
                           Double_t time,
                           Double_t polx,
                           Double_t poly,
                           Double_t polz,
                           TMCProcess proc,
                           Int_t& ntr,
                           Double_t weight,
                           Int_t is,
                           Int_t secondparentID) = 0;

    /** Fill the MCTrack output array, applying filter criteria **/
    virtual void FillTrackArray() {}

    /** Update the track index in the MCTracks and MCPoints **/
    virtual void UpdateTrackIndex(TRefArray* /* detArray=0 */) {}

    /** Set the list of detectors to be used for filltering the stack*/
    void SetDetArrayList(TRefArray* detArray);

    /** Allow a stack to perform a clean-up after a primary particle is finished **/
    virtual void FinishPrimary() {}

    /** Resets arrays and stack and deletes particles and tracks **/
    virtual void Reset() {}

    /** Register the MCTrack array to the Root Manager  **/
    virtual void Register() {}

    virtual TClonesArray* GetListOfParticles() { return 0; }
    virtual void SetParticleArray(__attribute__((unused)) TClonesArray* partArray) {}
    virtual void SetParticleArray(__attribute__((unused)) TClonesArray* partArray,
                                  __attribute__((unused)) Int_t partFrom,
                                  __attribute__((unused)) Int_t partTo)
    {}

    /** Clone this object (used in MT mode only) */
    virtual FairGenericStack* CloneStack() const;

    /** Fast simulation function to move particle to different position.
        In Geant3 it stops the current trajectory, and starts it again in the position given by the user.
        In Geant4 the FastSimulationModel with take over.
        Later, the points are reindexed and the thus created tracks are not stored in the output.
     *@param xx,yy,zz    new position    of the particle
     *@param tt          new proper time of the particle
     *@param px,py,pz    new momentum    of the particle
     *@param en          new energy      of the particle
     **/
    virtual void FastSimMoveParticleTo(Double_t xx,
                                       Double_t yy,
                                       Double_t zz,
                                       Double_t tt,
                                       Double_t px,
                                       Double_t py,
                                       Double_t pz,
                                       Double_t en);
    /** Fast simulation function to stop original particle. **/
    virtual void FastSimStopParticle();
    /** Fast simulation function to generate secondaries.
     *@param xx,yy,zz    position    of the particle
     *@param tt          proper time of the particle
     *@param px,py,pz    momentum    of the particle
     *@param en          energy      of the particle
     **/
    virtual void FastSimPushSecondary(Int_t parentID,
                                      Int_t pdgCode,
                                      Double_t xx,
                                      Double_t yy,
                                      Double_t zz,
                                      Double_t tt,
                                      Double_t px,
                                      Double_t py,
                                      Double_t pz,
                                      Double_t en,
                                      Double_t polx,
                                      Double_t poly,
                                      Double_t polz,
                                      TMCProcess proc,
                                      Double_t weight,
                                      Int_t is);
    /** Allow FairFastSim the retrieval of moved particle position, p1 and p2 to get secondaries **/
    virtual std::tuple<Int_t, Int_t, Int_t> FastSimGetMovedIndex()
    {
        return std::make_tuple(fFSMovedIndex, fFSFirstSecondary, fFSNofSecondaries);
    }
    virtual void FastSimClearMovedIndex()
    {
        fFSMovedIndex = -2;
        fFSFirstSecondary = -2;
        fFSNofSecondaries = 0;
    }

    template<typename T>
    void FastSimUpdateTrackIndex(T* point, Int_t& iTrack);

  protected:
    /** Copy constructor */
    FairGenericStack(const FairGenericStack&);
    /** Assignment operator */
    FairGenericStack& operator=(const FairGenericStack&);

    /** Fair Logger */
    FairLogger* fLogger;   //!

    /** List of detectors registering hits in the simulation */
    TRefArray* fDetList;   //!

    /** Iterator for the detector list*/
    TIterator* fDetIter;

    /**Verbosity level*/
    Int_t fVerbose;

    /** FastSimulation: STL map from new track index to original track index  **/
    std::map<Int_t, Int_t> fFSTrackMap;              //!
    std::map<Int_t, Int_t>::iterator fFSTrackIter;   //!
    Int_t fFSMovedIndex;                             //!
    Int_t fFSFirstSecondary;                         //!
    Int_t fFSNofSecondaries;                         //!

    ClassDef(FairGenericStack, 1);
};

template<typename T>
void FairGenericStack::FastSimUpdateTrackIndex(T* point, Int_t& iTrack)
{
    fFSTrackIter = fFSTrackMap.find(iTrack);   // check if point created by FastSimulation
    if (fFSTrackIter != fFSTrackMap.end()) {   // indeed the point has been created by the FastSimulation mechanism
        iTrack = fFSTrackIter->second;
        point->SetTrackID(iTrack);   // set proper TrackID
    }
}

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairGenericVMCConfig header file                -----
// -----            Created 2019.02.19 by R. Karabowicz                -----
// -------------------------------------------------------------------------

#include <string>   // for string

#ifndef FAIR_GENERIC_VMC_CONFIG_H
#define FAIR_GENERIC_VMC_CONFIG_H

class FairGenericVMCConfig
{
  public:
    FairGenericVMCConfig();
    virtual ~FairGenericVMCConfig();

    virtual void Setup(const char* mcEngine);
    virtual void SetupPostInit(const char* mcEngine);

    virtual void UsePostInitConfig(bool useC = true, const char* stringC = "g4ConfigPostInit.C")
    {
        fPostInitFlag = useC;
        fPostInitName = stringC;
    }

  protected:
    bool fPostInitFlag;
    std::string fPostInitName;
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairGeoParSet_H
#define FairGeoParSet_H

/**
 * Parameter class for Geometry stuff
 * @author M. Al-Turany
 * @version 1
 * @since 12.10.04
 */
#include "FairParGenericSet.h"   // for FairParGenericSet

#include <Rtypes.h>        // for Double_t, etc
#include <TGeoManager.h>   // IWYU pragma: keep needed by cint

class FairParamList;
class TObjArray;

class FairGeoParSet : public FairParGenericSet
{
  public:
    /**
     * constructor
     * @param name :  Parameter set name
     * @param title:  Parameter set title
     * @param context:  Parameter set context
     */

    FairGeoParSet(const char* name = "FairGeoParSet",
                  const char* title = "Class for base parameter io",
                  const char* context = "BaseDefaultContext");
    /** dtor*/
    ~FairGeoParSet() override;
    /** clear*/
    void clear() override;
    /**
     * Fills all persistent data members into the list for write.
     * @param FairParamList : Parameter list to be filled
     */
    void putParams(FairParamList*) override;
    /**
     * Fills all persistent data members from the list after reading. The function
     * returns false, when a data member is not in the list.
     * @param FairParamList : Parameter list to be filled
     */

    Bool_t getParams(FairParamList*) override;
    /**
     * Set the Geometry node list used in the simulation
     * @param array: TObjArray of Geometry nodes
     */
    void SetGeoNodes(TObjArray* array) { fGeoNodes = array; }
    /**
     * Set the Geometry (TGeoManager) used in the simulation
     * @param Geom: TGeoManager of the full geometry
     */
    void SetGeometry(TGeoManager* Geom) { fGeom = Geom; }
    /**
     *  Get the Geometry Nodes list used in the simulation
     */
    TObjArray* GetGeoNodes() { return fGeoNodes; }
    /**
     *  Get the geometry (TGeoManager) used in the simulation
     */
    TGeoManager* GetGeometry() { return fGeom; }

  protected:
    /// List of FairGeoNodes for sensitive volumes
    TObjArray* fGeoNodes;   //!
    /// Full Geometry
    TGeoManager* fGeom;
    ClassDefOverride(FairGeoParSet, 1);

  private:
    FairGeoParSet(const FairGeoParSet& L);
    FairGeoParSet& operator=(const FairGeoParSet&) { return *this; }
};

#endif /* !FairGeoParSet_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                       FairIon header file                      -----
// -----          Created 27/08/04  by V. Friese / D.Bertini           -----
// -------------------------------------------------------------------------

/** FairIon.h
 *@author V.Friese <v.friese@gsi.de>
 *@author D.Bertini <d.bertini@gsi.de>
 **
 ** A class for the user definition of an ion. It will be instantiated
 ** from the constructor of the FairIonGenerator.
 **/

#ifndef FAIRION_H
#define FAIRION_H

#include <Rtypes.h>   // for Int_t, Double_t, etc
#include <TNamed.h>   // for TNamed

class FairLogger;

class FairIon : public TNamed
{
  public:
    /** Default constructor **/
    FairIon();

    /** Standard constructor
     *@param name  name
     *@param z     atomic number
     *@param a     atomic mass
     *@param q     electric charge
     *@param e     excitation energy
     *@param m     mass [GeV]
     ** If mass is not given, it will be set to a times the proton mass.
     **/

    FairIon(const char* name, Int_t z, Int_t a, Int_t q, Double_t e = 0., Double_t m = 0.);
    void SetParams(const char* name, Int_t z, Int_t a, Int_t q, Double_t e = 0., Double_t m = 0.)
    {
        SetName(name);
        fZ = z;
        fA = a;
        fQ = q;
        fExcEnergy = e;
        fMass = m;
    }
    /** Destructor **/
    virtual ~FairIon();

    /** Accessors **/
    /**
     * Return the atomic number
     */
    Int_t GetZ() const { return fZ; }
    /**
     * Return the atomic mass
     */
    Int_t GetA() const { return fA; }
    /**
     * Return the charge
     */
    Int_t GetQ() const { return fQ; }
    /**
     * Return the  excitation energy
     */
    Double_t GetExcEnergy() const { return fExcEnergy; }
    /**
     * Return the mass in GeV
     */
    Double_t GetMass() const { return fMass; }

    /** Modifiers **/
    /**
     * Set the  excitation energy
     */
    void SetExcEnergy(Double_t eExc) { fExcEnergy = eExc; }
    /**
     * Set the atomic mass, use SetMass to set the mass of the ion
     */
    void SetA(Int_t a) { fA = a; }
    /**
     * Set the mass in GeV
     */
    void SetMass(Double_t mass) { fMass = mass; }

  private:
    static Int_t fgNIon;         //! /// Number of ions instantiated. One per generator.
    Int_t fZ;                    /// Atomic number
    Int_t fA;                    /// Atomic mass
    Int_t fQ;                    /// Electric charge
    Double_t fExcEnergy;         /// Excitation energy [GeV]
    Double_t fMass;              /// Mass [GeV]
    FairLogger* fLogger;         //! /// FairLogger

    FairIon(const FairIon&);
    FairIon& operator=(const FairIon&);

    ClassDef(FairIon, 2);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----               FairMCApplication header file                   -----
// -----            Created 06/01/04  by M. Al-Turany                  -----
// -------------------------------------------------------------------------

#ifndef FAIR_MC_APPLICATION_H
#define FAIR_MC_APPLICATION_H

#include "FairRadGridManager.h"
#include "FairRunInfo.h"   // for FairRunInfo

#include <Rtypes.h>                  // for Int_t, Bool_t, Double_t, etc
#include <TLorentzVector.h>          // for TLorentzVector
#include <TString.h>                 // for TString
#include <TVirtualMCApplication.h>   // for TVirtualMCApplication
#include <list>                      // for list
#include <map>                       // for map, multimap, etc
#include <memory>                    // for std::unique_ptr

class FairDetector;
class FairEventHeader;
class FairField;
class FairGenericStack;
class FairMCEventHeader;
class FairPrimaryGenerator;
class FairRadLenManager;
class FairRadMapManager;
class FairRootManager;
class FairTask;
class FairTrajFilter;
class FairVolume;
class FairRunSim;
class TChain;
class TIterator;
class TObjArray;
class TRefArray;
class TTask;
class TVirtualMC;

enum class FairMCApplicationState { kUnknownState, kConstructGeometry, kInitGeometry };

/**
 * The Main Application ( Interface to MonteCarlo application )
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairMCApplication : public TVirtualMCApplication
{
  public:
    /** Standard constructor
     *@param name      name
     *@param title     title
     *@param ModList  a TObjArray containing all detectors and modules used in this simulation
     *@param MatName  material file name
     */
    FairMCApplication(const char* name, const char* title, TObjArray* ModList, const char* MatName);
    /** default constructor
     */
    FairMCApplication();

    FairMCApplication(const FairMCApplication&) = delete;
    FairMCApplication& operator=(const FairMCApplication&) = delete;
    FairMCApplication(FairMCApplication&&) = delete;
    FairMCApplication& operator=(FairMCApplication&&) = delete;

    /** default destructor
     */
    ~FairMCApplication() override;
    /** Singelton instance
     */
    static FairMCApplication* Instance();
    virtual void AddDecayModes();
    /**  Add user defined particles (optional) */
    void AddParticles() override;   // MC Application
    /** Add user defined ions (optional)
        Called by TVirtualMC.
        TGeant3 calls AddIons() first, then InitGeometry().
        TGeant4 calls InitGeometry() first, then AddIons().
        This function also initializes event generators.*/
    void AddIons() override;   // MC Application
    /**
     *Add user defined Tasks to be executed after each event (optional)
     * @param fTask: Task that has to be excuted during simulation
     */
    void AddTask(TTask* fTask);
    /** Define actions at the beginning of the event */
    void BeginEvent() override;   // MC Application
    /** Define actions at the beginning of primary track */
    void BeginPrimary() override;   // MC Application
    /** Construct user geometry */
    void ConstructGeometry() override;   // MC Application
    /** Align or misalign geometry before actual run       */
    Bool_t MisalignGeometry() override;
    /** Define parameters for optical processes (optional) */
    void ConstructOpGeometry() override;   // MC Application
    /** Define actions at the end of event */
    void FinishEvent() override;   // MC Application
    /** Define actions at the end of primary track */
    void FinishPrimary() override;   // MC Application
    /** Define actions at the end of run */
    void FinishRun();
    /** Generate primary particles */
    void GeneratePrimaries() override;   // MC Application
    /** Return detector by name  */
    FairDetector* GetDetector(const char* DetName);
    /** Return Field used in simulation*/
    FairField* GetField() { return fxField; }
    /**Return primary generator*/
    FairPrimaryGenerator* GetGenerator();
    /**Return list of tasks*/
    TTask* GetListOfTasks();
    FairGenericStack* GetStack();
    TChain* GetChain();
    /** Initialize geometry
        Called by TVirtualMC.
        TGeant3 calls AddIons() first, then InitGeometry().
        TGeant4 calls InitGeometry() first, then AddIons().
        This function also registers detectors.*/
    void InitGeometry() override;   // MC Application
    /** Initialize MC engine */
    void InitMC(const char* setup, const char* cuts);
    /** Initialize Tasks if any*/
    void InitTasks();
    /**Define actions at the end of each track */
    void PostTrack() override;   // MC Application
    /** Define actions at the beginning of each track*/
    void PreTrack() override;   // MC Application

    /** Clone for worker (used in MT mode only) */
    TVirtualMCApplication* CloneForWorker() const override;

    /** Init application on worker (used in MT mode only) */
    void InitOnWorker() override;

    /** Finish run on worker (used in MT mode only) */
    void FinishRunOnWorker() override;

    /** Run the MC engine
     * @param nofEvents : number of events to simulate
     */
    void RunMC(Int_t nofEvents);
    /**
     * Set the magnetic field for simulation
     * @param field: magnetic field
     */
    void SetField(FairField* field);
    /**
     * Set the event generator  for simulation
     * @param fxGenerator: Event generator(s)
     */
    void SetGenerator(FairPrimaryGenerator* fxGenerator);
    /**
     * Set the parameter containers needed by Tasks(if any)
     */
    void SetParTask();
    /**
     * Switch for using Pythia as external decayer
     * @param decayer: if TRUE pythia will decay particles specifid in the Decay Config macro (see
     * SetPythiaDecayerConfig)
     */
    void SetPythiaDecayer(Bool_t decayer) { fPythiaDecayer = decayer; }
    /**
     * set the decay configuration macro to be used by Pythia
     */
    void SetPythiaDecayerConfig(const TString decayerConf) { fPythiaDecayerConfig = decayerConf; }
    /**
     * Switch for using the radiation length manager
     */
    void SetRadiationLengthReg(Bool_t RadLen);
    /**
     * Switch for using the radiation map manager
     */
    void SetRadiationMapReg(Bool_t RadMap);
    /**
     * Switch for debuging the tracking
     */
    void SetTrackingDebugMode(Bool_t set) { fDebug = set; }
    /**
     * Switch for using 2 or 3 body phase-space decay
     * @param  decay: if TRUE 2/3 body phase space decay will be used for particle specified in the User Decay Config
     * macro (see SetUserDecayConfig)
     */
    void SetUserDecay(Bool_t decay) { fUserDecay = decay; }
    /**
     * set the decay configuration macro to be used by user decay
     */
    void SetUserDecayConfig(const TString decayerConf) { fUserDecayConfig = decayerConf; }
    /** Define action at each step, dispatch the action to the corresponding detectors */
    void Stepping() override;   // MC Application
    /** Stop the run*/
    virtual void StopRun();
    /** Stop the run*/
    virtual void StopMCRun();
    /**Define maximum radius for tracking (optional) */
    Double_t TrackingRmax() const override;   // MC Application
    /** Define maximum z for tracking (optional) */
    Double_t TrackingZmax() const override;   // MC Application

    void AddMeshList(TObjArray* meshList);

    /**
     * Set if the current event should be written to the output file.
     * The default value which is set back after each event is to store
     * the event.
     */
    void SetSaveCurrentEvent(Bool_t set) { fSaveCurrentEvent = set; }

    /**
     * Get the current application state.
     */
    FairMCApplicationState GetState() const { return fState; }

    /**
     * Return non-owning pointer to FairRadGridManager
     */
    auto GetRadGridMan() { return fRadGridMan.get(); }

  private:
    // methods
    Int_t GetIonPdg(Int_t z, Int_t a) const;

    void UndoGeometryModifications();

  protected:
    // data members
    /**
     * \brief Main instance
     *
     * Only set for instances created by \ref CloneForWorker
     * and points to the instance from which the clone was
     * created
     */
    const FairMCApplication* fParent{nullptr};   //!
    /**List of active detector */
    TRefArray* fActiveDetectors;
    /**List of FairTask*/
    FairTask* fFairTaskList;   //!
    /**detector list (Passive and Active)*/
    TRefArray* fDetectors;
    /**Iterator for Module list*/
    TIterator* fModIter;   //!
    /**Module list in simulation*/
    TObjArray* fModules;
    /**Number of sensetive volumes in simulation session*/
    Int_t fNoSenVolumes;   //!
    /**flag for using Pythia as external decayer */
    Bool_t fPythiaDecayer;
    /** Pythia decay config macro*/
    TString fPythiaDecayerConfig;   //!
    /** Simulation Stack  */
    FairGenericStack* fStack;   //!
    /**Pointer to thr I/O Manager */
    FairRootManager* fRootManager;   //!
    /**List of sensetive volumes in all detectors*/
    TRefArray* fSenVolumes;   //!
    /**Magnetic Field Pointer*/
    FairField* fxField;   //
    /**Primary generator*/
    FairPrimaryGenerator* fEvGen;   //
    /**MC Engine 1= Geant3, 2 = Geant4*/
    Int_t fMcVersion;   // mc Version
    /** Track visualization manager */
    FairTrajFilter* fTrajFilter;   //!
    /**Flag for accepted tracks for visualization*/
    Bool_t fTrajAccepted;   //!
    /**Flag for using user decay*/
    Bool_t fUserDecay;
    /**User decay config macro*/
    TString fUserDecayConfig;   //!
    /** Debug flag*/
    Bool_t fDebug;   //!
    /**dispatcher internal use */
    std::multimap<Int_t, FairVolume*> fVolMap;   //!
    /** Track position*/
    /**dispatcher internal use RadLeng*/
    std::map<Int_t, Int_t> fModVolMap;   //!
    TLorentzVector fTrkPos;              //!
    /** Flag for Radiation length register mode  */
    Bool_t fRadLength;   //!

    /**Radiation length Manager*/
    FairRadLenManager* fRadLenMan;   //!
    /** Flag for Radiation map register mode  */
    Bool_t fRadMap;   //!
    /**Radiation Map Manager*/
    FairRadMapManager* fRadMapMan;   //!
    /**Radiation map Grid Manager*/
    std::unique_ptr<FairRadGridManager> fRadGridMan{};   //!

    FairEventHeader* fEventHeader;   //!

    FairMCEventHeader* fMCEventHeader;   //!
    /** list of senstive detectors used in the simuation session*/
    std::list<FairDetector*> listActiveDetectors;   //!
    /** list of all detectors used in the simuation session*/
    std::list<FairDetector*> listDetectors;   //!
    /** Pointer to the current MC engine //!
     */
    TVirtualMC* fMC;

    FairRunSim* fRun{nullptr};   //!

    /** Flag if the current event should be saved */
    Bool_t fSaveCurrentEvent;

    /** Current state */
    FairMCApplicationState fState;   //!

    ClassDefOverride(FairMCApplication, 5);

  private:
    /** Private special copy constructor, needed for CloneForWorker */
    FairMCApplication(const FairMCApplication&, std::unique_ptr<FairRunSim>);

    FairRunInfo fRunInfo;   //!
    Bool_t fGeometryIsInitialized;

    /**
     * Clean up the FairRunSim created in CloneForWorker
     */
    std::unique_ptr<FairRunSim> fWorkerRunSim;   //!
};

// inline functions

inline FairMCApplication* FairMCApplication::Instance()
{
    return static_cast<FairMCApplication*>(TVirtualMCApplication::Instance());
}

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRMODULE_H
#define FAIRMODULE_H

#include "FairGeoInterface.h"   // for FairGeoInterface
#include "FairGeoLoader.h"      // for FairGeoLoader
#include "FairGeoNode.h"        // for FairGeoNode
#include "FairGeoVolume.h"      // for FairGeoVolume
#include "FairLogger.h"
#include "FairRun.h"         // for FairRun
#include "FairRuntimeDb.h"   // for FairRuntimeDb

#include <Rtypes.h>      // for Bool_t, Int_t, etc
#include <TList.h>       // for TList (ptr only), TListIter
#include <TNamed.h>      // for TNamed
#include <TObjArray.h>   // for TObjArray
#include <TString.h>     // for TString, operator!=
#include <string>        // for string

class FairVolumeList;
class FairVolume;
class TArrayI;
class TGeoMatrix;
class TGeoNode;
class TGeoVolume;
class TRefArray;
class TVirtualMC;

/**
 * Base class for constructing all detecors and passive volumes
 * @author M. Al-Turany, Denis Bertini
 * @version 1.0
 * @since 01.04.08 M.Al-Turany
 * Add methods to construct geometry via ROOT files
 * Add some documentation
 *
 * Changelog: 29.02.2012 [O.Merle] Fixed missing material assignment for top volume.
 *                                 ... and please - add some documentation to your code.
 */
class FairModule : public TNamed
{
  public:
    /**default ctor*/
    FairModule();
    /**Standard ctor*/
    FairModule(const char* Name, const char* title, Bool_t Active = kFALSE);
    /**default dtor*/
    ~FairModule() override;
    /**Print method should be implemented in detector or module*/
    void Print(Option_t*) const override { ; }
    /**Set the geometry file name o be used*/
    virtual void SetGeometryFileName(TString fname, TString geoVer = "0");
    /**Get the Geometry file name*/
    virtual TString GetGeometryFileName() { return fgeoName; }
    /**Get the geometry file version if used*/
    virtual TString GetGeometryFileVer() { return fgeoVer; }
    /**method called from the MC application to construct the geometry, has to be implimented by user*/
    virtual void ConstructGeometry();
    /**method called from the MC application to set optical geometry properties*/
    virtual void ConstructOpGeometry();
    /**construct geometry from root files (TGeo)*/
    virtual void ConstructRootGeometry(TGeoMatrix* shiftM = nullptr);
    /**construct geometry from standard ASSCII files (Hades Format)*/
    virtual void ConstructASCIIGeometry();
    /**
     * Modify the geometry for the simulation run using methods of the Root geometry package
     * \deprecated Deprecated pre-v18.8, will be removed in v20.
     */
    [[deprecated("Use FairAlignmentHandler instead, see Tutorial4 for examples")]] virtual void ModifyGeometry()
    {
        LOG(warn) << "This function is deprecated. Use FairAlignmentHandler instead, see Tutorial4 for examples.";
    }
    virtual void RegisterAlignmentMatrices() { ; }

    /**construct geometry from GDML files*/
    virtual void ConstructGDMLGeometry(__attribute__((unused)) TGeoMatrix* posrot);
    /** custom settings of processes and cuts for media to be forwarded to the
     ** detector simulation */
    virtual void SetSpecialPhysicsCuts() { ; }
    /** Clone this object (used in MT mode only)*/
    virtual FairModule* CloneModule() const;
    /** Init worker run (used in MT mode only) */
    virtual void BeginWorkerRun() const { ; }
    /** Finish worker run (used in MT mode only) */
    virtual void FinishWorkerRun() const { ; }

    /** @deprecated template function to construct geometry. to be used in derived classes.
     * The first and the third argument are meaningless, just pass nullptr */
    template<class T, class U>
    [[deprecated("Broken signature, use ConstructASCIIGeometry(TString) instead")]] void
        ConstructASCIIGeometry(T*, TString containerName = "", U* = nullptr);
    /** Helper function to construct geometry. */
    template<class T, class U>
    void ConstructASCIIGeometry(TString containerName = "");

    /**Set the sensitivity flag for volumes, called from ConstructASCIIRootGeometry(), and has to be implimented for
     * detectors which use ConstructASCIIRootGeometry() to build the geometry */
    virtual Bool_t IsSensitive(const std::string& name);
    /**The function below is depracated, please change to the new method above */
    virtual Bool_t CheckIfSensitive(__attribute__((unused)) std::string name) __attribute__((
        deprecated("The method CheckIfSensitive is deprecated. Implement IsSensitive in the detector classes.")))
    {
        return kFALSE;
    }
    /**called from ConstructRootGeometry()*/
    virtual void ExpandNode(TGeoNode* Node);
    /**called from ConstructGDMLGeometry()*/
    virtual void ExpandNodeForGDML(__attribute__((unused)) TGeoNode* curNode);
    /**return the MC id of a volume named vname*/
    virtual Int_t getVolId(const TString&) const { return 0; }
    /**return the detector/Module id (which was set in the sim macro for the detector)*/
    Int_t GetModId() { return fModId; }
    /**Set the verbose level in this detector*/
    void SetVerboseLevel(Int_t level) { fVerboseLevel = level; }
    /**return the detector status */
    Bool_t IsActive() { return fActive; }
    /**set the detector/module id*/
    void SetModId(Int_t id) { fModId = id; }
    /** Set the name of the mother volume to which a new geometry is added.
     ** This function is needed for geometries which are defined as ROOT geometry manager.
     **/
    void SetMotherVolume(TString volName) { fMotherVolumeName = volName; }
    /**called from ConstuctASCIIGeometry*/
    void ProcessNodes(TList* aList);
    /**Set the parameter containers*/
    virtual void SetParContainers() { ; }
    /** Initialize everything which has to be done before the construction and modification
     ** of the geometry. Mostly this is needed to read data from the parameter containers.*/
    virtual void InitParContainers() { ; }
    /**return the geo parameter of this detector/module*/
    TList* GetListOfGeoPar() { return flGeoPar; }

    /**list of volumes in a simulation session*/
    static thread_local FairVolumeList* vList;   //!
    /**total number of volumes in a simulaion session*/
    static thread_local Int_t fNbOfVolumes;   //!
    /**list of all sensitive volumes in  a simulaion session*/
    static thread_local TRefArray* svList;   //!

    static thread_local TArrayI* volNumber;   //!
    TString fMotherVolumeName;                //!
    FairVolume* getFairVolume(FairGeoNode* fNode);
    void AddSensitiveVolume(TGeoVolume* v);

  private:
    /** Re-implimented from ROOT:  TGeoMatrix::SetDefaultName()  */
    void SetDefaultMatrixName(TGeoMatrix* matrix);
    void AssignMediumAtImport(TGeoVolume* v);   // O.Merle, 29.02.2012 - see impl.

    /**called from ConstructGDMLGeometry. Changes default ID created by TGDMLParse*/
    void ReAssignMediaId();
    void swap(FairModule& other) throw();

  protected:
    FairModule(const FairModule&);
    FairModule& operator=(const FairModule&);
    TString fgeoVer;
    TString fgeoName;
    Int_t fModId;
    Bool_t fActive;
    Int_t fNbOfSensitiveVol;   //!
    Int_t fVerboseLevel;
    TList* flGeoPar;    //!  list of Detector Geometry parameters
    Bool_t fGeoSaved;   //! flag for initialisation
    TVirtualMC* fMC;    //! cahed pointer to MC (available only after initialization)

    ClassDefOverride(FairModule, 4);
};

template<class T, class U>
void FairModule::ConstructASCIIGeometry(TString containerName)
{
    FairGeoLoader* loader = FairGeoLoader::Instance();
    FairGeoInterface* GeoInterface = loader->getGeoInterface();
    T* MGeo = new T();
    MGeo->print();
    MGeo->setGeomFile(GetGeometryFileName());
    GeoInterface->addGeoModule(MGeo);   // takes ownership!
    Bool_t rc = GeoInterface->readSet(MGeo);
    if (rc) {
        MGeo->create(loader->getGeoBuilder());
    }

    TList* volList = MGeo->getListOfVolumes();
    // store geo parameter
    FairRun* fRun = FairRun::Instance();
    FairRuntimeDb* rtdb = FairRun::Instance()->GetRuntimeDb();

    if ("" != containerName) {
        LOG(info) << "Add GeoNodes for " << MGeo->getDescription() << " to container " << containerName;

        //    U par=(U)(rtdb->getContainer(containerName));
        U* par = static_cast<U*>(rtdb->getContainer(containerName));
        TObjArray* fSensNodes = par->GetGeoSensitiveNodes();
        TObjArray* fPassNodes = par->GetGeoPassiveNodes();

        TListIter iter(volList);
        FairGeoNode* node = nullptr;
        FairGeoVolume* aVol = nullptr;

        while ((node = static_cast<FairGeoNode*>(iter.Next()))) {
            aVol = dynamic_cast<FairGeoVolume*>(node);
            if (node->isSensitive()) {
                fSensNodes->AddLast(aVol);
            } else {
                fPassNodes->AddLast(aVol);
            }
        }
        ProcessNodes(volList);
        par->setChanged();
        par->setInputVersion(fRun->GetRunId(), 1);
    }
}

template<class T, class U>
void FairModule::ConstructASCIIGeometry(T*, TString containerName, U*)
{
    ConstructASCIIGeometry<T, U>(containerName);
}

#endif   // FAIRMODULE_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/// Class FAIRParticle
/// ------------------
/// Extended TParticle with persistent pointers to mother and daughters
/// particles  (Ivana Hrivnacova, 5.4.2002)
/// Used to define particles which will be added to Geant3/4 (M. Al-Turany)

#ifndef FAIR_PARTICLE_H
#define FAIR_PARTICLE_H

#include <Rtypes.h>            // for Int_t, Double_t, Bool_t, etc
#include <TMCParticleType.h>   // for TMCParticleType
#include <TObject.h>           // for TObject
#include <TRef.h>              // for TRef
#include <TRefArray.h>         // for TRefArray
#include <TString.h>           // for TString

class TParticle;

class FairParticle : public TObject
{
  public:
    FairParticle(Int_t id, TParticle* particle);
    FairParticle(Int_t id, TParticle* particle, FairParticle* mother);
    FairParticle(const char* name,
                 Int_t z,
                 Int_t a,
                 Int_t s,
                 Double_t mass,
                 Int_t q,
                 Bool_t stable,
                 Double_t decaytime);
    FairParticle(const char* name, Int_t z, Int_t a, Double_t mass, Int_t q, Bool_t stable, Double_t decaytime);
    FairParticle(Int_t pdg,
                 const TString name,
                 TMCParticleType mcType,
                 Double_t mass,
                 Double_t charge,
                 Double_t lifetime,
                 const TString pType = "Ion",
                 Double_t width = 0,
                 Int_t iSpin = 0,
                 Int_t iParity = 0,
                 Int_t iConjugation = 0,
                 Int_t iIsospin = 0,
                 Int_t iIsospinZ = 0,
                 Int_t gParity = 0,
                 Int_t lepton = 0,
                 Int_t baryon = 0,
                 Bool_t stable = kFALSE);

    FairParticle();

    ~FairParticle() override;

    // methods
    void SetMother(FairParticle* particle);
    void AddDaughter(FairParticle* particle);
    void Print(Option_t* option = "") const override;
    void PrintDaughters() const;

    // get methods
    Int_t GetPDG() const;
    TParticle* GetParticle() const;
    FairParticle* GetMother() const;
    Int_t GetNofDaughters() const;
    FairParticle* GetDaughter(Int_t i) const;
    const char* GetName() const override { return fname.Data(); }
    TMCParticleType GetMCType() { return fmcType; }
    Double_t GetMass() { return fmass; }
    Double_t GetCharge() { return fcharge; }
    Double_t GetDecayTime() { return fDecayTime; }
    const TString& GetPType() { return fpType; }
    Double_t GetWidth() { return fwidth; }
    Int_t GetSpin() { return fiSpin; }
    Int_t GetiParity() { return fiParity; }
    Int_t GetConjugation() { return fiConjugation; }
    Int_t GetIsospin() { return fiIsospin; }
    Int_t GetIsospinZ() { return fiIsospinZ; }
    Int_t GetgParity() { return fgParity; }
    Int_t GetLepton() { return flepton; }
    Int_t GetBaryon() { return fbaryon; }
    Bool_t IsStable() { return fstable; }

  private:
    FairParticle(const FairParticle& P);
    FairParticle& operator=(const FairParticle&) { return *this; }
    // data members
    Int_t fpdg;
    TParticle* fParticle;
    TRef fMother;
    TRefArray fDaughters;
    const TString fname;
    TMCParticleType fmcType;
    Double_t fmass;
    Double_t fcharge;
    Double_t fDecayTime;
    const TString fpType;
    Double_t fwidth;
    Int_t fiSpin;
    Int_t fiParity;
    Int_t fiConjugation;
    Int_t fiIsospin;
    Int_t fiIsospinZ;
    Int_t fgParity;
    Int_t flepton;
    Int_t fbaryon;
    Bool_t fstable;

    ClassDefOverride(FairParticle, 3);
};

#endif   // FAIR_PARTICLE_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH *
 *                                                                              *
 *              This software is distributed under the terms of the *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE" *
 ********************************************************************************/

/** FairPrimaryGenerator.h
 *@author V.Friese  <v.friese@gsi.de>
 *
The FairPrimaryGenerator is responsible for the handling of the MC input.
Several input generators can be registered to it; these have to be
derived from the FairGenerator class. The FairPrimaryGenerator defines
position and (optionally) smearing of the primary vertex.
This class should be instantised only once.

Modified 05.06.07:  add a method DoTracking(Bool_t) to be able to switch on/off
the tracking from the macro (M. Al-Turany)

**/

#ifndef FAIRPRIMARYGENERATOR_H
#define FAIRPRIMARYGENERATOR_H

#include "FairGenerator.h"   // for FairGenerator

#include <Rtypes.h>   // for Double_t, Bool_t, Int_t, etc
#include <TMCProcess.h>
#include <TNamed.h>      // for TNamed
#include <TObjArray.h>   // for TObjArray
#include <TVector3.h>    // for TVector3
#include <iostream>      // for cout

class FairGenericStack;
class FairMCEventHeader;
class TIterator;

class FairPrimaryGenerator : public TNamed
{

  public:
    /** Default constructor. **/
    FairPrimaryGenerator();

    /** Constructor with name and title **/
    FairPrimaryGenerator(const char *name, const char *title = "FAIR Generator");

    /** Destructor. **/
    virtual ~FairPrimaryGenerator();

    /** Initialize the generater (if needed!)*/
    virtual Bool_t Init();

    /** Finalize the generater (if needed!)*/
    virtual void Finish();

    /** Register a generator derived from FairGenerator.  **/
    void AddGenerator(FairGenerator *generator)
    {
        if (!fGenList) {
            std::cout << "Empty fGenList pointer ! " << std::endl;
            return;
        }
        fGenList->Add(generator);
    }

    void SetEventNr(Int_t evtNr) { fEventNr = evtNr; }

    /** Public method GenerateEvent
      To be called at the beginning of each event from FairMCApplication.
      Generates an event vertex and calls the ReadEvent methods from the
      registered generators.
      *@param pStack The particle stack
      *@return kTRUE if successful, kFALSE if not
      **/
    virtual Bool_t GenerateEvent(FairGenericStack *pStack);

    /** Public method AddTrack
      Adding a track to the MC stack. To be called within the ReadEvent
      methods of the registered generators.
      *@param pdgid Particle ID (PDG code)
      *@param px,py,pz Momentum coordinates [GeV]
      *@param vx,vy,vz Track origin relative to event vertex
      **/
    virtual void AddTrack(Int_t pdgid,
                          Double_t px,
                          Double_t py,
                          Double_t pz,
                          Double_t vx,
                          Double_t vy,
                          Double_t vz,
                          Int_t parent = -1,
                          Bool_t wanttracking = true,
                          Double_t e = -9e9,
                          Double_t tof = 0.,
                          Double_t weight = 0.,
                          TMCProcess proc = kPPrimary);

    /** Clone this object (used in MT mode only) */
    virtual FairPrimaryGenerator *ClonePrimaryGenerator() const;

    /** Set beam position and widths.
     *@param beamX0      mean x position of beam at target
     *@param beamY0      mean y position of beam at target
     *@param beamSigmaX  Gaussian beam width in x
     *@param beamSigmaY  Gaussian beam width in y
     **/
    void SetBeam(Double_t beamX0, Double_t beamY0, Double_t beamSigmaX, Double_t beamSigmaY);

    /** Set nominal beam angle and angle widths.
     *@param beamAngleX0      mean x angle of beam at target
     *@param beamAngleY0      mean y angle of beam at target
     *@param beamAngleSigmaX  Gaussian beam angle width in x
     *@param beamAngleSigmaY  Gaussian beam angle width in y
     **/
    void SetBeamAngle(Double_t beamAngleX0, Double_t beamAngleY0, Double_t beamAngleSigmaX, Double_t beamAngleSigmaY);

    /** Public method SetEventPlane
     **@param phiMin   Lower limit for event plane angle [rad]
     **@param phiMax   Upper limit for event plane angle [rad]
     **If set, an event plane angle will be generated with flat
     **distrtibution between phiMin and phiMax.
     **/
    void SetEventPlane(Double_t phiMin, Double_t phiMax);

    /** Set target position and thickness.
     *@param targetZ   z position of target center
     *@param targetDz  full target thickness
     **/
    void SetTarget(Double_t targetZ, Double_t targetDz);

    /** Set target position for multiple tagets. The thickness
     * is the same for all targets.
     *@param nroftargets   number of targets
     *@param *targetZ      z positions of target center
     *@param targetDz      full target thickness
     **/
    void SetMultTarget(Int_t nroftargets, Double_t *targetZ, Double_t targetDz);

    /** Enable vertex smearing in z and/or xy direction **/
    void SmearVertexZ(Bool_t flag);
    void SmearGausVertexZ(Bool_t flag);
    void SmearVertexXY(Bool_t flag);
    void SmearGausVertexXY(Bool_t flag);

    TObjArray *GetListOfGenerators() { return fGenList; }

    /** Set the pointer to the MCEvent **/
    void SetEvent(FairMCEventHeader *event) { fEvent = event; };

    /** Accessor to the MCEvent **/
    FairMCEventHeader *GetEvent() { return fEvent; };

    /** Swich on/off the tracking of a particle*/

    void DoTracking(Bool_t doTracking = kTRUE) { fdoTracking = doTracking; }

    Int_t GetTotPrimary() { return fTotPrim; }

  protected:
    /**  Copy constructor */
    FairPrimaryGenerator(const FairPrimaryGenerator &);
    /**  Assignment operator */
    FairPrimaryGenerator &operator=(const FairPrimaryGenerator &);

    /**  Nominal beam position at target in x [cm] */
    Double_t fBeamX0;
    /** Nominal beam position at target in y [cm]*/
    Double_t fBeamY0;
    /** Beam width (Gaussian) in x [cm]*/
    Double_t fBeamSigmaX;
    /**  Beam width (Gaussian) in y [cm]*/
    Double_t fBeamSigmaY;

    /**  Nominal beam angle at target in x [rad] */
    Double_t fBeamAngleX0;
    /**  Nominal beam angle at target in y [rad] */
    Double_t fBeamAngleY0;
    /**  Actual beam angle at target in x [rad] */
    Double_t fBeamAngleX;
    /**  Actual beam angle at target in y [rad] */
    Double_t fBeamAngleY;
    /** Beam angle width (Gaussian) in x [rad]*/
    Double_t fBeamAngleSigmaX;
    /** Beam angle width (Gaussian) in y [rad]*/
    Double_t fBeamAngleSigmaY;
    /** Actual beam direction at the vertex */
    TVector3 fBeamDirection;

    /** Lower limit for the event plane rotation angle [rad] */
    Double_t fPhiMin;
    /** Upper limit for the event plane rotation angle [rad] */
    Double_t fPhiMax;
    /** Actual event plane rotation angle [rad] */
    Double_t fPhi;

    /**  Nominal z position of center of targets [cm]*/
    Double_t *fTargetZ;   //!
    /**  Number of targets;*/
    Int_t fNrTargets;
    /**  Full target thickness [cm]*/
    Double_t fTargetDz;

    /** Vertex position of current event [cm]*/
    TVector3 fVertex;

    /** Number of primary tracks in current event*/
    Int_t fNTracks;

    /**  Flag for uniform vertex smearing in z*/
    Bool_t fSmearVertexZ;
    /**  Flag for gaus vertex smearing in z*/
    Bool_t fSmearGausVertexZ;
    /**  Flag for vertex smearing in xy*/
    Bool_t fSmearVertexXY;
    /**  Flag for gaus vertex smearing in xy*/
    Bool_t fSmearGausVertexXY;
    /**  Flag for beam gradient calculation*/
    Bool_t fBeamAngle;
    /**  Flag for event plane rotation*/
    Bool_t fEventPlane;

    /**  Pointer to MC stack*/
    FairGenericStack *fStack;   //!
    /**  List of registered generators */
    TObjArray *fGenList;
    /**  Iterator over generator list */
    TIterator *fListIter;   //!
    /**  Pointer to MCEventHeader */
    FairMCEventHeader *fEvent;   //!
    /** go to tracking  */
    Bool_t fdoTracking;   //!
    /** Number of MC tracks before a Generator is called, needed for MC index
     * update */
    Int_t fMCIndexOffset;   //!
    /** Number of all primaries of this run*/
    static Int_t fTotPrim;   //!
    /** Event number (Set by the primary generator if not set already by one of
      the specific generators
   **/
    Int_t fEventNr;

    /** Private method MakeVertex. If vertex smearing in xy is switched on,
      the event vertex is smeared Gaussianlike in x and y direction
      according to the mean beam positions and widths set by the
      SetBeam method. If vertex smearing in z is switched on, the z
      coordinate of the event vertex is flatly distributed over the
      extension of the target.
      To be called at the beginning of the event from the
      GenerateEvent method.
  **/
    virtual void MakeVertex();

    /** Private method MakeBeamAngle. If beam angle smearing in xy
  is switched on, all tracks in an event are rotated by a Gaussianlike
  angle distribution around the x and y axis according to the mean
  beam angle and angle widths set by the SetBeamAngle method.
  To be called at the beginning of the event from the GenerateEvent
  method.
  **/
    virtual void MakeBeamAngle();

    /** Private method MakeEventPlane. If the rotation of the event around the
      z-axis by a random angle is switched on, the complete event is rotated
      by the chosen angle. This function is called at the beginning of the
      event from the GenerateEvent method. The function pick a random
      rotation angle between fPhiMin and fPhiMax which are set using the
      function SetEventPlane.
  **/
    void MakeEventPlane();

    ClassDef(FairPrimaryGenerator, 5);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNIDGENERATOR_H
#define FAIRRUNIDGENERATOR_H

#include <time.h>   // IWYU pragma: keep for timespec
// IWYU pragma: no_include <sys/_structs.h>

typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
typedef unsigned char uuid_t[16];

class FairRunIdGenerator
{
    struct uuid
    {
        uint32_t time_low;
        uint16_t time_mid;
        uint16_t time_hi_and_version;
        uint16_t clock_seq;
        uint8_t node[6];
    };

    struct timespec fTimeSpec;

    int get_random_fd(void);
    void get_random_bytes(void*, int);
    int get_node_id(unsigned char*);
    int get_clock(uint32_t*, uint32_t*, uint16_t*);
    void uuid_generate_time(uuid_t);
    void uuid_generate_random(uuid_t);
    void uuid_generate(uuid_t);
    void uuid_pack(const struct uuid*, uuid_t);
    void uuid_unpack(const uuid_t, struct uuid*);

  public:
    struct timespec getTimeSpec() { return fTimeSpec; }
    struct timespec getTimeSpecFromTID(unsigned int ms);
    unsigned int getTID();

  public:
    FairRunIdGenerator()
        : fTimeSpec()
    {}
    ~FairRunIdGenerator() {}
    unsigned int generateId(void);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUME_H
#define FAIR_VOLUME_H

#include "FairModule.h"

#include <Rtypes.h>    // for Int_t, FairVolume::Class, etc
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString

class FairDetector;
class FairGeoNode;

/**
 * This Object is only used for internal book keeping!
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairVolume : public TNamed
{
  public:
    FairVolume();
    FairVolume(const TString& name, Int_t id = 0, Int_t modId = 0, FairModule* fMod = nullptr);
    ~FairVolume() override;

    void setRealName(TString name) { fRealName = name; }
    const char* getRealName() const { return fRealName.Data(); }
    Int_t getVolumeId() const { return fVolumeId; }
    Int_t getModId() const { return fModId; }
    void setModId(Int_t id) { fModId = id; }
    void setCopyNo(Int_t id) { fCopyNo = id; }
    void setVolumeId(Int_t id) { fVolumeId = id; }
    void setGeoNode(FairGeoNode* d) { fNode = d; }
    void setMotherId(Int_t fM) { fMotherId = fM; }
    void setMotherCopyNo(Int_t copyNo) { fMotherCopyNo = copyNo; }

    FairModule* GetModule() const { return fModule; }
    FairDetector* GetDetector() const { return fDetector; }
    void SetModule(FairModule* mod);

    Int_t getMCid() const { return fMCid; }
    Int_t getCopyNo() const { return fCopyNo; }
    void setMCid(Int_t id) { fMCid = id; }
    FairGeoNode* getGeoNode() const { return fNode; }
    Int_t getMotherId() const { return fMotherId; }
    Int_t getMotherCopyNo() const { return fMotherCopyNo; }

  private:
    FairVolume(const FairVolume&);
    FairVolume& operator=(const FairVolume&);

    TString fRealName{""};            /**Volume Name in ASCII file*/
    Int_t fVolumeId{-1};              /**Volume Id in GeoManager*/
    Int_t fModId{-1};                 /**Module Id in which this volume exist*/
    Int_t fMCid{-1};                  /**Volume Id in MC*/
    Int_t fCopyNo{-1};                /**Volume Copy No*/
    Int_t fMotherId{-1};              /**Mother Volume Id*/
    Int_t fMotherCopyNo{-1};          /**Mother Volume Copy No*/
    FairDetector* fDetector{nullptr}; /** The Detector which will proccess the hits for this volume*/
    FairModule* fModule{nullptr};     /**The Module in which the volume is */
    FairGeoNode* fNode{nullptr};      /**Node corresponding to this volume*/

    ClassDefOverride(FairVolume, 2);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_VOLUMELIST_H
#define FAIR_VOLUMELIST_H

#include "FairVolume.h"

#include <Rtypes.h>      // for Int_t, etc
#include <TObjArray.h>   // for TObjArray
#include <TObject.h>     // for TObject
#include <TString.h>     // for TString

// class FairVolume;

/**
 * This Object is only used for internal book keeping!
 * @author M. Al-Turany, D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairVolumeList : public TObject
{
  private:
    TObjArray* fData;
    FairVolumeList(const FairVolumeList&);
    FairVolumeList& operator=(const FairVolumeList&);

  public:
    FairVolumeList();
    virtual ~FairVolumeList();

    FairVolume* getVolume(TString* name);
    Int_t getVolumeId(TString* name);

    FairVolume* findObject(TString name);
    void addVolume(FairVolume* elem);

    Int_t getEntries() { return fData->GetEntries(); }
    FairVolume* At(Int_t pos) { return (dynamic_cast<FairVolume*>(fData->At(pos))); }

    ClassDef(FairVolumeList, 1);
};

#endif   // FAIR_VOLUMELIST_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairRootFileSink                      -----
// -----                    Created 22.12.2017 by R. Karabowicz            -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef __FAIRROOT__FairRootFileSink__
#define __FAIRROOT__FairRootFileSink__

#include "FairSink.h"

#include <Rtypes.h>
#include <TFile.h>
#include <TString.h>
#include <typeinfo>

class FairEventHeader;
class FairFileHeader;
class TBranch;
class TObjArray;
class TObject;
class TTree;
class TFolder;

class FairRootFileSink : public FairSink
{
  public:
    FairRootFileSink(TFile* f, const char* Title = "OutputRootFile");
    FairRootFileSink(const TString* RootFileName, const char* Title = "OutputRootFile");
    FairRootFileSink(const TString RootFileName, const char* Title = "OutputRootFile");
    //  FairRootFileSink(const FairRootFileSink& file);
    virtual ~FairRootFileSink();

    virtual Bool_t InitSink();
    virtual void Close();
    virtual void Reset();

    virtual Sink_Type GetSinkType() { return kFILESINK; }

    virtual void FillEventHeader(FairEventHeader* feh);

    virtual TFile* OpenRootFile(TString fileName = "");
    TFile* GetRootFile() { return fRootFile; }
    virtual TString GetFileName() { return (fRootFile ? fRootFile->GetName() : ""); }

    virtual void SetOutTree(TTree* fTree) { fOutTree = fTree; }
    TTree* GetOutTree() { return fOutTree; }

    virtual void Fill();

    virtual Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0);

    virtual void RegisterImpl(const char*, const char*, void*);
    virtual void RegisterAny(const char* brname, const std::type_info& oi, const std::type_info& pi, void* obj);

    virtual void WriteFolder();
    virtual bool CreatePersistentBranchesAny();

    virtual void WriteObject(TObject* f, const char*, Int_t option = 0);
    virtual void WriteGeometry();

    virtual FairSink* CloneSink();

  private:
    /** Title of input sink, could be input, background or signal*/
    TString fOutputTitle;
    /** ROOT file */
    TFile* fRootFile;
    /** Output Tree  */
    TTree* fOutTree;
    /**  list of folders from all input (and friends) files */
    TObjArray* fListFolder;   //!
    /** folder structure of output */
    TFolder* fCbmout;
    /** Initialization flag, true if initialized */
    Bool_t fIsInitialized;

    FairRootFileSink(const FairRootFileSink&);
    FairRootFileSink operator=(const FairRootFileSink&);

    void TruncateBranchNames();
    void TruncateBranchNames(TBranch* b, TString ffn);
    // bool CreatePersistentBranchesAny();

    /**File Header*/
    FairFileHeader* fFileHeader;   //!

    bool fPersistentBranchesDone{false};   //!

    ClassDef(FairRootFileSink, 1);
};

#endif /* defined(__FAIRROOT__FairRootFileSink__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairSink                              -----
// -----                    Created 22.12.2017 by R. Karabowicz            -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRSINK_H
#define FAIRSINK_H

#include <Rtypes.h>
#include <TString.h>
#include <map>        // map
#include <memory>     // unique_ptr
#include <string>     // string
#include <typeinfo>   // type_info

class TObject;
class TFolder;
class TTree;

enum Sink_Type
{
    kONLINESINK,
    kFILESINK
};

class FairSink
{
  public:
    FairSink();
    FairSink(const FairSink& sink);
    virtual ~FairSink();

    virtual Bool_t InitSink() = 0;
    virtual void Close() = 0;
    virtual void Reset() = 0;

    virtual Sink_Type GetSinkType() = 0;
    virtual TString GetFileName() { return ""; }

    void SetRunId(Int_t runId) { fRunId = runId; }
    Int_t GetRunId() const { return fRunId; }

    virtual void SetOutTree(TTree* fTree) = 0;

    virtual void Fill() = 0;

    virtual Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) = 0;

    virtual void RegisterImpl(const char*, const char*, void*) = 0;
    virtual void RegisterAny(const char* brname, const std::type_info& oi, const std::type_info& pi, void* obj) = 0;

    virtual void WriteFolder() = 0;
    virtual bool CreatePersistentBranchesAny() = 0;

    virtual void WriteObject(TObject* f, const char*, Int_t option = 0) = 0;
    virtual void WriteGeometry() = 0;

    virtual FairSink* CloneSink() = 0;

  protected:
    struct TypeAddressPair
    {
        TypeAddressPair(const std::type_info& oi, const std::type_info& pi, void* a)
            : origtypeinfo(oi)
            , persistenttypeinfo(pi)
            , ptraddr(a)
        {}
        const std::type_info& origtypeinfo;         // type_info of type addr points to
        const std::type_info& persistenttypeinfo;   // type_info of ROOT persistent branch (drops pointers)
        void* ptraddr;                              // address of a pointer (pointing to origtypeinfo);
    };

    Int_t fRunId;

    /**folder structure of output*/
    TFolder* fOutFolder;
    /// A map of branchnames to typeinformation + memory address;
    /// used for branches registered to bes stored; use of ptr here
    /// since type_info cannot be copied
    std::map<std::string, std::unique_ptr<TypeAddressPair const>> fPersistentBranchesMap;   //!

  public:
    ClassDef(FairSink, 1);
};

#endif
/********************************************************************************
 *    Copyright (C) 2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

#ifndef __FAIRROOT__FairFileSourceBase__
#define __FAIRROOT__FairFileSourceBase__

#include "FairSource.h"

#include <TFile.h>
#include <list>
#include <map>

/**
 * \brief Internal base class for FairFileSource and FairMixedSource
 */
class FairFileSourceBase : public FairSource
{
  public:
    ~FairFileSourceBase() override;
    void Reset() override {}
    Source_Type GetSourceType() override { return kFILE; }
    void SetParUnpackers() override {}
    Bool_t InitUnpackers() override { return kTRUE; }
    Bool_t ReInitUnpackers() override { return kTRUE; }

    Bool_t CompareBranchList(TFile* fileHandle, TString inputLevel);

  protected:
    FairFileSourceBase()
        : FairSource(){};

    std::map<TString, std::list<TString>> fCheckInputBranches{};   //!

    ClassDefOverride(FairFileSourceBase, 0);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairFileSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairFileSource__
#define __FAIRROOT__FairFileSource__

#include "FairFileSourceBase.h"

#include <TArrayI.h>
#include <TChain.h>
#include <TF1.h>
#include <TFile.h>
#include <TFolder.h>
#include <TString.h>
#include <list>
#include <map>
#include <memory>

class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TTree;

class FairFileSource : public FairFileSourceBase
{
  public:
    FairFileSource(TFile* f, const char* Title = "InputRootFile", UInt_t identifier = 0);
    FairFileSource(const TString* RootFileName, const char* Title = "InputRootFile", UInt_t identifier = 0);
    FairFileSource(const TString RootFileName, const char* Title = "InputRootFile", UInt_t identifier = 0);
    // FairFileSource(const FairFileSource& file);
    ~FairFileSource() override;

    Bool_t Init() override;
    Int_t ReadEvent(UInt_t i = 0) override;
    void Close() override;

    /**Check the maximum event number we can run to*/
    Int_t CheckMaxEventNo(Int_t EvtEnd = 0) override;
    /**Read the tree entry on one branch**/
    void ReadBranchEvent(const char* BrName) override;
    /**Read specific tree entry on one branch**/
    void ReadBranchEvent(const char* BrName, Int_t Entry) override;
    void FillEventHeader(FairEventHeader* feh) override;

    const TFile* GetRootFile() { return fRootFile; }
    /** Add a friend file (input) by name)*/
    void AddFriend(TString FileName);
    /**Add ROOT file to input, the file will be chained to already added files*/
    void AddFile(TString FileName);
    void AddFriendsToChain();
    void PrintFriendList();
    void CheckFriendChains();
    void CreateNewFriendChain(TString inputFile, TString inputLevel);
    TTree* GetInTree() { return fInChain->GetTree(); }
    TChain* GetInChain() { return fInChain; }
    TFile* GetInFile() { return fRootFile; }
    void CloseInFile()
    {
        if (fRootFile) {
            fRootFile->Close();
        }
    }
    void SetInTree(TTree* tempTree);
    TObjArray* GetListOfFolders() { return fListFolder; }
    TFolder* GetBranchDescriptionFolder() { return fCbmroot; }
    UInt_t GetEntries() { return fNoOfEntries; }

    //    TList*              GetBranchNameList() {return fBranchNameList;}

    void SetInputFile(TString name);

    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime).
     * The total repetition time is beamTime + gapTime */
    void SetBeamTime(Double_t beamTime, Double_t gapTime);
    /** Set the min and max limit for event time in ns */
    void SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void SetEventMeanTime(Double_t mean);
    void SetEventTime();
    Double_t GetDeltaEventTime();
    void SetFileHeader(FairFileHeader* f) { fFileHeader = f; }
    Double_t GetEventTime();

    Bool_t ActivateObject(TObject** obj, const char* BrName) override;
    Bool_t ActivateObjectAny(void**, const std::type_info&, const char*) override;

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void SetEvtHeaderNew(Bool_t Status) { fEvtHeaderIsNew = Status; }
    Bool_t IsEvtHeaderNew() { return fEvtHeaderIsNew; }

    /** Allow to disable the testing the file layout when adding files to a chain.
     */
    void SetCheckFileLayout(Bool_t enable) { fCheckFileLayout = enable; }

    /**Read one event from source to find out which RunId to use*/
    Bool_t SpecifyRunId() override;

  private:
    /** Title of input source, could be input, background or signal*/
    TString fInputTitle;
    /**ROOT file*/
    TFile* fRootFile;
    /** Current Entry number */
    Int_t fCurrentEntryNr;   //!
    /** List of all files added with AddFriend */
    std::list<TString> fFriendFileList;                                 //!
    std::list<TString> fInputChainList;                                 //!
    std::map<TString, TChain*> fFriendTypeList;                         //!
    std::list<TString> fInputLevel;                                     //!
    std::map<TString, std::multimap<TString, TArrayI>> fRunIdInfoAll;   //!
    /**Input Chain */
    TChain* fInChain;
    /**Input Tree */
    TTree* fInTree;
    /** list of folders from all input (and friends) files*/
    TObjArray* fListFolder;   //!
    /**folder structure of output*/
    TFolder* fCbmout;
    /**folder structure of input*/
    TFolder* fCbmroot;
    /***/
    UInt_t fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t IsInitialized;

    FairFileSource(const FairFileSource&);
    FairFileSource operator=(const FairFileSource&);

    /** MC Event header */
    FairMCEventHeader* fMCHeader;   //!

    /**Event Header*/
    FairEventHeader* fEvtHeader;   //!

    /**File Header*/
    FairFileHeader* fFileHeader;   //!

    /** This is true if the event time used, came from simulation*/
    Bool_t fEventTimeInMCHeader;   //!
    /**This flag is true if the event header was created in this session
     * otherwise it is false which means the header was created in a previous data
     * level and used here (e.g. in the digi)
     */
    Bool_t fEvtHeaderIsNew;   //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t fCurrentEntryNo;   //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t fTimeforEntryNo;   //!

    /** min time for one event (ns) */
    Double_t fEventTimeMin;   //!
    /** max time for one Event (ns) */
    Double_t fEventTimeMax;   //!
    /** Time of event since th start (ns) */
    Double_t fEventTime;   //!
    /** Time of particles in beam (ns) */
    Double_t fBeamTime;   //!
    /** Time without particles in beam (gap) (ns) */
    Double_t fGapTime;   //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t fEventMeanTime;   //!
    /** used to generate random numbers for event time; */
    std::unique_ptr<TF1> fTimeProb;   //!
    /** True if the file layout should be checked when adding files to a chain.
     *  Default value is true.
     */
    Bool_t fCheckFileLayout;   //!

    ClassDefOverride(FairFileSource, 3);
};

#endif /* defined(__FAIRROOT__FairFileSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
//
//  FairMixedSource.h
//  FAIRROOT
//
//  Created by Mohammad Al-Turany on 08/02/14.
//
//

#ifndef __FAIRROOT__FairMixedSource__
#define __FAIRROOT__FairMixedSource__

#include "FairFileSourceBase.h"

#include <TArrayI.h>
#include <TChain.h>
#include <TF1.h>
#include <TFile.h>
#include <list>
#include <map>
#include <memory>

class FairEventHeader;
class FairFileHeader;
class FairMCEventHeader;
class TString;
class TFolder;
class TObject;

class FairRootManager;

class FairMixedSource : public FairFileSourceBase
{
  public:
    FairMixedSource(TFile* f, const char* Title = "InputRootFile", UInt_t identifier = 0);
    FairMixedSource(const TString* RootFileName, const char* Title = "InputRootFile", UInt_t identifier = 0);
    FairMixedSource(const TString RootFileName,
                    const Int_t signalId,
                    const char* Title = "InputRootFile",
                    UInt_t identifier = 0);
    //  FairMixedSource(const FairMixedSource& file);
    ~FairMixedSource() override;

    Bool_t Init() override;
    Int_t ReadEvent(UInt_t i = 0) override;
    void Close() override;

    /**Check the maximum event number we can run to*/
    Int_t CheckMaxEventNo(Int_t EvtEnd = 0) override;
    /**Read the tree entry on one branch**/
    void ReadBranchEvent(const char* BrName) override;
    /** Read specific tree entry on one branch**/
    void ReadBranchEvent(const char* BrName, Int_t Entry) override;

    void FillEventHeader(FairEventHeader* feh) override;

    const TFile* GetRootFile() { return fRootFile; }
    /** Add a friend file (input) by name)*/

    Bool_t ActivateObject(TObject** obj, const char* BrName) override;
    Bool_t ActivateObjectAny(void**, const std::type_info&, const char*) override;

    void ReadBKEvent(UInt_t i = 0);

    /**Set the input signal file
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file
     */
    void SetSignalFile(TString name, UInt_t identifier);
    /**Set the input background file by name*/
    void SetBackgroundFile(TString name);
    /**Add signal file to input
     *@param name :        signal file name
     *@param identifier :  Unsigned integer which identify the signal file to which this signal should be added
     */
    void AddSignalFile(TString name, UInt_t identifier);
    void AddBackgroundFile(TString name);

    TChain* GetBGChain() { return fBackgroundChain; }
    TChain* GetSignalChainNo(UInt_t i);

    Bool_t OpenBackgroundChain();
    Bool_t OpenSignalChain();

    /**Set the signal to background ratio in event units
     *@param background :  Number of background Events for one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     */
    void BGWindowWidthNo(UInt_t background, UInt_t Signalid);
    /**Set the signal to background rate in time units
     *@param background :  Time of background Events before one signal
     *@param Signalid :    Signal file Id, used when adding (setting) the signal file
     */
    void BGWindowWidthTime(Double_t background, UInt_t Signalid);

    /** Set the min and max limit for event time in ns */
    void SetEventTimeInterval(Double_t min, Double_t max);
    /** Set the mean time for the event in ns */
    void SetEventMeanTime(Double_t mean);
    /** Set the repetition time of the beam when it can interact (beamTime) and when no interaction happen (gapTime).
     * The total repetition time is beamTime + gapTime */
    void SetBeamTime(Double_t beamTime, Double_t gapTime);
    void SetEventTime();
    Double_t GetDeltaEventTime();
    void SetFileHeader(FairFileHeader* f) { fFileHeader = f; }
    Double_t GetEventTime();

    TObjArray* GetListOfFolders() { return fListFolder; }
    TFolder* GetBranchDescriptionFolder() { return fCbmroot; }
    UInt_t GetEntries() { return fNoOfEntries; }

    /**Set the status of the EvtHeader
     *@param Status:  True: The header was creatged in this session and has to be filled
              FALSE: We use an existing header from previous data level
     */
    void SetEvtHeaderNew(Bool_t Status) { fEvtHeaderIsNew = Status; }
    Bool_t IsEvtHeaderNew() { return fEvtHeaderIsNew; }

    /** Use the Backgraund RunID to initialize the parameter for the run */
    void UseRunIdFromBG();
    /** Use the Backgraund RunID to initialize the parameter for the run
     *@param identifier: Signal file identifier to be used by default we take the first Signal
     */
    void UseRunIdfromSG(UInt_t identifier = 1);

  private:
    /**IO manager */
    FairRootManager* fRootManager;

    /** Title of input source, could be input, background or signal*/
    TString fInputTitle;
    /**ROOT file*/
    TFile* fRootFile;
    /** List of all files added with AddFriend */
    std::list<TString> fFriendFileList;                                 //!
    std::list<TString> fInputChainList;                                 //!
    std::map<TString, TChain*> fFriendTypeList;                         //!
    std::list<TString> fInputLevel;                                     //!
    std::map<TString, std::multimap<TString, TArrayI>> fRunIdInfoAll;   //!
    /** list of folders from all input (and friends) files*/
    TObjArray* fListFolder;   //!
    /**folder structure of output*/
    TFolder* fCbmout;
    /**folder structure of input*/
    TFolder* fCbmroot;
    /***/
    UInt_t fSourceIdentifier;
    /**No of Entries in this source*/
    UInt_t fNoOfEntries;
    /**Initialization flag, true if initialized*/
    Bool_t IsInitialized;

    /** MC Event header */
    FairMCEventHeader* fMCHeader;   //!

    /**Event Header*/
    FairEventHeader* fEvtHeader;   //!

    /**Output Event Header*/
    FairEventHeader* fOutHeader;   //!

    /**File Header*/
    FairFileHeader* fFileHeader;   //!

    /** This is true if the event time used, came from simulation*/
    Bool_t fEventTimeInMCHeader;   //!
    /**This flag is true if the event header was created in this session
     * otherwise it is false which means the header was created in a previous data
     * level and used here (e.g. in the digi)
     */
    Bool_t fEvtHeaderIsNew;   //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t fCurrentEntryNo;   //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t fTimeforEntryNo;   //!
    /* /\**No of entries in BG Chain*\/ */
    UInt_t fNoOfBGEntries;   //!
    /* /\**Hold the current entry for each input chain*\/ */
    std::map<UInt_t, UInt_t> fCurrentEntry;   //!

    /** min time for one event (ns) */
    Double_t fEventTimeMin;   //!
    /** max time for one Event (ns) */
    Double_t fEventTimeMax;   //!
    /** Time of event since th start (ns) */
    Double_t fEventTime;   //!
    /** Time of particles in beam (ns) */
    Double_t fBeamTime;   //!
    /** Time without particles in beam (gap) (ns) */
    Double_t fGapTime;   //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t fEventMeanTime;   //!
    /** used to generate random numbers for event time; */
    std::unique_ptr<TF1> fTimeProb;   //!

    /**holds the SB ratio by number*/
    std::map<UInt_t, Double_t> fSignalBGN;   //!
    /* /\**True for background window in entry units*\/ */
    Bool_t fSBRatiobyN;   //!
    /* /\**True for background window in time units (ns) *\/ */
    Bool_t fSBRatiobyT;   //!

    /**Actual identifier of the added signals, this is used to identify how many signals are added*/
    UInt_t fActualSignalIdentifier;   //!
    /** Total number of signals added (Types and not files!)*/
    UInt_t fNoOfSignals;   //!
    /** list of chains which has to be created for the different signals*/
    std::list<TString>* fSignalChainList;   //!
    /**Chain containing the background*/
    TChain* fBackgroundChain;                    //!
    std::map<UInt_t, TChain*> fSignalTypeList;   //!

    /**True if RunId is taken from Backgraund*/
    Bool_t fRunIdFromBG;   //!
    /**True if RunId is taken from Signal */
    Bool_t fRunIdFromSG;   //!
    /** Identifier of signal file for RunID
     * Zero if RunId is taken from BG.
     */
    UInt_t fRunIdFromSG_identifier;   //!

    /**Read one event from source to find out which RunId to use*/
    Bool_t SpecifyRunId() override;

    FairMixedSource(const FairMixedSource&);
    FairMixedSource& operator=(const FairMixedSource&);

  public:
    ClassDefOverride(FairMixedSource, 0);
};

#endif /* defined(__FAIRROOT__FairMixedSource__) */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -----------------------------------------------------------------------------
// -----                                                                   -----
// -----                             FairSource                            -----
// -----                    Created 01.11.2013 by F. Uhlig                 -----
// -----                                                                   -----
// -----------------------------------------------------------------------------

#ifndef FAIRSOURCE_H
#define FAIRSOURCE_H

#include "FairLogger.h"
#include "TClass.h"

#include <Rtypes.h>
#include <TObject.h>

class FairEventHeader;

enum Source_Type
{
    kONLINE,
    kFILE
};

class FairSource : public TObject
{
  public:
    FairSource();
    FairSource(const FairSource& source);
    virtual ~FairSource();
    virtual Bool_t Init() = 0;
    virtual Int_t ReadEvent(UInt_t = 0) = 0;
    virtual Bool_t SpecifyRunId() = 0;
    virtual void Close() = 0;
    virtual void Reset() = 0;
    virtual Bool_t ActivateObject(TObject**, const char*) { return kFALSE; }
    virtual Bool_t ActivateObjectAny(void**, const std::type_info&, const char*) { return kFALSE; }
    virtual Source_Type GetSourceType() = 0;
    virtual void SetParUnpackers() = 0;
    virtual Bool_t InitUnpackers() = 0;
    virtual Bool_t ReInitUnpackers() = 0;
    /**Check the maximum event number we can run to*/
    virtual Int_t CheckMaxEventNo(Int_t = 0) { return -1; }
    /**Read the tree entry on one branch**/
    virtual void ReadBranchEvent(const char*) { return; }
    virtual void ReadBranchEvent(const char*, Int_t) { return; }
    virtual void FillEventHeader(FairEventHeader* feh);
    void SetRunId(Int_t runId) { fRunId = runId; }
    Int_t GetRunId() const { return fRunId; }

  protected:
    Int_t fRunId;

  public:
    ClassDef(FairSource, 2);
};

namespace {

template<typename S>
bool ActivateObjectAnyImpl(S* source, void** obj, const std::type_info& info, const char* brname)
{
    // we check if the types match at all
    auto br = source->GetBranch(brname);
    if (!br) {
        // branch not found in source
        return false;
    }

    // look up the TClass and resulting typeid stored in this branch
    auto cl = TClass::GetClass(br->GetClassName());
    if (!cl) {
        // class not found
        return false;
    }

    auto storedtype = cl->GetTypeInfo();

    // check consistency of types
    if (info.hash_code() != storedtype->hash_code()) {
        LOG(info) << "Trying to read from branch " << brname << " with wrong type " << info.name()
                  << " (expected: " << storedtype->name() << ")\n";
        return false;
    }
    source->SetBranchStatus(brname, 1);
    // force to use the (void*) interface which is non-checking
    source->SetBranchAddress(brname, (void*)obj);
    return true;
}

}   // namespace

#endif
#ifndef FAIR_LINK_MANAGER_H
#define FAIR_LINK_MANAGER_H

#include <Rtypes.h>    // for Bool_t, Int_t, UInt_t, etc
#include <TMCtls.h>    // for multi-threading
#include <TObject.h>   // for TObject
#include <set>         // for set of branch types to ignore

class FairLogger;

class FairLinkManager : public TObject
{
  public:
    /**ctor*/
    FairLinkManager();
    /**dtor*/
    virtual ~FairLinkManager();

    /** static access method */
    static FairLinkManager* Instance();
    virtual void AddIgnoreType(Int_t type);   ///< Adds a BranchId (Type) to which links are not included in the link
                                              ///< list. Either ignore types or include types can be given.
    virtual Bool_t IsIgnoreType(Int_t type) const;

    virtual void AddIncludeType(Int_t type);   ///< Adds a BranchId (Type) to which links are included in the link list.
                                               ///< Either ignore types or include types can be given (XOR).

    std::set<Int_t> GetIgnoreTypes() const { return fIgnoreTypes; }

  private:
    /**private methods*/
    FairLinkManager(const FairLinkManager&);
    FairLinkManager& operator=(const FairLinkManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/

    std::set<Int_t> fIgnoreTypes;   //!
    Bool_t fIgnoreSetting;

    /**Singleton instance*/
    static TMCThreadLocal FairLinkManager* fgInstance;

    FairLogger* fLogger;   //!

    ClassDef(FairLinkManager, 1);
};

#endif   // FAIR_ROOT_MANAGER_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                    FairRadGridManager source file             -----
// -----          original author                  D.Bertini           -----
// -----          adapted april 2010               O.Hartmann          -----
// -------------------------------------------------------------------------
#ifndef FAIRRADGRIDMANAGER_H
#define FAIRRADGRIDMANAGER_H 1

#include <Rtypes.h>           // for Float_t, Double_t, Int_t, etc
#include <TLorentzVector.h>   // for TLorentzVector
#include <TObjArray.h>        // for TObjArray
#include <TString.h>          // for TString
#include <iostream>           // for basic_ostream::operator<<, etc

class FairMesh;
class TClonesArray;

/**
 * @class FairRadGridManager
 */

class FairRadGridManager
{
  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadGridManager class.
     */
    FairRadGridManager();
    /**
     * Destructor.
     */
    virtual ~FairRadGridManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadGridManager, 1);

  private:
    FairRadGridManager(const FairRadGridManager&);
    FairRadGridManager& operator=(const FairRadGridManager&);

    static FairRadGridManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray* fPointCollection;
    /**track index */
    Int_t fTrackID;   //!
    /**volume id */
    Int_t fVolumeID;   //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;   //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;   //!
    /**  momentum in*/
    TLorentzVector fMomIn;   //!
    /**  momentum out*/
    TLorentzVector fMomOut;   //!
    /**track time */
    Double_t fTime;   //!
    /**track length */
    Double_t fLength;   //!
    /** energy loss */
    Double_t fELoss;   //!
    /** mass umber*/
    Float_t fA;
    /** atomic number*/
    Float_t fZmat;
    /**  density */
    Float_t fDensity;
    /**radition length */
    Float_t fRadl;
    /**absorption length */
    Float_t fAbsl;
    /**estimator*/
    Int_t fEstimator;
    /** the mesh */
    TObjArray* fMeshList;
    /** output file name */
    TString fOutputFileName;

  public:
    TObjArray* GetMeshList() { return fMeshList; }
    void AddMeshList(TObjArray* list)
    {
        std::cout << " grid manag " << list->GetEntriesFast() << std::endl;
        fMeshList = list;
    }
    Bool_t IsTrackInside(TLorentzVector& vec, FairMesh* aMesh);
    Bool_t IsTrackEntering(TLorentzVector& vec1, TLorentzVector& vec2);
    /** fill the 2D mesh */
    void FillMeshList();
    /**initialize the manager*/
    void Init();
    /**reset*/
    void Reset();
    /**set output file name*/
    void SetOutputFileName(TString tempString) { fOutputFileName = tempString; }
    TString GetOutputFileName() { return fOutputFileName; }
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadGridManager object, created
     * with FairRadGridManager::FairRadGridManager().
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated("Maybe use FairMCApplcation::GetRadGridMan()")]] static FairRadGridManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadLenManager source file             -----
// -----                  Created 14/01/08  by M. Al-Turany            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADLENMANAGER_H
#define FAIRRADLENMANAGER_H 1

#include <Rtypes.h>           // for Float_t, Double_t, Int_t, etc
#include <TLorentzVector.h>   // for TLorentzVector

class TClonesArray;
class TVirtualMC;

/**
 * @class FairRadLenManager
 */

class FairRadLenManager
{
  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadLenManager class.
     */
    FairRadLenManager();

    /**
     * Destructor.
     */
    virtual ~FairRadLenManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadLenManager, 1);

  private:
    FairRadLenManager(const FairRadLenManager&);
    FairRadLenManager& operator=(const FairRadLenManager&);

    static FairRadLenManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray* fPointCollection;
    /**track index */
    Int_t fTrackID;   //!
    /**volume id */
    Int_t fVolumeID;   //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;   //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;   //!
    /**  momentum in*/
    TLorentzVector fMomIn;   //!
    /**  momentum out*/
    TLorentzVector fMomOut;   //!
    /**track time */
    Double_t fTime;   //!
    /**track length */
    Double_t fLength;   //!
    /** energy loss */
    Double_t fELoss;   //!
    /** mass umber*/
    Float_t fA;
    /** atomic number*/
    Float_t fZmat;
    /**  density */
    Float_t fDensity;
    /**radition length */
    Float_t fRadl;
    /**absorption length */
    Float_t fAbsl;

  public:
    /**Add point to collection*/
    void AddPoint(TVirtualMC* aMC, const Int_t ModuleId);
    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated("Use AddPoint(TVirtualMC*, ...)")]] void AddPoint(const Int_t ModuleId);
    /**initialize the manager*/
    void Init();
    /**reset*/
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadLenManager object, created
     * with FairRadLenManager::FairRadLenManager().
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] static FairRadLenManager* Instance();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairRadMapManager source file            -----
// -------------------------------------------------------------------------
#ifndef FAIRRADMAPMANAGER_H
#define FAIRRADMAPMANAGER_H 1

#include <Rtypes.h>           // for Double_t, Float_t, Int_t, etc
#include <TLorentzVector.h>   // for TLorentzVector

class TClonesArray;
class TMap;
class TVirtualMC;

/**
 * @class FairRadMapManager
 */

class FairRadMapManager
{
  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairRadMapManager class.
     */
    FairRadMapManager();

    /**
     * Destructor.
     */
    virtual ~FairRadMapManager();

    /**
     * Class definition.
     */
    ClassDef(FairRadMapManager, 1);

  private:
    FairRadMapManager(const FairRadMapManager&);
    FairRadMapManager& operator=(const FairRadMapManager&);

    static FairRadMapManager* fgInstance;

    /**
     * collection of point
     */
    TClonesArray* fPointCollection;
    /**track index */
    Int_t fTrackID;   //!
    /**volume id */
    Int_t fVolumeID;   //!
    /** pid */
    Int_t fPdg;   //!
    /**  entry position in global frame*/
    TLorentzVector fPosIn;   //!
    /**  exit position in global frame*/
    TLorentzVector fPosOut;   //!
    /**  momentum in*/
    TLorentzVector fMomIn;   //!
    /**  momentum out*/
    TLorentzVector fMomOut;   //!
    /**track time */
    Double_t fTime;   //!
    /**track length */
    Double_t fLength;   //!
    /**track setp */
    Double_t fStep;
    /** energy loss */
    Double_t fELoss;   //!
    /**dose */
    Double_t fDose;
    Double_t fDoseSL;
    /** mass umber*/
    Float_t fA;
    /** atomic number*/
    Float_t fZmat;
    /** radiation length*/
    Float_t fRadl;
    /**  density */
    Float_t fDensity;
    /**absorption length */
    Float_t fAbsl;
    //**volume, mass */
    Double_t fActVol;
    Double_t fActMass;

    TMap* fMassMap;

  public:
    /**Add point to collection*/
    void AddPoint(TVirtualMC* aMC, const Int_t);
    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated("Use AddPoint(TVirtualMC*, ...)")]] void AddPoint(const Int_t ModuleId);
    /**initialize the manager*/
    void Init();
    /**reset*/
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairRadMapManager object, created
     * with FairRadMapManager::FairRadMapManager().
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] static FairRadMapManager* Instance();
    //  void GetGeoManager();
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/*
 * FairRingSorter.h
 *
 *  Created on: Jul 15, 2010
 *      Author: stockman
 */

#ifndef FairRingSorter_H_
#define FairRingSorter_H_

#include <Rtypes.h>    // for FairRingSorter::Class, etc
#include <TObject.h>   // for TObject
#include <iostream>    // for operator<<, ostream, etc
#include <map>         // for multimap
#include <utility>     // for pair
#include <vector>      // for vector

class FairTimeStamp;

class FairRingSorter : public TObject
{
  public:
    FairRingSorter(int size = 100, double width = 10)
        : TObject()
        , fRingBuffer(size)
        , fOutputData()
        , fLowerBoundPointer(0, 0)
        , fCellWidth(width)
        , fVerbose(0)
    {}

    virtual ~FairRingSorter(){};

    virtual FairTimeStamp* CreateElement(FairTimeStamp* data);

    virtual void AddElement(FairTimeStamp* digi, double timestamp);
    virtual void WriteOutElements(int index);   ///< writes out the entries from LowerBoundPointer up to index
    virtual void WriteOutElement(int index);    ///< writes out the entry at the index and clears it
    virtual void WriteOutAll() { WriteOutElements(fLowerBoundPointer.first); }
    virtual double GetBufferSize() { return fCellWidth * fRingBuffer.size(); }
    virtual std::vector<FairTimeStamp*> GetOutputData() { return fOutputData; }

    virtual void DeleteOutputData() { fOutputData.clear(); }
    virtual void SetLowerBound(double timestampOfHitToWrite);

    virtual void print(std::ostream& out = std::cout)
    {
        out << "RingSorter: Size " << fRingBuffer.size() << " CellWidth: " << fCellWidth << "\n";
        out << "LowerBoundPointer at index: " << fLowerBoundPointer.first << " Time: " << fLowerBoundPointer.second
            << "\n";
        out << "| ";
        for (unsigned int i = 0; i < fRingBuffer.size(); i++) {
            out << fRingBuffer[i].size() << " |";
        }
        out << std::endl;
    }

  private:
    int CalcIndex(double val);
    std::vector<std::multimap<double, FairTimeStamp*>> fRingBuffer;
    std::vector<FairTimeStamp*> fOutputData;
    std::pair<int, double> fLowerBoundPointer;
    double fCellWidth;
    int fVerbose;

    ClassDef(FairRingSorter, 1);
};

#endif /* FairRingSorter_H_ */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

/** FairRingSorterTask.h
 **
 **/

#ifndef FairRingSorterTask_H
#define FairRingSorterTask_H

#include "FairRingSorter.h"   // for FairRingSorter
#include "FairTask.h"         // for FairTask, InitStatus

#include <Rtypes.h>    // for Bool_t, Int_t, kTRUE, etc
#include <TString.h>   // for TString

class FairTimeStamp;
class TClonesArray;

class FairRingSorterTask : public FairTask
{
  public:
    /** Default constructor **/
    FairRingSorterTask()
        : FairTask("SorterTask")
        , fSorter(0)
        , fPersistance(kTRUE)
        , fDigiPixelMCInfo(kFALSE)
        , fNumberOfCells(1000)
        , fWidthOfCells(10)
        , fInputBranch()
        , fInputArray(0)
        , fOutputBranch()
        , fFolder()
        , fOutputArray(0)
        , fEntryNr(0)
    {
        SetVerbose(0);
    }

    /** Named constructor **/
    FairRingSorterTask(const char* name)
        : FairTask(name)
        , fSorter(0)
        , fPersistance(kTRUE)
        , fDigiPixelMCInfo(kFALSE)
        , fNumberOfCells(1000)
        , fWidthOfCells(10)
        , fInputBranch()
        , fInputArray(0)
        , fOutputBranch()
        , fFolder()
        , fOutputArray(0)
        , fEntryNr(0)
    {
        SetVerbose(0);
    }

    FairRingSorterTask(Int_t numberOfCells,
                       Double_t widthOfCells,
                       TString inputBranch,
                       TString outputBranch,
                       TString folderName)
        : FairTask("Sorter")
        , fSorter(0)
        , fPersistance(kTRUE)
        , fDigiPixelMCInfo(kFALSE)
        , fNumberOfCells(numberOfCells)
        , fWidthOfCells(widthOfCells)
        , fInputBranch(inputBranch)
        , fInputArray(0)
        , fOutputBranch(outputBranch)
        , fFolder(folderName)
        , fOutputArray(0)
        , fEntryNr(0)
    {
        SetVerbose(0);
    }

    /** Destructor **/
    ~FairRingSorterTask() override { delete fSorter; }

    /** Virtual method Init **/
    InitStatus Init() override;
    InitStatus ReInit() override;

    /** Virtual method Exec **/
    void Exec(Option_t* opt) override;
    void FinishEvent() override;
    void FinishTask() override;

    void SetPersistance(Bool_t p = kTRUE) { fPersistance = p; };
    Bool_t GetPersistance() { return fPersistance; };

    virtual void AddNewDataToTClonesArray(FairTimeStamp* data);
    virtual FairRingSorter* InitSorter(Int_t numberOfCells, Double_t widthOfCells) const;

  protected:
    FairRingSorter* fSorter;
    /** switch to turn on/off storing the arrays to a file*/
    Bool_t fPersistance;
    /** switch to turn on/off storing additional MC Info of Digis*/
    Bool_t fDigiPixelMCInfo;
    Int_t fNumberOfCells;
    Double_t fWidthOfCells;   // in ns
    /** Input array of PndSdsPixelDigis **/
    TString fInputBranch;
    TClonesArray* fInputArray;
    /** Output array of sorted PndSdsDigis **/
    TString fOutputBranch;
    TString fFolder;
    TClonesArray* fOutputArray;
    Int_t fEntryNr;
    FairRingSorterTask(const FairRingSorterTask&);
    FairRingSorterTask& operator=(const FairRingSorterTask&);

    ClassDefOverride(FairRingSorterTask, 2);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIR_ROOT_MANAGER_H
#define FAIR_ROOT_MANAGER_H

#include "FairLogger.h"
#include "FairSink.h"
#include "FairSource.h"

#include <Rtypes.h>      // for Bool_t, Int_t, UInt_t, etc
#include <TChain.h>      // for TChain
#include <TObject.h>     // for TObject
#include <TRefArray.h>   // for TRefArray
#include <TString.h>     // for TString, operator<
#include <map>           // for map, multimap, etc
#include <memory>
#include <string>
#include <type_traits>   // is_pointer, remove_pointer, is_const, remove...
#include <typeinfo>
#include <vector>

class BinaryFunctor;
class FairEventHeader;
class FairFileHeader;
class FairLink;
class FairTSBufferFunctional;
class FairWriteoutBuffer;
class TBranch;
class TClonesArray;
class TObjArray;
class TCollection;
class TFile;
class TFolder;
class TList;
class TNamed;
class TTree;

/**
 * I/O Manager class
 * @author M. Al-Turany, Denis Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairRootManager : public TObject
{
  public:
    /**dtor*/
    ~FairRootManager() override;
    Bool_t AllDataProcessed();
    /** Add a branch name to the Branchlist and give it an id*/
    Int_t AddBranchToList(const char* name);
    /**
    Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist   */
    Int_t CheckBranch(const char* BrName);

    void CloseSink()
    {
        if (fSink) {
            fSink->Close();
        }
    }
    /**Create a new file and save the current TGeoManager object to it*/
    void CreateGeometryFile(const char* geofile);
    void Fill();
    void LastFill();
    TClonesArray* GetEmptyTClonesArray(TString branchName);
    TClonesArray* GetTClonesArray(TString branchName);
    /**Update the list of Memory branches from the source used*/
    void UpdateBranches();

    /**Return branch name by Id*/
    TString GetBranchName(Int_t id);
    /**Return Id of a branch named */
    Int_t GetBranchId(TString const& BrName);

    /**The MCTrack branch stands out since it is required by the framework algorithms**/
    Int_t GetMCTrackBranchId() const { return fMCTrackBranchId; }

    /**Return a TList of TObjString of branch names available in this session*/
    TList* GetBranchNameList() { return fBranchNameList; }

    /**  Get the Object (container) for the given branch name,
         this method can be used to access the data of
         a branch that was created from a different
         analysis task, and not written in the tree yet.
         the user have to cast this pointer to the right type.
         Return a pointer to the object (collection) saved in the fInChain branch named BrName*/
    TObject* GetObject(const char* BrName);

    /// Initializes and returns a default object for a branch or looks it up when it exists already.
    /// Returns nullptr when the branch does not exist or looking up with wrong type.
    /// The name Init indicates that this functions should be called only in Init sections of FairTasks.
    /// The returned default object will be filled with data by the framework.
    template<typename T>
    T InitObjectAs(const char* BrName);

    /** Return a pointer to the object (collection) saved in the fInTree branch named BrName*/
    Double_t GetEventTime();
    /** Returns a clone of the data object the link is pointing to. The clone has to be deleted in the calling code! */
    TObject* GetCloneOfLinkData(const FairLink link);
    /** Get the data of the given branch name,
     *  this method runs over multiple entries
     *  of the tree and selects the data according
     *  to the function and the parameter given.
     */

    TClonesArray* GetCloneOfTClonesArray(const FairLink link);

    void InitTSBuffer(TString branchName, BinaryFunctor* function);
    TClonesArray* GetData(TString branchName, BinaryFunctor* function, Double_t parameter);
    TClonesArray* GetData(TString branchName,
                          BinaryFunctor* startFunction,
                          Double_t startParameter,
                          BinaryFunctor* stopFunction,
                          Double_t stopParameter);
    void RegisterTSBuffer(TString branchName, FairTSBufferFunctional* functionalBuffer)
    {
        fTSBufferMap[branchName] = functionalBuffer;
    }
    void TerminateTSBuffer(TString branchName);
    void TerminateAllTSBuffer();
    FairTSBufferFunctional* GetTSBuffer(TString branchName) { return fTSBufferMap[branchName]; }

    /** static access method */
    static FairRootManager* Instance();

    /**Read a single entry from background chain*/
    Int_t ReadEvent(Int_t i = 0);
    /** Read a single entry from each branch that is not read via TSBuffers*/
    Int_t ReadNonTimeBasedEventFromBranches(Int_t i = 0);
    /**Read the tree entry on one branch**/
    void ReadBranchEvent(const char* BrName);
    /**Read the tree entry on one branch for a specific entry**/
    void ReadBranchEvent(const char* BrName, Int_t entry);

    /**Read all entries from input tree(s) with time stamp from current time to dt (time in ns)*/

    Int_t GetRunId();

    Bool_t ReadNextEvent(Double_t dt);
    /**create a new branch in the output tree
     *@param name            Name of the branch to create
     *@param Foldername      Folder name containing this branch (e.g Detector name)
     *@param obj             Pointer of type TNamed (e.g. MCStack object)
     *@param toFile          if kTRUE, branch will be saved to the tree*/
    void Register(const char* name, const char* Foldername, TNamed* obj, Bool_t toFile);
    /**create a new branch in the output tree
     *@param name            Name of the branch to create
     *@param Foldername      Folder name containing this branch (e.g Detector name)
     *@param obj             Pointer of type TCollection (e.g. TClonesArray of hits, points)
     *@param toFile          if kTRUE, branch will be saved to the tree*/
    void Register(const char* name, const char* Foldername, TCollection* obj, Bool_t toFile);

    /** create a new branch based on an arbitrary type T (for which a dictionary must exist) **/
    template<typename T>
    void RegisterAny(const char* name, T*& obj, Bool_t toFile);

    void RegisterInputObject(const char* name, TObject* obj);

    TClonesArray* Register(TString branchName, TString className, TString folderName, Bool_t toFile);
    /** Register a new FairWriteoutBuffer to the map. If a Buffer with the same map key already exists the given buffer
     * will be deleted and the old will be returned!*/
    FairWriteoutBuffer* RegisterWriteoutBuffer(TString branchName, FairWriteoutBuffer* buffer);
    /**Update the list of time based branches in the output file*/
    void UpdateListOfTimebasedBranches();
    /**Use time stamps to read data and not tree entries
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] void RunWithTimeStamps() {}

    /**Set the branch name list*/
    void SetBranchNameList(TList* list);
    /** Replace the time based branch name list*/
    void SetTimeBasedBranchNameList(TList* list);

    /** \deprecated Deprecated in v18.8, will be removed in v20. */
    [[deprecated]] void FillEventHeader(FairEventHeader* feh)
    {
        if (fSource)
            fSource->FillEventHeader(feh);
    }

    /**Enables a last Fill command after all events are processed to store any data which is still in Buffers*/
    void SetLastFill(Bool_t val = kTRUE) { fFillLastData = val; }
    /**When creating TTree from TFolder the fullpath of the objects is used as branch names
     * this method truncate the full path from the branch names
     */

    Int_t Write(const char* name = nullptr, Int_t option = 0, Int_t bufsize = 0) override;
    /** Write the current TGeoManager to file*/
    void WriteGeometry();
    /**Write the file header object to the output file*/
    void WriteFileHeader(FairFileHeader* f);
    /**Write the folder structure used to create the tree to the output file */
    void WriteFolder();

    /**Check the maximum event number we can run to*/
    Int_t CheckMaxEventNo(Int_t EvtEnd = 0);

    void StoreWriteoutBufferData(Double_t eventTime);
    void StoreAllWriteoutBufferData();
    void DeleteOldWriteoutBufferData();

    Int_t GetEntryNr() { return fEntryNr; }
    void SetEntryNr(Int_t val) { fEntryNr = val; }

    void SetUseFairLinks(Bool_t val) { fUseFairLinks = val; };
    Bool_t GetUseFairLinks() const { return fUseFairLinks; };

    /**
     * @param Status : if  true all inputs are mixed, i.e: each read event will take one entry from each input and put
     * them in one big event and send it to the next step
     */
    /* void SetMixAllInputs(Bool_t Status) { */
    /*    fMixAllInputs=kTRUE; */
    /* } */

    /** These methods have been moved to the FairFileSource */
    void SetSource(FairSource* tempSource) { fSource = tempSource; }
    FairSource* GetSource() { return fSource; }
    Bool_t InitSource();

    void SetSink(FairSink* tempSink) { fSink = tempSink; }
    FairSink* GetSink() { return fSink; }
    Bool_t InitSink();

    void SetListOfFolders(TObjArray* ta) { fListFolder = ta; }
    TChain* GetInChain() { return fSourceChain; }
    TChain* GetSignalChainNo(UInt_t i) { return fSignalChainList[i]; }
    TTree* GetInTree()
    {
        if (fSourceChain)
            return fSourceChain->GetTree();
        return 0;
    }
    const TFile* GetRootFile()
    {
        if (fSourceChain)
            return fSourceChain->GetFile();
        return 0;
    }
    TFile* GetInFile()
    {
        if (fSourceChain)
            return fSourceChain->GetFile();
        return 0;
    }
    void SetInChain(TChain* tempChain, Int_t ident = -1);
    /* /\**Set the input tree when running on PROOF worker*\/ */

    void SetFinishRun(Bool_t val = kTRUE) { fFinishRun = val; }
    Bool_t FinishRun() { return fFinishRun; }

    static void SetTreeName(const std::string& tname) { fTreeName = tname; }
    static void SetFolderName(const std::string& tname) { fFolderName = tname; }

    const static char* GetTreeName();
    const static char* GetFolderName();

    /**public Members for multi-threading */
    Int_t GetInstanceId() const { return fId; }
    void UpdateFileName(TString& fileName);

    /** Return a pointer to the output File of type TFile */
    TFile* GetOutFile();
    /** Return a pointer to the output tree of type TTree */
    TTree* GetOutTree();

    /**Read one event from source to find out which RunId to use*/
    Bool_t SpecifyRunId();

  private:
    // helper struct since std::pair has problems with type_info
    struct TypeAddressPair
    {
        TypeAddressPair(const std::type_info& oi, const std::type_info& pi, void* a)
            : origtypeinfo(oi)
            , persistenttypeinfo(pi)
            , ptraddr(a)
        {}
        const std::type_info& origtypeinfo;         // type_info of type addr points to
        const std::type_info& persistenttypeinfo;   // type_info of ROOT persistent branch (drops pointers)
        void* ptraddr;                              // address of a pointer (pointing to origtypeinfo);
    };

    /**private methods*/
    /**ctor*/
    FairRootManager();
    FairRootManager(const FairRootManager&);
    FairRootManager& operator=(const FairRootManager&);
    /**  Set the branch address for a given branch name and return
        a TObject pointer, the user have to cast this pointer to the right type.*/
    TObject* ActivateBranch(const char* BrName);
    void AddFriends();
    /**Add a branch to memory, it will not be written to the output files*/
    void AddMemoryBranch(const char*, TObject*);

    template<typename T>
    void AddMemoryBranchAny(const char* name, T** obj);
    template<typename T>
    T GetMemoryBranchAny(const char* name) const;

    template<typename T>
    void RegisterImpl(const char* name, const char* Foldername, T* obj, Bool_t toFile);

    /** Internal Check if Branch persistence or not (Memory branch)
    return value:
    1 : Branch is Persistance
    2 : Memory Branch
    0 : Branch does not exist
    */
    Int_t CheckBranchSt(const char* BrName);
    /**Create the Map for the branch persistency status  */
    void CreatePerMap();
    TObject* GetMemoryBranch(const char*);
    //   void                GetRunIdInfo(TString fileName, TString inputLevel);

    FairWriteoutBuffer* GetWriteoutBuffer(TString branchName);

    // private helper function to emit a warning
    void EmitMemoryBranchWrongTypeWarning(const char* brname, const char* typen1, const char* typen2) const;

    /**private Members*/
    Int_t fOldEntryNr;
    /**folder structure of output*/
    TFolder* fOutFolder;
    /**folder structure of input*/
    TFolder* fRootFolder;
    /** current time in ns*/
    Double_t fCurrentTime;
    TObject** fObj2;   //!
    /** Counter for the number of branches activiated */
    Int_t fNObj;   //!
    /** A list which hold the pointer to the branch
     * and the name of the branch in memory, it contains all branches (TClonesArrays)
     * persistance and Memory only branches
     */
    std::map<TString, TObject*> fMap;   //!

    /**folder name variable*/
    static std::string fFolderName;   //!
    /**tree name variable*/
    static std::string fTreeName;   //!
    static std::string GetNameFromFile(const char* namekind);

    /// A map of branchnames to typeinformation + memory address;
    /// used for branches registered with RegisterAny; use of ptr here
    /// since type_info cannot be copied
    std::map<std::string, std::unique_ptr<TypeAddressPair const>> fAnyBranchMap;   //!

    /**Branch id for this run */
    Int_t fBranchSeqId;
    /**List of branch names as TObjString*/
    TList* fBranchNameList;   //!

    /**The branch ID for the special (required) MCTrack branch**/
    Int_t fMCTrackBranchId;   //!

    /**List of Time based branchs names as TObjString*/
    TList* fTimeBasedBranchNameList;   //!
    /** Internally used to compress empty slots in data buffer*/
    std::map<TString, TClonesArray*> fActiveContainer;
    /** Internally used to read time ordered data from branches*/
    std::map<TString, FairTSBufferFunctional*> fTSBufferMap;     //!
    std::map<TString, FairWriteoutBuffer*> fWriteoutBufferMap;   //!
    std::map<Int_t, TBranch*> fInputBranchMap;                   //!    //Map of input branch ID with TBranch pointer
    /**Flag for creation of Map for branch persistency list  */
    Bool_t fBranchPerMap;
    /** Map for branch persistency list */
    std::map<TString, Int_t> fBrPerMap;   //!

    /** for internal use, to return the same event time for the same entry*/
    UInt_t fCurrentEntryNo;   //!
    /** for internal use, to return the same event time for the same entry*/
    UInt_t fTimeforEntryNo;   //!
    Bool_t fFillLastData;     //!
    Int_t fEntryNr;           //!

    TObjArray* fListFolder;   //!

    FairSource* fSource;

    TChain* fSourceChain = nullptr;
    std::map<UInt_t, TChain*> fSignalChainList;   //!

    FairEventHeader* fEventHeader;

    FairSink* fSink;

    Bool_t fUseFairLinks;   //!
    Bool_t fFinishRun;      //!
    /** List of branches used with no-time stamp in time-based session */
    TRefArray fListOfNonTimebasedBranches{};   //!

    /**private Members for multi-threading */
    // global static data members
    static Int_t fgCounter;   // The counter of instances
    // data members
    Int_t fId;   // This manager ID

    ClassDefOverride(FairRootManager, 14);
};

// FIXME: move to source since we can make it non-template dependent
template<typename T>
void FairRootManager::AddMemoryBranchAny(const char* brname, T** obj)
{
    if (fAnyBranchMap.find(brname) == fAnyBranchMap.end()) {
        auto& ot = typeid(T*);
        auto& pt = typeid(T);
        fAnyBranchMap[brname] = std::unique_ptr<TypeAddressPair const>(new TypeAddressPair(ot, pt, (void*)obj));
    }
}

// try to retrieve an object address from the registered branches/names
template<typename T>
T FairRootManager::GetMemoryBranchAny(const char* brname) const
{
    static_assert(std::is_pointer<T>::value, "Return type of GetMemoryBranchAny has to be a pointer");
    using P = typename std::remove_pointer<T>::type;
    auto iter = fAnyBranchMap.find(brname);
    if (iter != fAnyBranchMap.end()) {
        // verify type consistency
        if (typeid(P).hash_code() != iter->second->origtypeinfo.hash_code()) {
            EmitMemoryBranchWrongTypeWarning(brname, typeid(P).name(), iter->second->origtypeinfo.name());
            return nullptr;
        }
        return static_cast<T>(iter->second->ptraddr);
    }
    return nullptr;
}

template<typename T>
void FairRootManager::RegisterAny(const char* brname, T*& obj, bool persistence)
{
    AddBranchToList(brname);
    // we are taking the address of the passed pointer
    AddMemoryBranchAny<T>(brname, &obj);
    if (persistence) {
        auto& ot = typeid(T*);
        auto& pt = typeid(T);
        if (fSink)
            fSink->RegisterAny(brname, ot, pt, &obj);
        else
            LOG(fatal) << "The sink does not exist to store persistent branches.";
    }
}

// this function serves as a factory (or lookup) for memory managed
// instances associated to branches
// it returns a pointer to unmodifiable instance of T
template<typename TPtr>
TPtr FairRootManager::InitObjectAs(const char* brname)
{
    static_assert(std::is_pointer<TPtr>::value, "Return type of GetObjectAs has to be a pointer");
    using X = typename std::remove_pointer<TPtr>::type;
    static_assert(std::is_const<X>::value, "Return type of GetObjectAs has to be pointer to const class");
    using T = typename std::remove_const<X>::type;

    // is there already an object associated to the branch in memory??
    // then just return
    T** obj = GetMemoryBranchAny<T**>(brname);
    // obj is some address/instance holding TPtr instances
    if (obj != nullptr)
        return *obj;

    if (!fSource) {
        return nullptr;
    }

    // it does not seem to be the case, let us create the pointer which will be initialized
    // with the data (pointer to T)
    T** addr = new T*;
    // init the pointee to a default obj which we can return
    (*addr) = new T;
    // try to find and activate in the source
    auto succeeded = fSource->ActivateObjectAny((void**)addr, typeid(T), brname);

    if (!succeeded) {
        delete (*addr);
        delete addr;
        return nullptr;
    }
    // add into branch list
    AddMemoryBranchAny<T>(brname, addr);

    // NOTE: ideally we would do proper resource management for addr and *addr
    // since the FairRootManager becomes owner of these pointers/instances; Unfortunately this
    // is quite a difficult task since we would have to store something like std::unique_ptr<T> in a member
    // container which we cannot know a priori; Some solutions we could think of in the future are
    // a) use the Destructor mechanism of ROOT::TClass since we still have the type info.
    // b) investigate if boost::any could be of help here
    // In any case, this problem is not very critical in the sense that FairRootManager is a singleton and hence
    // cannot really leak memory (Assuming that the destructors of T are not doing something non-trivial).
    return *addr;
}

#endif   // FAIR_ROOT_MANAGER_H
/********************************************************************************
 * Copyright (C) 2014-2023 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUN_H
#define FAIRRUN_H

#include "FairAlignmentHandler.h"
#include "FairEventHeader.h"
#include "FairSink.h"
#include "FairSource.h"

#include <Rtypes.h>   // for Int_t, Bool_t, etc
#include <TMCtls.h>   // for multi-threading
#include <TNamed.h>   // for TNamed
#include <TString.h>
#include <map>
#include <memory>
#include <string>

class FairEventHeader;
class FairFileHeader;
class FairRootManager;
class FairRuntimeDb;
class FairSink;
class FairTask;
class TFile;
class FairField;
class TGeoHMatrix;

/**
 * Configure the Simuation or Analysis
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */

class FairRun : public TNamed
{
    friend class FairMCApplication;

  public:
    /**
     * default ctor
     */
    FairRun(Bool_t isMaster = kTRUE);
    /**
     * default dtor
     */
    ~FairRun() override;
    /**
     * static instance
     */
    static FairRun* Instance();
    /**
     * Add a FAIRTask to the simulation or analysis
     */
    virtual void AddTask(FairTask* t);
    virtual void StoreTaskNames(const FairTask* t);
    virtual void SetTask(FairTask* t);
    /**
     * Initialize the Simulation or analysis
     */
    virtual void Init() = 0;
    /*
     * Get the magnetic field *
     */
    virtual FairField* GetField() = 0;
    /**
     * run the analysis or simulation
     */
    virtual void Run(Int_t NStart = 0, Int_t NStop = 0) = 0;
    /**
     *       Set the experiment dependent run header
     *       for each run
     */
    void SetEventHeader(FairEventHeader* EvHeader) { fEvtHeader = EvHeader; }
    /**
     * return a pointer to the RuntimeDB
     */
    FairRuntimeDb* GetRuntimeDb() { return fRtdb; }
    /**
     * Set the sink
     */
    void SetSink(std::unique_ptr<FairSink> newsink);
    void SetSink(FairSink* tempSink);
    /**
     * return a non-owning pointer to the sink
     */
    FairSink* GetSink() { return fSink.get(); }
    /**
     * return the run ID for the actul run
     */
    Int_t GetRunId() { return (static_cast<Int_t>(fRunId)); }

    /**
     * Set the Run ID
     */
    void SetRunId(UInt_t runId) { fRunId = runId; }

    /**Get the detector specific run header*/
    FairEventHeader* GetEventHeader();
    /**
     * return true for Anaylsis session
     */
    Bool_t IsAna() { return fAna; }
    /**
     *Get task by name
     */

    FairTask* GetTask(const char* taskName);
    /**
     *Get Main Task
     */
    FairTask* GetMainTask() { return fTask; }
    /**
     * Return the number of Tasks added to this Run
     */
    Int_t GetNTasks() { return fNTasks; }

    /**Create a new file and save the TGeoManager to it*/
    void CreateGeometryFile(const char* geofile);

    /**
     * Set if RunInfo file should be written
     * \deprecated Use SetGenerateRunInfo() instead.
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] void SetWriteRunInfoFile(Bool_t write);

    //** Set if RunInfo should be generated */
    void SetGenerateRunInfo(Bool_t write) { fGenerateRunInfo = write; }

    /**
     * Get info if RunInfo file is written
     * \deprecated Use \ref IsRunInfoGenerated() instead.
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] Bool_t GetWriteRunInfoFile();

    //** Get info if RunInfo file is written */
    Bool_t IsRunInfoGenerated() { return fGenerateRunInfo; }

    //** Switches the use of FairLinks */
    void SetUseFairLinks(Bool_t val);

    //** Get info if run on master */
    Bool_t GetIsMaster() const { return fIsMaster; }

    //** Mark/Unmark event to be filled into output. Default is TRUE. */
    void MarkFill(Bool_t flag) { fMarkFill = flag; }

    //** Get option string */
    TString GetOptions() { return fOptions; };

    //** Set option string */
    void SetOptions(const TString& s) { fOptions = s; };

    /**
     * Set the output file name for analysis or simulation
     * \deprecated Use \ref FairSink and \ref SetSink().
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] virtual void SetOutputFile(const char* fname);
    /**
     * Set the output file for analysis or simulation
     * \deprecated Use \ref FairSink and \ref SetSink().
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] virtual void SetOutputFile(TFile* f);
    /**
     * Set the  output file name without creating the file
     * \deprecated Use \ref FairSink and \ref SetSink().
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] void SetOutputFileName(const TString& name);
    /**
     * \deprecated Use \ref FairSink and \ref SetSink().
     *   Deprecated pre-v19, will be removed in v20.
     */
    [[deprecated]] TFile* GetOutputFile();

    /**
     * New functions which allow to postpone creating a new Sink in MT
     * to be kept after clean-up of deprecated functions above
     */
    void SetUserOutputFileName(const TString& name);
    TString GetUserOutputFileName() const;

    void AddAlignmentMatrices(const std::map<std::string, TGeoHMatrix>& alignmentMatrices, bool invertMatrices = false);

    /**
     * \brief Set the input signal file
     *
     * Takes an owning pointer!
     */
    virtual void SetSource(FairSource* tempSource);
    /** Return non-owning pointer to source **/
    FairSource* GetSource() { return fSource.get(); }
    FairRootManager& GetRootManager() { return *fRootManager; }
    FairRootManager const& GetRootManager() const { return *fRootManager; }

  private:
    FairRun(const FairRun& M);
    FairRun& operator=(const FairRun&) { return *this; }
    /** Number of Tasks added*/
    Int_t fNTasks;

  protected:
    /** static pointer to this run*/
    static TMCThreadLocal FairRun* fRunInstance;
    /** RuntimeDb*/
    FairRuntimeDb* fRtdb;
    /** Tasks used*/
    FairTask* fTask;
    /**IO manager */
    FairRootManager* fRootManager;
    /**Output sink*/
    std::unique_ptr<FairSink> fSink{};   //!
    /**Output file name set by user*/
    TString fUserOutputFileName;
    /**Options for derived classes, to be set & parsed by user*/
    TString fOptions;
    /**Run Id*/
    UInt_t fRunId;   //!
    /** true for Anaylsis session*/
    Bool_t fAna;   //!
    /** MC Event Header */
    FairEventHeader* fEvtHeader;   //!
    /** File  Header */
    FairFileHeader* fFileHeader;
    /** true if RunInfo file should be written*/
    Bool_t fGenerateRunInfo;   //!
    /** true if on master*/
    Bool_t fIsMaster;   //!

    Bool_t fMarkFill;   //!

    FairAlignmentHandler fAlignmentHandler;

    std::unique_ptr<FairSource> fSource{};   //!

    void AlignGeometry() const;
    /**
     * Call FillEventHeader on the source
     */
    void FillEventHeader()
    {
        if (fSource)
            fSource->FillEventHeader(fEvtHeader);
    }

    /**
     * Get the RunId of the Event Header
     */
    UInt_t GetEvtHeaderRunId() const { return fEvtHeader->GetRunId(); }

    ClassDefOverride(FairRun, 5);
};
#endif   // FAIRRUN_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANA_H
#define FAIRRUNANA_H

/**
 * Configure and manage the  Analysis
 * @author M. Al-Turany D. Bertini
 * @version 0.1
 * @since 28.02.05
 */

#include "FairRootManager.h"   // for FairRootManager
#include "FairRun.h"           // for FairRun
#include "FairRunInfo.h"       // for FairRunInfo

#include <Rtypes.h>    // for Bool_t, Double_t, UInt_t, etc
#include <TString.h>   // for TString

class FairField;
class TF1;
class TFile;

class FairSource;
class FairFileSource;
class FairMixedSource;

class FairRunAna : public FairRun
{

  public:
    static FairRunAna* Instance();
    virtual ~FairRunAna();
    FairRunAna();
    /**initialize the run manager*/
    void Init() override;
    /**Run from event number NStart to event number NStop */
    void Run(Int_t NStart = 0, Int_t NStop = 0) override;
    /**Run over the whole input file with timpe window delta_t as unit (entry)*/
    void Run(Double_t delta_t);
    /**Run for the given single entry*/
    void Run(Long64_t entry);
    /**Run event reconstruction from event number NStart to event number NStop */
    void RunEventReco(Int_t NStart, Int_t NStop);
    /**Run over all TSBuffers until the data is processed*/
    void RunTSBuffers();
    /** the dummy run does not check the evt header or the parameters!! */
    void DummyRun(Int_t NStart, Int_t NStop);
    /** This methode is only needed and used with ZeroMQ
     * it read a certain event and call the task exec, but no output is written
     * @param entry : entry number in the tree
     */
    void RunMQ(Long64_t entry);
    /** Run on a list of lmd files*/
    void RunOnLmdFiles(UInt_t NStart = 0, UInt_t NStop = 0);

    void RunOnTBData();
    /** finish tasks, write output*/
    void TerminateRun();

    /** Switch On/Off the storing of FairEventHeader in output file*/
    void SetEventHeaderPersistence(Bool_t flag) { fStoreEventHeader = flag; }

    void Reinit(UInt_t runId);
    UInt_t getRunId() { return fRunId; }
    /** Get the magnetic field **/
    FairField* GetField() override { return fField; }
    /** Set the magnetic Field */
    void SetField(FairField* ffield) { fField = ffield; }
    /** Set external geometry file */
    void SetGeomFile(const char* GeoFileName);
    /** Return a pointer to the geometry file */
    TFile* GetGeoFile() { return fInputGeoFile; }
    /** Initialization of parameter container is set to static, i.e: the run id is
     *  is not checked anymore after initialization
     */

    void SetContainerStatic(Bool_t tempBool = kTRUE);
    Bool_t GetContainerStatic() { return fStatic; };
    void RunWithTimeStamps();
    Bool_t IsTimeStamp() { return fTimeStamps; }

    /** Set the flag for proccessing lmd files */
    void StopProcessingLMD(void) { fFinishProcessingLMDFile = kTRUE; }
    /** Get the status of lmd file proccessing */
    Bool_t GetLMDProcessingStatus(void) { return fFinishProcessingLMDFile; }

  protected:
    /**
     * Virtual function which calls the Fill function of the IOManager.
     * Allows to override the function with an experiment specific version.
     **/
    virtual void Fill();

  private:
    FairRunAna(const FairRunAna& M);
    FairRunAna& operator=(const FairRunAna&) { return *this; }

    FairRunInfo fRunInfo;   //!

  protected:
    /** This variable became true after Init is called*/
    Bool_t fIsInitialized;
    TFile* fInputGeoFile;
    static FairRunAna* fgRinstance;
    Bool_t fLoadGeo;
    /** true for static initialisation of parameters */
    Bool_t fStatic;   //!
    FairField* fField;
    Bool_t fTimeStamps;
    Bool_t fInFileIsOpen;   //!
    /** min time for one event (ns) */
    Double_t fEventTimeMin;   //!
    /** max time for one Event (ns) */
    Double_t fEventTimeMax;   //!
    /** Time of event since th start (ns) */
    Double_t fEventTime;   //!
    /** EventMean time used (P(t)=1/fEventMeanTime*Exp(-t/fEventMeanTime) */
    Double_t fEventMeanTime;   //!
    /** used to generate random numbers for event time; */
    TF1* fTimeProb;   //!
    /** Flag for proccessing lmd-files*/
    Bool_t fFinishProcessingLMDFile;   //!

    /** Temporary member to preserve old functionality without setting source in macro */
    FairFileSource* fFileSource;   //!
    /** Temporary member to preserve old functionality without setting source in macro */
    FairMixedSource* fMixedSource;   //!
    /** Flag for Event Header Persistency */
    Bool_t fStoreEventHeader;   //!

    ClassDefOverride(FairRunAna, 6);
};

#endif   // FAIRRUNANA_H
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNSIM_H
#define FAIRRUNSIM_H

#include "FairGenericVMCConfig.h"
#include "FairIon.h"             // for FairIon
#include "FairMCApplication.h"   // for FairMCApplication
#include "FairParticle.h"        // for FairParticle
#include "FairRun.h"             // for FairRun

#include <Rtypes.h>      // for Bool_t, Double_t, Int_t, etc
#include <TMCtls.h>      // for multi-threading
#include <TObjArray.h>   // for TObjArray
#include <TString.h>     // for TString
#include <functional>
#include <memory>
#include <utility>

class FairField;
class FairMCEventHeader;
class FairMesh;
class FairModule;
class FairPrimaryGenerator;

/**
 * \brief Configure the Simulation session
 * \ingroup base_steer
 * @author M. Al-Turany  D. Bertini
 * @version 0.1
 * @since 12.01.04
 */
class FairRunSim : public FairRun
{
  public:
    /** default ctor*/
    FairRunSim(Bool_t isMaster = kTRUE);
    /** default dtor*/
    ~FairRunSim() override;
    /** Singelton instance*/
    static FairRunSim* Instance();
    /**
     *       Add a module to the simulation (e.g. PIPE, Magnet, ..etc)
     */
    void AddModule(FairModule* Mod);
    /**
     *       Add a user defined ion to the simulation
     */
    void AddNewIon(FairIon* ion) { fIons->Add(ion); }
    /**
     *       Add a user defined ion to the simulation
     */
    void AddNewParticle(FairParticle* Particle) { fParticles->Add(Particle); }
    /**
     *       this method is used by the FAIRMCApplication
     */
    TObjArray* GetUserDefIons();
    /**
     *       this method is used by the FAIRMCApplication
     */
    TObjArray* GetUserDefParticles();

    /**
     *       Initialize the Simulation
     */
    void Init() override;
    /**
     *       run the  simulation
     */
    void Run(Int_t NEvents = 0, Int_t NotUsed = 0) override;
    /**
     *       Set the magnetic that has to be used for simulation field
     */
    void SetField(FairField* field);
    /**
     *       Set the event generator that has to be used for simulation field
     */
    void SetGenerator(FairPrimaryGenerator* Gen);

    /**
     *       Set the experiment dependent event header
     *       for each Monte Carlo Event
     */
    void SetMCEventHeader(FairMCEventHeader* McHeader) { fMCEvHead = McHeader; }

    /** Set the material file name to be used */
    void SetMaterials(const char* MatFileName);

    /**switch On/Off the track visualisation */
    void SetStoreTraj(Bool_t storeTraj = kTRUE) { fStoreTraj = storeTraj; }

    /**Return the switch for the track visualisation */
    Bool_t GetStoreTraj() const { return fStoreTraj; }

    /**switch On/Off the debug mode */
    void SetTrackingDebugMode(Bool_t set)
    {
        if (fApp) {
            fApp->SetTrackingDebugMode(set);
        }
    }

    /**Set geometry builder*/
    void SetGeoModel(const char* name);

    /**return the geometry loader used in this session*/
    TString* GetGeoModel() { return &fLoaderName; }

    /**Get the field used in simulation*/
    FairField* GetField() override { return fField; }

    /**Get the detector specific event header*/
    FairMCEventHeader* GetMCEventHeader();

    /**return the full list of modules used in simulation*/
    TObjArray* GetListOfModules() { return ListOfModules; }

    /**Get the used primary generator*/
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    FairPrimaryGenerator* GetPrimaryGenerator() { return fGen; }
#pragma GCC diagnostic pop

    /**switch On/Off external decayer (Pythia) */
    void SetPythiaDecayer(Bool_t decayer) { fPythiaDecayer = decayer; }

    /**switch On external decayer (Pythia). Config macro will be used */
    void SetPythiaDecayer(const TString& Config);

    /**switch On user defined decay, Config  macro will be called  */
    void SetUserDecay(const TString& Config);

    /**switch On/Off user defined decay if true gconfig/UserDecay.C macro will be called  */
    void SetUserDecay(Bool_t decay) { fUserDecay = decay; }

    /**Flag for external decayer*/
    Bool_t IsExtDecayer() { return fPythiaDecayer; }

    /**Flag for User decay*/
    Bool_t IsUserDecay() { return fUserDecay; }

    /**Switch on/off Radiation length register */
    void SetRadLenRegister(Bool_t value) { fRadLength = value; }

    void SetRadMapRegister(Bool_t value) { fRadMap = value; }

    void SetRadGridRegister(Bool_t value) { fRadGrid = value; }

    void AddMesh(FairMesh* Mesh);

    void SetUserConfig(const TString& Config) { fUserConfig = Config; }
    TString GetUserConfig() { return fUserConfig; }

    void SetUserCuts(const TString& Cuts) { fUserCuts = Cuts; }
    TString GetUserCuts() { return fUserCuts; }

    /** Set Beam energy in GeV/c */
    void SetBeamMom(Double_t BeamMom)
    {
        fBeamMom = BeamMom;
        fUseBeamMom = kTRUE;
    }

    /** Get the Beam energy */
    Double_t GetBeamMom() { return fBeamMom; }

    /**Get beam energy flag */
    Bool_t UseBeamMom() { return fUseBeamMom; }
    void SetFieldContainer();

    void SetSimSetup(std::function<void()> f)
    {
        fSimSetup = f;
        fUseSimSetupFunction = true;
    }
    void SetSimSetupPostInit(std::function<void()> f)
    {
        fSimSetupPostInit = f;
        fUseSimSetupPostInitFunction = true;
    }

    void SetSimulationConfig(std::unique_ptr<FairGenericVMCConfig> tconf) { fSimulationConfig = std::move(tconf); }
    /**
     * Get non-owning pointer
     */
    FairGenericVMCConfig* GetSimulationConfig() { return fSimulationConfig.get(); }

    void SetIsMT(Bool_t isMT) { fIsMT = isMT; }
    Bool_t IsMT() const { return fIsMT; }

    void SetImportTGeoToVMC(Bool_t v) { fImportTGeoToVMC = v; }
    Bool_t IsImportTGeoToVMC() const { return fImportTGeoToVMC; }

    void StopMCRun() { fApp->StopMCRun(); }

    /**
     * Get non-owning pointer to FairMCApplication
     */
    auto GetMCApplication() { return fApp; }

  private:
    FairRunSim(const FairRunSim& M);
    FairRunSim& operator=(const FairRunSim&) { return *this; }
    void SetMCConfig();
    void CheckFlukaExec();

  protected:
    Int_t count{0};                     //!< Internal counter
    FairMCApplication* fApp{nullptr};   //!< Main VMC application
    Double_t fBeamMom{0};               //!< Beam Energy in GeV/c
    Bool_t fUseBeamMom{kFALSE};         //!< flag for use Beam Energy
    /**
     * Primary Event Generator
     *
     * \deprecated Use \ref GetPrimaryGenerator() / \ref SetGenerator()
     * \deprecated Deprecated in v18.8, will be removed in v19.2.
     */
    [[deprecated("Use Setter/Getter")]] FairPrimaryGenerator* fGen{nullptr};   //!

    FairMCEventHeader* fMCEvHead;                   //!                          /** MC Event Header */
    static TMCThreadLocal FairRunSim* fginstance;   //!              /** Singleton Instance */
    FairField* fField;                              /** Magnetic Field */
    TObjArray* fIons;                               //!                              /** Array of user defined ions */
    TObjArray* fParticles;                          //!                         /** Array of user defined particles*/
    TObjArray* ListOfModules;                       //!                       /** Array of used modules */
    TString MatFname;                               //!                           /** Material file name */
    Bool_t fStoreTraj;                              //!                       /** Trajectory store flags */
    TString fLoaderName{"TGeo"};                    //!< Geometry Model (TGeo or G3)
    Bool_t fPythiaDecayer;                          //!                    /** flag for using Pythia decayer*/
    TString fPythiaDecayerConfig;                   //!               /** Macro for Pythia decay configuration*/
    Bool_t fUserDecay;                              /** flag for setting user decay */
    TString fUserDecayConfig;                       //!                   /** Macro for decay configuration*/
    Bool_t fRadLength;                              //!                       /** flag for registring radiation length*/
    Bool_t fRadMap;                                 //!                            /** flag for RadiationMapManager
    Bool_t fRadGrid;                                //!
    TObjArray* fMeshList;                           //!                          /** radiation grid scoring
    TString fUserConfig;                            //!                        /** Macro for geant configuration*/
    TString fUserCuts;                              //!                          /** Macro for geant cuts*/
    Bool_t fIsMT;                                   //!                              /** MT mode option (Geant4 only)*/
    Bool_t fImportTGeoToVMC;                        //!                   /** Allow importing TGeometry to VMC */
    std::function<void()> fSimSetup;   //!                          /** A user provided function to do sim setup /
                                       //!                          instead of using macros **/
    bool fUseSimSetupFunction = false;
    std::function<void()> fSimSetupPostInit;   //!                          /** A user provided function to do sim setup
                                               //!                          / instead of using macros **/
    bool fUseSimSetupPostInitFunction = false;
    std::unique_ptr<FairGenericVMCConfig> fSimulationConfig{};   //!                 /** Simulation configuration */

    ClassDefOverride(FairRunSim, 2);
};

#endif   // FAIRRUNSIM_H
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----                      FairTask header file                      -----
// -----          Created 12/01/04  by M. Al-Turany / D. Bertini       -----
// -------------------------------------------------------------------------

/** FairTask
 * @author M. Al-Turany, Denis Bertini
 * @since 12.01.04
 **
 ** Base class for tasks in the cbmroot framework.
 ** Derived classes should implement the Exec method.
 **/

#ifndef FAIRTASK_H
#define FAIRTASK_H

#include <Rtypes.h>    // for Int_t, FairTask::Class, etc
#include <TString.h>   // for TString
#include <TTask.h>     // for TTask
#include <map>

class FairLogger;

enum InitStatus
{
    kSUCCESS,
    kERROR,
    kFATAL
};

/**
 * \ingroup base_steer
 */
class FairTask : public TTask
{
  public:
    /** Default constructor **/
    FairTask();

    /** Standard constructor
     *@param name        Name of task
     *@param iVerbose    Verbosity level
     **/
    FairTask(const char* name, Int_t iVerbose = 1);

    FairTask(const FairTask&) = delete;
    FairTask& operator=(const FairTask&) = delete;
    FairTask(FairTask&&) = delete;
    FairTask& operator=(FairTask&&) = delete;

    /** Destructor **/
    ~FairTask() override;

    /** Initialisation at begin of run. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void InitTask();

    /** Reinitialisation. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void ReInitTask();

    /** Set parameters. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    void SetParTask();

    /** Action at end of run. For this task and all of the subtasks.
        Method used internally in FairRoot. **/
    virtual void FinishTask();

    /** Action at end of event. For this task and all of the subtasks. **/
    virtual void FinishEvent();

    /** Set verbosity level. For this task and all of the subtasks. **/
    void SetVerbose(Int_t iVerbose);

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] void SetInputPersistance(Bool_t val) { fInputPersistance = val; }
#pragma GCC diagnostic pop

    /**
     * \deprecated Deprecated in v18.8, will be removed in v20.
     */
    [[deprecated]] void CheckInputPersistance(TString branchName);

    void ExecuteTask(Option_t* option = "0") override;   // *MENU*

    /** Set persistency of branch with given name true or false
     *  In case is is set to false the branch will not be written to the output.
     **/
    void SetOutputBranchPersistent(TString, Bool_t);

    /** Check if the branch with the given name is persistent.
     *  If the branch is not in the map, the default return value is true.
     **/
    Bool_t IsOutputBranchPersistent(TString);

    void SetStreamProcessing(Bool_t val = kTRUE) { fStreamProcessing = val; }

  protected:
    Int_t fVerbose;                           //  Verbosity level
    [[deprecated]] Int_t fInputPersistance;   ///< \deprecated Deprecated in v18.8, will be removed in v20.
    FairLogger* fLogger;                      //!
    Bool_t fStreamProcessing;

    /** Intialisation at begin of run. To be implemented in the derived class.
     * \retval  kSUCCESS   If not kSUCCESS, task will be set inactive.
     **/
    virtual InitStatus Init() { return kSUCCESS; };

    /** Reinitialisation. To be implemented in the derived class.
     * \retval  kSUCCESS   If not kSUCCESS, task will be set inactive.
     **/
    virtual InitStatus ReInit() { return kSUCCESS; };

    /** Intialise parameter containers.
        To be implemented in the derived class.
    **/
    virtual void SetParContainers(){};

    /** Action at end of run. For this task and all of the subtasks.
        To be implemented in the derived class.
    **/
    virtual void Finish(){};

    /** Recursive intialisation of subtasks at begin of run **/
    void InitTasks();

    /** Recursive reinitialisation of subtasks **/
    void ReInitTasks();

    void ExecuteTasks(Option_t* option) override;

    /** Recursive parameter initialisation for subtasks **/
    void SetParTasks();

    /** Recursive finish of subtasks **/
    void FinishTasks();

    /** Recursive FinishEvent of subtasks **/
    void FinishEvents();

  private:
    std::map<TString, Bool_t> fOutputPersistance;

    ClassDefOverride(FairTask, 4);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// ********************************************* //
// ***        D. Kresan   2004-Sep-14        *** //
// ***        D.Kresan@gsi.de                *** //
// ********************************************* //

#ifndef FAIR_TRAJ_FILTER_H
#define FAIR_TRAJ_FILTER_H 1

#include <Rtypes.h>      // for Double_t, Bool_t, Int_t, etc
#include <TGeoTrack.h>   // IWYU pragma: keep needed by cint // TODO: is this still relevant for CINT?
#include <TMCtls.h>      // for multi-threading
#include <TMath.h>       // for Pi, TwoPi
#include <TString.h>     // for TString

class TClonesArray;
class TParticle;

/**
 * @class FairTrajFilter
 * The filter for storing of the trajectories.
 * This singleton class controls storing of trajectories
 * in the gGeoManager list during the simulation.
 * It is created, if FairRun::SetStoreTraj(kTRUE) was called
 * in the run macro
 * before the initialisation. The cuts should be applied
 * after initialisation and before run via
 * FairTrajFilter::Instance()->Set...Cut(...) methods.
 * Three modes of momentum cut (phase space, polar and decart reference systems),
 * are self-excluded. The last that was set, is applied in the simulation.
 * All other cuts are combined together.
 * @author D. Kresan
 * @version 0.1
 * @since 2004-Sep-15
 */

class FairTrajFilter
{
  public:
    /**
     * Default constructor.
     * Creates the singleton object of FairTrajFilter class.
     * The pointer to this object can be reached via FairTrajFilter::Instance().
     */
    FairTrajFilter();

    /**
     * Destructor.
     */
    virtual ~FairTrajFilter();

    /**
     * Class definition.
     */
    ClassDef(FairTrajFilter, 1);

  private:
    FairTrajFilter(const FairTrajFilter&);
    FairTrajFilter& operator=(const FairTrajFilter&);

    static TMCThreadLocal FairTrajFilter* fgInstance;

    Double_t fVxMin;
    Double_t fVxMax;
    Double_t fVyMin;
    Double_t fVyMax;
    Double_t fVzMin;
    Double_t fVzMax;

    Double_t fPMin;
    Double_t fPMax;
    Double_t fThetaMin;
    Double_t fThetaMax;
    Double_t fPhiMin;
    Double_t fPhiMax;

    Double_t fPxMin;
    Double_t fPxMax;
    Double_t fPyMin;
    Double_t fPyMax;
    Double_t fPzMin;
    Double_t fPzMax;

    Double_t fPtMin;
    Double_t fPtMax;
    Double_t fRapidityMin;
    Double_t fRapidityMax;

    Int_t fKinCutType;

    Double_t fEtotMin;
    Double_t fEtotMax;

    Bool_t fStorePrim;
    Bool_t fStoreSec;

    Double_t fStepSizeMin;

    /**
     * collection of tracks
     */
    TClonesArray* fTrackCollection;

    TGeoTrack* fCurrentTrk;

  public:
    TGeoTrack* AddTrack(Int_t trackId, Int_t pdgCode);
    TGeoTrack* AddTrack(TParticle* p);
    TGeoTrack* CheckAddTrack(Int_t trackId, TParticle* p);
    TGeoTrack* GetCurrentTrk() { return fCurrentTrk; }

    void Init(TString brName = "GeoTracks", TString folderName = "MCGeoTrack");
    void Reset();
    /**
     * This function is used to access the methods of the class.
     * @return Pointer to the singleton FairTrajFilter object, created
     * with FairTrajFilter::FairTrajFilter().
     */
    static FairTrajFilter* Instance();

    /**
     * This function applies all availible cuts on different variables.
     * @param p - pointer to the TParticle object.
     * @return kTRUE - if particle survives the cuts. Otherwise - kFALSE.
     */
    Bool_t IsAccepted(const TParticle* p) const;

    /**
     * This function enables the vertex cut.
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param Box in coordinate space. Only trajectories, created inside this box
     * will be stored. Default values - the cave dimensions.
     */
    void SetVertexCut(Double_t vxMin = -2000.,
                      Double_t vyMin = -2000.,
                      Double_t vzMin = -2000.,
                      Double_t vxMax = 2000.,
                      Double_t vyMax = 2000.,
                      Double_t vzMax = 2000.);

    /**
     * This function enables the momentum cut (polar reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (polar reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutP(Double_t pMin = 0.,
                         Double_t thetaMin = 0.,
                         Double_t phiMin = 0.,
                         Double_t pMax = 1e10,
                         Double_t thetaMax = TMath::Pi(),
                         Double_t phiMax = TMath::TwoPi());

    /**
     * This function enables the momentum cut (decart reference system).
     * Three modes of momentum cut (phase space, polar and decart reference systems),
     * are self-excluded. The last that was set, is applied in the simulation.
     * @param The region in momentum space (decart reference system). Only particles
     * inside this region will be stored.
     * Default values - whole momentum range.
     */
    void SetMomentumCutD(Double_t pxMin = -1e10,
                         Double_t pyMin = -1e10,
                         Double_t pzMin = -1e10,
                         Double_t pxMax = 1e10,
                         Double_t pyMax = 1e10,
                         Double_t pzMax = 1e10);

    /**
     * This function enables the cut in phase space (pt-rapidity).
     * @param The region in phase space (pt-rapidity). Only particles
     * inside this region will be stored.
     * Default values - whole pt-rapidity range.
     */
    void SetPtRapidityCut(Double_t ptMin = 0.,
                          Double_t ptMax = 1e10,
                          Double_t rapidityMin = -1e10,
                          Double_t rapidityMax = 1e10);

    /**
     * This function enables the cut on total energy.
     * @param Total energy range. Only particles with total energy value
     * inside this range will be stored. Deafult values - whole energy range.
     */
    void SetEnergyCut(Double_t etotMin = 0., Double_t etotMax = 1e10);

    /**
     * This function controls the storing of primaries.
     * @param storePrim - boolean flag to control the storing of primaries.
     */
    inline void SetStorePrimaries(Bool_t storePrim = kTRUE) { fStorePrim = storePrim; };

    /**
     * This function controls the storing of secondaries.
     * @param storeSec - boolean flag to control the storing of secondaries.
     */
    inline void SetStoreSecondaries(Bool_t storeSec = kTRUE) { fStoreSec = storeSec; };

    /**
     * This function controls the process of adding the points to the trajectory.
     * @param stepSizeMin - minimum value of step size, wich will be added to
     * the trajectory.
     */
    void SetStepSizeCut(Double_t stepSizeMin = 0.);

    /**
     * This is the getter for the vertex cut.
     * @param References to the variables where return values should be stored.
     */
    void GetVertexCut(Double_t& vxMin,
                      Double_t& vyMin,
                      Double_t& vzMin,
                      Double_t& vxMax,
                      Double_t& vyMax,
                      Double_t& vzMax) const;

    /**
     * This is the getter for the momentum cut (polar reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutP(Double_t& pMin,
                         Double_t& thetaMin,
                         Double_t& phiMin,
                         Double_t& pMax,
                         Double_t& thetaMax,
                         Double_t& phiMax) const;

    /**
     * This is the getter for the momentum cut (decart reference system).
     * @param References to the variables where return values should be stored.
     */
    void GetMomentumCutD(Double_t& pxMin,
                         Double_t& pyMin,
                         Double_t& pzMin,
                         Double_t& pxMax,
                         Double_t& pyMax,
                         Double_t& pzMax) const;

    /**
     * This is the getter for the space phase cut.
     * @param References to the variables where return values should be stored.
     */
    void GetPtRapidityCut(Double_t& ptMin, Double_t& ptMax, Double_t& rapidityMin, Double_t& rapidityMax) const;

    /**
     * This is the getter for the total energy cut.
     * @param References to the variables where return values should be stored.
     */
    void GetEnergyCut(Double_t& etotMin, Double_t& etotMax) const;

    /**
     * This is the getter for flag of storing of primaries.
     * @return kTRUE if primaries should be stored.
     */
    inline Bool_t IsPrimariesStored() const { return fStorePrim; };

    /**
     * This is the getter for flag of storing of secondaries.
     * @return kTRUE if secondaries should be stored.
     */
    inline Bool_t IsSecondariesStored() const { return fStoreSec; };

    /**
     * This is the getter for the step size cut.
     * @return The minimum value of the step size wich still should be
     * added to the trajectory.
     */
    inline Double_t GetStepSizeCut() const { return fStepSizeMin; };

    TGeoTrack* GetTrack(Int_t trackId);
};

#endif
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FairTSBufferFunctionalFunctional_H_
#define FairTSBufferFunctionalFunctional_H_

#include "FairTimeStamp.h"   // for FairTimeStamp

#include <Rtypes.h>     // for Int_t, Bool_t, Double_t, etc
#include <TObject.h>    // for TObject
#include <TString.h>    // for TString
#include <functional>   // for binary_function
#include <iostream>     // for operator<<, basic_ostream, etc

class TBranch;
class TClonesArray;
class TTree;

/**
 * \class BinaryFunctor
 * \brief Base class for all functors which are used in the FairTSBufferFunctional
 * \see FairTSBufferFunctional
 *
 * The class is a base class to control which data is extracted by the FairTSBufferFunctional class for processing.
 * The important method to overwrite is Call. It gets the actual data which is read in from the tree and a parameter.
 * If the actual data is not anymore part of the data you want to have Call returns true to stop the reading of data.
 * Otherwise it should return false.
 * The method TimeOut is used to break the processing if for example always the same data is requested.
 */

class BinaryFunctor
{
  public:
    using first_argument_type = FairTimeStamp*;
    using second_argument_type = double;
    using result_type = bool;

    virtual bool operator()(FairTimeStamp* a, double b) { return Call(a, b); };
    virtual bool Call(FairTimeStamp* a, double b) = 0;
    virtual bool TimeOut() { return false; }
    virtual void ResetTimeOut(){};

    virtual ~BinaryFunctor(){};
};

/**
 * \class StopTime
 * Gives you all the data which is older than the given parameter StopTime.
 * It does not return the data requested before.
 */

class StopTime : public BinaryFunctor
{
  public:
    StopTime()
        : fRequestTime(-1)
        , fOldTime(-1)
        , fSameTimeRequestCounter(0){};

    /**
     * \parameter b: StopTime: All data older than StopTime is returned
     */
    bool Call(FairTimeStamp* a, double b) override
    {
        fRequestTime = b;
        // std::cout << "StopTime: " << a->GetTimeStamp() << " > " <<  b << std::endl;
        return a->GetTimeStamp() > b;
    };

    bool TimeOut() override
    {
        if (fRequestTime != fOldTime) {
            fOldTime = fRequestTime;
            fSameTimeRequestCounter = 0;
            // std::cout << "RequestedTime: " << fRequestTime << std::endl;
            return false;
        } else if (fRequestTime == fOldTime) {
            std::cout << "-I- FairTSBufferFunctional StopTime has requested the same data as before: " << fRequestTime
                      << std::endl;
            fSameTimeRequestCounter++;
        } else {
            std::cout << "-E- FairTSBufferFunctional StopTime Functor has requested time " << fRequestTime
                      << " smaller than old time " << fOldTime << std::endl;
            return true;
        }
        return fSameTimeRequestCounter > 9;
    }

    void ResetTimeOut() override { fSameTimeRequestCounter = 0; }

  private:
    double fRequestTime;
    double fOldTime;
    int fSameTimeRequestCounter;
};

/**
 * \class TimeGap
 * Returns you all the data between two time gaps of a given length.
 */

class TimeGap : public BinaryFunctor
{
  public:
    TimeGap()
        : fOldTime(-1.){};

    /**
     * \parameter b : TimeGap: All data between two time gaps which are larger than TimeGap are returned
     */
    bool Call(FairTimeStamp* a, double b) override
    {
        double aTime = a->GetTimeStamp();

        if (fOldTime < 0) {
            fOldTime = aTime;
            return false;
        }
        if (aTime - fOldTime > b) {
            fOldTime = aTime;
            return true;
        } else {
            fOldTime = aTime;
            return false;
        }
    };

  private:
    double fOldTime;
};

/**
 * \class FairTSBufferFunctional
 * \brief A class to access time ordered data in a root branch
 *
 * In the constructor of the class one has to give the branch name of the data, the tree the data is stored in
 * and a BinaryFunctor which contains the method how the data should be extracted. Several example functors already
 * exists. To extract the data one has to call GetData with a parameter which fits to the selected functor. GetData
 * returns a TClonesArray which contains the data.
 *
 *
 * Be careful! The buffer runs through the time ordered data in one time direction only. This means that you cannot
 * request data which is older than the data you have requested before.
 *
 * Addition: This is not true anymore. GetData(Double_t, Double_t) is able to get also data which is older but this only
 * works if you request a fixed time via StopTime functor. For other functors the behavior is unpredictable.
 *
 *  Created on: Feb 18, 201
 *      Author: stockman
 */

class FairTSBufferFunctional : public TObject
{
  public:
    FairTSBufferFunctional(TString branchName,
                           TTree* sourceTree,
                           BinaryFunctor* stopFunction,
                           BinaryFunctor* startFunction = 0);

    ~FairTSBufferFunctional() override {}
    TClonesArray* GetData(Double_t stopParameter);
    TClonesArray* GetData(Double_t startParameter, Double_t stopParameter);
    Int_t GetBranchIndex() { return fBranchIndex; }

    void SetBranchIndex(const Int_t val) { fBranchIndex = val; }
    void SetStartFunction(BinaryFunctor* function) { fStartFunction = function; }
    void SetStopFunction(BinaryFunctor* function) { fStopFunction = function; }
    Bool_t AllDataProcessed();
    void Terminate() { fTerminate = kTRUE; }

    Bool_t TimeOut()
    {
        Bool_t stopTimeOut = fStopFunction->TimeOut();
        Bool_t startTimeOut = kTRUE;
        if (fStartFunction != 0) {
            startTimeOut = fStartFunction->TimeOut();
            //        if (startTimeOut == kTRUE && stopTimeOut == kFALSE){
            //          fStartFunction->ResetTimeOut();
            //        }
            //        else if (startTimeOut == kFALSE && stopTimeOut == kTRUE){
            //          fStopFunction->ResetTimeOut();
            //        }
        }
        return (stopTimeOut && startTimeOut);
    }

    Int_t FindStartIndex(Double_t startParameter);

  private:
    void ReadInNextFilledEntry();
    Int_t ReadInPreviousFilledEntry(Int_t startEntry);
    void ReadInNextEntry();   //** used only if no function is given and input data is directly passed through to the
                              // OutputArray
    void ReadInEntry(Int_t number);
    void AbsorbDataBufferArray();   //< Absorbs the complete data from fInputArray to fBufferArray

    TClonesArray* fOutputArray;
    TClonesArray* fBufferArray;
    TClonesArray* fInputArray;

    BinaryFunctor* fStartFunction;
    BinaryFunctor* fStopFunction;

    TBranch* fBranch;
    Int_t fBranchIndex;

    Bool_t fTerminate;

    Int_t fVerbose;

    FairTSBufferFunctional(const FairTSBufferFunctional&);
    FairTSBufferFunctional& operator=(const FairTSBufferFunctional&);

    ClassDefOverride(FairTSBufferFunctional, 0);
};

#endif
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
/**
 * @class FairWriteoutBuffer
 *
 * @author Tobias Stockmanns
 * @brief A container class to store digi data during events
 *
 * The FairWriteoutBuffer class provides a container which handles the storage of data between
 * events. The data has to be given with an active time, the absolute time the data is active in the
 * detector and can influence the output of the data.
 * FillNewData is used to put new data into the container.
 * WriteOutData with a given actual time stores the data which has an active time older than the given time
 * in the corresponding TClonesArray of the FairRootManager.
 * At the end of the task WriteOutAllData has to be called to store the data which is still in the buffer.
 * If one adds data via FillNewData into the buffer which is already present in the buffer, Modify is called.
 * The standard behavior of Modify is that the new data is ignored to simulate pile-up. If a different behavior
 * is wanted one has to overwrite Modify in a derived class.
 *
 * The data which should be stored in the buffer has to be derived from FairTimeStamp.
 * It needs an operator< and a method equal if the same detector element is hit.
 *
 * To use this buffer one has to derive his own buffer class from FairWriteoutBuffer and overwrite the pure virtual
 * functions.
 */

#ifndef FairWriteoutBuffer_H_
#define FairWriteoutBuffer_H_

#include "FairLogger.h"        // for FairLogger
#include "FairRootManager.h"   // for FairRootManager
#include "FairTimeStamp.h"     // for FairTimeStamp

#include <Rtypes.h>         // for Bool_t, Int_t, etc
#include <TClonesArray.h>   // for TClonesArray
#include <TObject.h>        // for TObject
#include <TString.h>        // for TString
#include <iostream>         // for cout, ostream
#include <map>              // for multimap
#include <utility>          // for pair
#include <vector>           // for vector

class FairWriteoutBuffer : public TObject
{
  public:
    FairWriteoutBuffer()
        : TObject()
        , fStartTime_map()
        , fDeadTime_map()
        , fBranchName()
        , fClassName()
        , fTreeSave(false)
        , fActivateBuffering(kFALSE)
        , fVerbose(0)
        , fLogger(FairLogger::GetLogger()){};
    FairWriteoutBuffer(TString branchName, TString className, TString folderName, Bool_t persistance);
    ~FairWriteoutBuffer() override {}

    virtual void SaveDataToTree(Bool_t val = kTRUE)
    {
        fTreeSave = val;   ///< If SaveDataToTree is set the data is stored at the end of the buffering into the given
                           ///< TClonesArray.
    }
    virtual void ActivateBuffering(Bool_t val = kTRUE)
    {
        fActivateBuffering = val;   ///< fActivateBuffering has to be set to kTRUE to use the buffering. Otherwise the
                                    ///< data is directly stored in the given TClonesArray.
    }

    Bool_t IsBufferingActivated() { return fActivateBuffering; }

    /// Fills a pointer to a data object into the buffer. StartTime gives the time when the data can influence later
    /// data, activeTime gives the time how long the data can influence later data. Both time data has to be given as an
    /// absolute time!
    virtual void FillNewData(FairTimeStamp* data, double startTime, double activeTime);

    virtual Int_t GetNData() { return fDeadTime_map.size(); }
    virtual std::vector<FairTimeStamp*> GetRemoveOldData(double time);
    virtual std::vector<FairTimeStamp*> GetAllData();

    virtual void SetVerbose(Int_t val) { fVerbose = val; }

    virtual void DeleteOldData()
    {
        if (fBranchName.Length() > 0) {
            TClonesArray* myArray = FairRootManager::Instance()->GetTClonesArray(fBranchName);
            myArray->Delete();
        }
    }

    virtual void WriteOutData(double time);
    virtual void WriteOutAllData();

  protected:
    virtual void AddNewDataToTClonesArray(
        FairTimeStamp* data) = 0;   ///< store the data from the FairTimeStamp pointer in a TClonesArray (you have to
                                    ///< cast it to your type of data)
    virtual double FindTimeForData(
        FairTimeStamp* data) = 0;   ///< if the same data object (like a pad or a pixel) is already present in the
                                    ///< buffer, the time of this object has to be returned otherwise -1
    virtual void FillDataMap(FairTimeStamp* data, double activeTime) = 0;   ///< add a new element in the search buffer
    virtual void EraseDataFromDataMap(
        FairTimeStamp* data) = 0;   ///< delete the element from the search buffer (see PndSdsDigiPixelWriteoutBuffer)

    /// Modify defines the behavior of the buffer if data should be stored which is already in the buffer. Parameters
    /// are the old data with the active time, the new data with an active time. Modify returns than a vector with the
    /// new data which should be stored.
    virtual std::vector<std::pair<double, FairTimeStamp*>> Modify(std::pair<double, FairTimeStamp*> oldData,
                                                                  std::pair<double, FairTimeStamp*>)
    {
        std::vector<std::pair<double, FairTimeStamp*>> result;
        result.push_back(oldData);
        return result;
    }

    virtual void WriteOutDataDeadTimeMap(double time);
    virtual void MoveDataFromStartTimeMapToDeadTimeMap(double time);
    virtual void FillDataToDeadTimeMap(FairTimeStamp* data, double activeTime, double startTime);

    virtual void PrintData(FairTimeStamp* data)
    {
        std::cout << data->GetTimeStamp();
    };   ///< Method should be overwritten in derived classes to print the data of an object stored in the buffer
    virtual void PrintDeadTimeMap();
    virtual void PrintStartTimeMap();

    std::multimap<double, std::pair<double, FairTimeStamp*>> fStartTime_map;
    std::multimap<double, FairTimeStamp*> fDeadTime_map;

    TString fBranchName;
    TString fClassName;
    Bool_t fTreeSave;
    Bool_t fActivateBuffering;
    Int_t fVerbose;
    FairLogger* fLogger;   //! /// FairLogger

  private:
    FairWriteoutBuffer(const FairWriteoutBuffer&);
    FairWriteoutBuffer& operator=(const FairWriteoutBuffer&);

    ClassDefOverride(FairWriteoutBuffer, 1);
};

#endif /* FairWriteoutBuffer_H_ */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
// -------------------------------------------------------------------------
// -----            FairAnaSelector header file                        -----
// -----            Created 14/10/11  by R. Karabowicz                 -----
// -----            Updated 01/02/12  by R. Karabowicz                 -----
// -------------------------------------------------------------------------

#ifndef FAIRANASELECTOR_H
#define FAIRANASELECTOR_H

#include "FairLogger.h"   // for FairLogger, MESSAGE_ORIGIN

#include <Rtypes.h>          // for Int_t, Bool_t, etc
#include <TSelector.h>       // for TSelector
#include <TSelectorList.h>   // for TSelectorList
#include <TString.h>         // for TString
#include <TTree.h>           // for TTree

class FairFileSource;
class FairRunAnaProof;

class TFile;
class TList;
class TObject;
class TProofOutputFile;

class FairAnaSelector : public TSelector
{
  public:
    TProofOutputFile* fProofFile;
    TFile* fFile;
    TTree* fChain;   //! pointer to the analyzed TTree or TChain
    FairRunAnaProof* fRunAna;

    FairAnaSelector(TTree* /*tree*/ = 0)
        : fProofFile(0)
        , fFile(0)
        , fChain(0)
        , fRunAna(nullptr)
        , fProofSource(0)
        , fCurrentDirectory("")
    {}

    ~FairAnaSelector() override {}
    Int_t Version() const override { return 1; }
    void Begin(TTree* tree) override;
    void SlaveBegin(TTree* tree) override;
    void Init(TTree* tree) override;
    Bool_t Notify() override;
    Bool_t Process(Long64_t entry) override;
    Int_t GetEntry(Long64_t entry, Int_t getall = 0) override
    {
        return fChain ? fChain->GetTree()->GetEntry(entry, getall) : 0;
    }
    void SetOption(const char* option) override { fOption = option; }
    void SetObject(TObject* obj) override { fObject = obj; }
    void SetInputList(TList* input) override { fInput = input; }
    TList* GetOutputList() const override { return fOutput; }
    void SlaveTerminate() override;
    void Terminate() override;

    void SetFairRunAnaProof(FairRunAnaProof* runAna) { fRunAna = runAna; }

  private:
    FairAnaSelector(const FairAnaSelector&);
    FairAnaSelector operator=(const FairAnaSelector&);

    FairFileSource* fProofSource;

    TString fCurrentDirectory;

    ClassDefOverride(FairAnaSelector, 0);
};

#endif   // FAIRANASELECTOR_H
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNANAPROOF_H
#define FAIRRUNANAPROOF_H

/**
 * Configure and manage the  Analysis on proof
 * @author R. Karabowicz
 * @version 0.1
 * @since 30.04.2013
 */

#include "FairFileSource.h"   // FairRunAnaProof can only accept FairFileSource as source
#include "FairRunAna.h"

#include <Rtypes.h>
#include <TProof.h>

class FairRunAnaProof : public FairRunAna
{
  public:
    /** \deprecated Deprecated in v18.8, will be removed in v20. */
    [[deprecated]] static FairRunAnaProof* Instance();
    virtual ~FairRunAnaProof();
    FairRunAnaProof(const char* proofName = "");

    /**initialize the run manager*/
    void Init() override;

    /** Init containers executed on PROOF, which is part of Init when running locally*/
    void InitContainers();

    /**Run from event number NStart to event number NStop */
    void Run(Int_t NStart = 0, Int_t NStop = 0) override;
    /**Run for one event, used on PROOF nodes*/
    void RunOneEvent(Long64_t entry);
    /**Run on proof from event NStart to event NStop*/
    void RunOnProof(Int_t NStart, Int_t NStop);

    /** set the input tree of fRootManager when running on PROOF worker*/
    /* void        SetInTree (TTree* tempTree)   { */
    /*   fRootManager->SetInTree (tempTree); */
    /* } */

    /** GetProof */
    TProof* GetProof() { return fProof; }

    /** To be set to kTRUE only when running on PROOF worker, only by TSelector */
    void SetRunOnProofWorker(Bool_t tb = kTRUE) { fRunOnProofWorker = tb; }
    /** Set PROOF ARchive (PAR) file name*/
    void SetProofParName(TString parName) { fProofParName = parName; }
    /** Set directory for storing output files*/
    void SetOutputDirectory(TString dirName) { fOutputDirectory = dirName; }
    /** Set PROOF output status, possibilities: "copy","merge"*/
    void SetProofOutputStatus(TString outStat) { fProofOutputStatus = outStat; }

    void SetSource(FairSource* tempSource) override;

  protected:
    static FairRunAnaProof* fRAPInstance;

    /** PROOF **/
    TProof* fProof;
    /** executing on PROOF worker*/
    Bool_t fRunOnProofWorker;   //!
    /** PROOF server name*/
    TString fProofServerName;   //!
    /** PROOF ARchive (PAR) file name*/
    TString fProofParName;   //!
    /** Output directory*/
    TString fOutputDirectory;   //!
    /** Output status indicator: "copy","merge","dataset"*/
    TString fProofOutputStatus;

  private:
    FairRunAnaProof(const FairRunAnaProof&);
    FairRunAnaProof operator=(const FairRunAnaProof&);

    FairFileSource* fProofFileSource;

    ClassDefOverride(FairRunAnaProof, 1);
};

#endif   // FAIRRUNANAPROOF_H

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class FairRuntimeDb with content:

#line 1 "G__ParBase dictionary payload"


#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRCONTFACT_H
#define FAIRCONTFACT_H

#include <Rtypes.h>    // for Bool_t, ClassDef, etc
#include <TList.h>     // for TList
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString

class FairParIo;
class FairParSet;

class FairContainer : public TNamed
{
  private:
    FairContainer();
    FairContainer(const FairContainer&);
    FairContainer& operator=(const FairContainer&);

  protected:
    /** available contexts for this parameter container*/
    TList* contexts;
    /** actual context set by the user */
    TString actualContext;

  public:
    FairContainer(const char*, const char*, const char*);
    ~FairContainer() override;
    void addContext(const char*);
    Bool_t setActualContext(const char* c);
    const char* getDefaultContext();
    const char* getActualContext() const { return actualContext.Data(); }
    void print();
    TString getConcatName();
    const char* getContext();
    ClassDefOverride(FairContainer, 0);   // class for list elements in class FairContFact
};

class FairContFact : public TNamed
{
  public:
    FairContFact();
    FairContFact(const char* name, const char* title);
    ~FairContFact() override;
    Bool_t addContext(const char* name);
    void print();
    FairParSet* getContainer(const char*);
    virtual FairParSet* createContainer(FairContainer*) { return nullptr; }
    virtual void activateParIo(FairParIo*) {}
    /// @param[in] container Transfers ownership if return value is true
    Bool_t AddContainer(FairContainer*);

  protected:
    TList* containers{new TList};   // all parameter containers managed by this factory
    const char* getActualContext(const char* name)
    {
        return (static_cast<FairContainer*>(containers->FindObject(name)))->getActualContext();
    }
    ClassDefOverride(FairContFact, 0);   // base class of all factories for parameter containers

  private:
    FairContFact(const FairContFact&);
    FairContFact& operator=(const FairContFact&);
};

#endif /* !FAIRCONTFACT_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARASCIIFILEIO_H
#define FAIRDETPARASCIIFILEIO_H

#include "FairDetParIo.h"   // for FairDetParIo

#include <Rtypes.h>    // for Text_t, Bool_t, etc
#include <TString.h>   // for TString
#include <iosfwd>      // for fstream

class FairParSet;

class FairDetParAsciiFileIo : public FairDetParIo
{
  protected:
    TString fHeader;       //! header of container output in file
    TString sepLine;       //! comment line
    std::fstream* pFile;   //! pointer to ascii file
    Bool_t findContainer(const Text_t* name);
    Bool_t checkAllFound(Int_t*, Int_t);
    void writeHeader(const Text_t*,
                     const Text_t* context = "",
                     const Text_t* author = "",
                     const Text_t* description = "");
    void writeComment(FairParSet*);
    void readComment(const Char_t*, FairParSet*);

  public:
    FairDetParAsciiFileIo(std::fstream* f);
    virtual ~FairDetParAsciiFileIo() {}

  private:
    FairDetParAsciiFileIo& operator=(const FairDetParAsciiFileIo&);
    FairDetParAsciiFileIo(const FairDetParAsciiFileIo&);

    ClassDefOverride(FairDetParAsciiFileIo, 0);   // Class for detector parameter I/O from ascii file
};

#endif /* !FAIRDETPARASCIIFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARIO_H
#define FAIRDETPARIO_H

#include <Rtypes.h>   // for Int_t, FairDetParIo::Class, etc
#include <TNamed.h>   // for TNamed

class FairParSet;

class FairDetParIo : public TNamed
{
  protected:
    Int_t inputNumber;   // input number (first or second input in runtime database)

  public:
    FairDetParIo();
    virtual ~FairDetParIo() { ; }

    // sets the input number
    void setInputNumber(Int_t n) { inputNumber = n; }

    // returns the input number
    Int_t getInputNumber() { return inputNumber; }

    // initializes parameter container
    virtual Bool_t init(FairParSet*) { return kFALSE; }

    // writes parameter container to output
    virtual Int_t write(FairParSet*) { return kFALSE; }

    ClassDefOverride(FairDetParIo, 0);   // Base class for detector parameter IO
};

#endif /* !HDETPARIO_H */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRDETPARROOTFILEIO_H
#define FAIRDETPARROOTFILEIO_H

#include "FairDetParIo.h"   // for FairDetParIo

#include <Rtypes.h>   // for Int_t, Text_t, etc

class FairParRootFile;
class FairParSet;
class TObject;

class FairDetParRootFileIo : public FairDetParIo
{
  protected:
    FairParRootFile* pFile;   // pointer to parameter ROOT file

  public:
    FairDetParRootFileIo(FairParRootFile* f);
    virtual ~FairDetParRootFileIo() {}
    virtual Bool_t read(FairParSet*);
    Int_t write(FairParSet*) override;

  protected:
    Int_t findInputVersion(const char* contName);
    Int_t getMaxVersion(const char* contName);
    TObject* findContainer(Text_t* contName, Int_t version);

  private:
    FairDetParRootFileIo(const FairDetParRootFileIo&);
    FairDetParRootFileIo& operator=(const FairDetParRootFileIo&);

    ClassDefOverride(FairDetParRootFileIo, 0);   // detector base class for parameter I/O from ROOT file
};

#endif /* !FAIRDETPARROOTFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGENERICPARASCIIFILEIO_H
#define FAIRGENERICPARASCIIFILEIO_H

#include "FairDetParAsciiFileIo.h"   // for FairDetParAsciiFileIo

#include <Rtypes.h>   // for Int_t, Bool_t, etc
#include <iosfwd>     // for fstream

class FairParGenericSet;
class FairParSet;
class TString;

class FairGenericParAsciiFileIo : public FairDetParAsciiFileIo
{
  public:
    FairGenericParAsciiFileIo(std::fstream* f = 0);
    ~FairGenericParAsciiFileIo() {}
    Bool_t init(FairParSet*) override;
    Int_t write(FairParSet*) override;

  private:
    ClassDefOverride(FairGenericParAsciiFileIo,
                     0)   // I/O from Ascii file for parameter containers derived from FairParGenericSet
        Bool_t readGenericSet(FairParGenericSet* pPar);
    Int_t writeGenericSet(FairParGenericSet* pPar);

    template<class type>
    const UChar_t* readData(type, const Char_t*, TString&, Int_t&);
    template<class type>
    void writeData(type*, Int_t);
};

#endif /* !FAIRGENERICPARASCIIFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRGENERICPARROOTFILEIO_H
#define FAIRGENERICPARROOTFILEIO_H

#include "FairDetParRootFileIo.h"   // for FairDetParRootFileIo

#include <Rtypes.h>   // for ClassDef macro

class FairParRootFile;
class FairParSet;

class FairGenericParRootFileIo : public FairDetParRootFileIo
{
  public:
    FairGenericParRootFileIo(FairParRootFile* f = 0);
    ~FairGenericParRootFileIo() {}
    Bool_t init(FairParSet*) override;
    ClassDefOverride(FairGenericParRootFileIo,
                     0)   // I/O from ROOT file for parameter containers derived from FairParGenericSet
};

#endif /* !FAIRGENERICPARROOTFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARAMLIST_H
#define FAIRPARAMLIST_H

#include <Rtypes.h>           // for Text_t, Int_t, Bool_t, etc
#include <TArrayC.h>          // for TArrayC
#include <TFile.h>            // for TFile
#include <THashTable.h>       // for THashTable
#include <TNamed.h>           // for TNamed
#include <TObject.h>          // for TObject
#include <TROOT.h>            // for TROOT, gROOT
#include <TSeqCollection.h>   // for TSeqCollection
#include <TString.h>          // for TString

class TArrayD;
class TArrayF;
class TArrayI;

class FairParamObj : public TNamed
{
  protected:
    UChar_t* paramValue;      // Pointer to binary array
    Int_t arraySize;          // Size of binary array
    TString paramType;        // Type of parameter value or class name
    Bool_t basicType;         // kTRUE for C-types and C-type parameter arrays, kFALSE for classes
    Int_t bytesPerValue;      // number of bytes per value
    Int_t classVersion;       // Code version of classes stored as binary
    UChar_t* streamerInfo;    // Pointer to binary array container the streamer info
    Int_t streamerInfoSize;   // Size of streamer info array

  public:
    FairParamObj(const Text_t* name = "");
    FairParamObj(FairParamObj&);
    FairParamObj(const Text_t*, Int_t);
    FairParamObj(const Text_t*, Bool_t);
    FairParamObj(const Text_t*, UInt_t);
    FairParamObj(const Text_t*, Float_t);
    FairParamObj(const Text_t*, Double_t);
    FairParamObj(const Text_t*, const Int_t*, const Int_t);
    FairParamObj(const Text_t*, const UInt_t*, const Int_t);
    FairParamObj(const Text_t*, const Float_t*, const Int_t);
    FairParamObj(const Text_t*, const Double_t*, const Int_t);
    FairParamObj(const Text_t*, const Text_t*);
    FairParamObj(const Text_t*, const Char_t*, const Int_t);
    FairParamObj(const Text_t*, const UChar_t*, const Int_t);
    ~FairParamObj();
    void setParamType(const Text_t* t);
    UChar_t* setLength(Int_t l);
    void setParamValue(UChar_t*, const Int_t);
    void setClassVersion(const Int_t v) { classVersion = v; }
    UChar_t* setStreamerInfoSize(Int_t);
    void setStreamerInfo(UChar_t*, const Int_t);
    UChar_t* getParamValue() { return paramValue; }
    Bool_t isBasicType() { return basicType; }
    const char* getParamType() { return paramType.Data(); }
    Int_t getBytesPerValue() { return bytesPerValue; }
    Int_t getClassVersion() { return classVersion; }
    Int_t getLength() { return arraySize; }
    Int_t getNumParams();
    UChar_t* getStreamerInfo() { return streamerInfo; }
    Int_t getStreamerInfoSize() { return streamerInfoSize; }
    void print();

  protected:
    template<class type>
    void printData(type*, Int_t);

  private:
    FairParamObj& operator=(const FairParamObj&);

    // Class for binary parameter object (name + binary array)
    ClassDefOverride(FairParamObj, 0);
};

class FairParamList : public TObject
{
  protected:
    THashTable paramList;   // List for parameters stored as string
    class FairParamTFile : public TFile
    {
      public:
        FairParamTFile()
        {
            // Create StreamerInfo index
            Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize() + 1;
            if (lenIndex < 5000) {
                lenIndex = 5000;
            }
            fClassIndex = new TArrayC(lenIndex);
        }
        ~FairParamTFile()
        {
            delete fClassIndex;
            fClassIndex = 0;
        }
    };

  public:
    FairParamList();
    ~FairParamList();
    void add(FairParamObj&);
    void add(const Text_t*, const Text_t*);
    void add(const Text_t*, Int_t);
    void add(const Text_t*, Bool_t);
    void add(const Text_t*, UInt_t);
    void add(const Text_t*, Float_t);
    void add(const Text_t*, Double_t);
    void add(const Text_t*, TArrayI&);
    void add(const Text_t*, TArrayC&);
    void add(const Text_t*, TArrayF&);
    void add(const Text_t*, TArrayD&);
    void add(const Text_t*, const UChar_t*, const Int_t);
    void add(const Text_t*, const Int_t*, const Int_t);
    void add(const Text_t*, const Float_t*, const Int_t);
    void add(const Text_t*, const Double_t*, const Int_t);
    void addObject(const Text_t*, TObject*);
    Bool_t fill(const Text_t*, Text_t*, const Int_t);
    Bool_t fill(const Text_t*, Int_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, Bool_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, UInt_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, Float_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, Double_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, UChar_t*, const Int_t nValues = 1);
    Bool_t fill(const Text_t*, TArrayI*);
    Bool_t fill(const Text_t*, TArrayC*);
    Bool_t fill(const Text_t*, TArrayF*);
    Bool_t fill(const Text_t*, TArrayD*);
    Bool_t fillObject(const Text_t*, TObject*);
    void print();
    FairParamObj* find(const Text_t* name) { return static_cast<FairParamObj*>(paramList.FindObject(name)); }
    THashTable* getList() { return &paramList; }

  private:
    FairParamList(const FairParamList&);
    FairParamList& operator=(const FairParamList&);

    // Class for lists of parameters (of type FairParamObj)
    ClassDefOverride(FairParamList, 4);
};

#endif /* !FAIRPARAMLIST_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARASCIFILEIIO_H
#define FAIRPARASCIFILEIIO_H

#include "FairParIo.h"   // for FairParIo

#include <Rtypes.h>   // for Bool_t, Text_t, etc
#include <fstream>    // for fstream, etc

class TList;

class FairParAsciiFileIo : public FairParIo
{
  protected:
    std::fstream* file;   // pointer to a file

  public:
    FairParAsciiFileIo();

    // default destructor closes an open file and deletes list of I/Os
    ~FairParAsciiFileIo();

    // opens file
    // if a file is already open, this file will be closed
    // activates detector I/Os
    Bool_t open(const Text_t* fname, const Text_t* status = "in");

    // concatenate files whose names are stored in the TList
    // TList holds list od TObjStrings
    // create file all.par in local working directory
    // calls open to open the generated file all.par
    Bool_t open(const TList* fnamelist, const Text_t* status = "in");

    // closes file
    void close() override;

    // returns kTRUE if file is open
    Bool_t check() override
    {
        if (file) {
            return (file->rdbuf()->is_open() == 1);
        } else {
            return kFALSE;
        }
    }

    // prints information about the file and the detector I/Os
    void print() override;

    std::fstream* getFile();

  private:
    FairParAsciiFileIo(const FairParAsciiFileIo&);
    FairParAsciiFileIo& operator=(const FairParAsciiFileIo&);

    ClassDefOverride(FairParAsciiFileIo, 0);   // Parameter I/O from ASCII files
};

#endif /* !FAIRPARASCIIFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARGENERICSET_H
#define FAIRPARGENERICSET_H

#include "FairParSet.h"   // for FairParSet

#include <Rtypes.h>   // for Bool_t, etc

class FairParIo;
class FairParamList;

class FairParGenericSet : public FairParSet
{
  public:
    FairParGenericSet(const char* name, const char* title, const char* context, Bool_t ownership = kFALSE)
        : FairParSet(name, title, context, ownership)
    {}
    virtual ~FairParGenericSet() {}
    virtual void putParams(FairParamList*) = 0;
    virtual Bool_t getParams(FairParamList*) = 0;
    virtual void printParams();

    Bool_t init(FairParIo* inp) override;
    Int_t write(FairParIo* output) override;

  protected:
    FairParGenericSet()
        : FairParSet()
    {}
    ClassDefOverride(FairParGenericSet, 1);   // Base class for generic-style parameter containers
};

#endif /* !FAIRPARGENERICSET_H */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARIO_H
#define FAIRPARIO_H

#include <Rtypes.h>    // for Bool_t, Text_t, etc
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString

class FairDetParIo;
class FairRtdbRun;
class TList;

class FairParIo : public TObject
{
  protected:
    TList* detParIoList;   // list of detector I/Os
    Bool_t autoWritable;   // flag indicating if automatic write is possible
    TString filename;

  public:
    FairParIo();
    virtual ~FairParIo();
    virtual FairDetParIo* getDetParIo(const Text_t*);
    virtual void setDetParIo(FairDetParIo*);
    virtual void removeDetParIo(Text_t*);
    void setInputNumber(Int_t);
    virtual void close() { ; }

    // returns the filename
    const char* getFilename() { return filename.Data(); }

    // creates input/output class for a special detector and stores pointer
    // used only for Oracle input/output
    // (code in  class OraIo)
    virtual void setDetParIo(Text_t*) { ; }

    // prints information about input/output
    virtual void print() { ; }

    // checks if the input/output is open
    virtual Bool_t check() { return kFALSE; }

    // reads versions of parameter containers for an event file
    virtual void readVersions(FairRtdbRun*) { ; }

    // sets global file pointer in ROOT if input/output is a ROOT-file
    // (code in FairParRootFileIo)
    virtual void cd() { ; }

    // set and get for flag autoWritable
    void setAutoWritable(Bool_t f = kTRUE) { autoWritable = f; }
    Bool_t isAutoWritable() const { return autoWritable; }

  private:
    FairParIo(const FairParIo&);
    FairParIo& operator=(const FairParIo&);

    ClassDefOverride(FairParIo, 0);   // Base class for all parameter I/Os
};

#endif /* !FAIRPARIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARROOTFILEIO_H
#define FAIRPARROOTFILEIO_H

#include "FairParIo.h"   // for FairParIo

#include <Rtypes.h>   // for Bool_t, Text_t, Int_t, etc
#include <TFile.h>    // for TFile
#include <TNamed.h>   // for TNamed
#include <fstream>
using std::fstream;

class FairRtdbRun;
class TKey;
class TList;

class FairParRootFile : public TNamed
{
  public:
    FairRtdbRun* run;   //! pointer to current run in ROOT file
    FairParRootFile(const Text_t* fname, Option_t* option = "READ", const Text_t* ftitle = "", Int_t compress = 1);
    FairParRootFile(TFile* f);
    ~FairParRootFile();
    FairRtdbRun* getRun() { return run; }
    void readVersions(FairRtdbRun*);

    Bool_t IsOpen() { return RootFile && (RootFile->IsOpen()); }
    void cd()
    {
        if (RootFile) {
            RootFile->cd();
        }
    }
    Bool_t IsWritable() { return RootFile && RootFile->IsWritable(); }

    TKey* GetKey(const Text_t* t)
    {
        if (RootFile) {
            return RootFile->GetKey(t);
        } else {
            return nullptr;
        }
    }
    TList* GetListOfKeys()
    {
        if (RootFile) {
            return RootFile->GetListOfKeys();
        } else {
            return nullptr;
        }
    }
    void Close()
    {
        if (RootFile) {
            RootFile->Close();
        }
    }

  protected:
    TFile* RootFile;

  private:
    FairParRootFile(const FairParRootFile&);
    FairParRootFile& operator=(const FairParRootFile&);

    ClassDefOverride(FairParRootFile, 0);   // ROOT file for Parameter I/O
};

class FairParRootFileIo : public FairParIo
{
  protected:
    FairParRootFile* file;   // pointer to ROOT file
    Bool_t fMerging;

  public:
    FairParRootFileIo();
    FairParRootFileIo(Bool_t merged);
    ~FairParRootFileIo();
    Bool_t open(const Text_t* fname, Option_t* option = "READ", const Text_t* ftitle = "", Int_t compress = 1);
    Bool_t open(const TList* fnamelist, Option_t* option = "READ", const Text_t* ftitle = "", Int_t compress = 1);
    static void MergeFiles(TFile* newParFile, const TList* fnamelist);
    void close() override;
    void print() override;
    FairParRootFile* getParRootFile();
    void readVersions(FairRtdbRun*) override;
    TList* getKeys();
    Bool_t check() override
    {
        // returns kTRUE if file is open
        if (file) {
            return file->IsOpen();
        } else {
            return kFALSE;
        }
    }
    void cd() override
    {
        // sets the global ROOT file pointer gFile
        if (file) {
            file->cd();
        }
    }
    /**
    Open an existing root file for IO
    */
    Bool_t open(TFile* f);
    void setMerging(Bool_t io) { fMerging = io; }

  private:
    FairParRootFileIo(const FairParRootFileIo&);
    FairParRootFileIo& operator=(const FairParRootFileIo&);

    ClassDefOverride(FairParRootFileIo, 0);   // Parameter I/O from ROOT files
};

#endif /* !FAIRPARROOTFILEIO_H */
/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRPARSET_H
#define FAIRPARSET_H

#include <Rtypes.h>   // for Int_t, Bool_t, etc
#include <TObject.h>
#include <TString.h>   // for TString

class FairLogger;
class FairParIo;

class FairParSet : public TObject
{
  protected:
    TString fName;          //
    TString fTitle;         //
    TString detName;        //! name of the detector the container belongs to
    Int_t versions[3];      //! versions of container in the 2 possible inputs
    Bool_t status;          //! static flag
    Bool_t changed;         //! flag is kTRUE if parameters have changed
    Bool_t owned;           //! if flag is KTRUE FairDB has the par. class ownership
    TString paramContext;   // Context/purpose for parameters and conditions
    TString author;         // Author of parameters
    TString description;    // Description of parameters
    /** Fair Logger */
    FairLogger* fLogger;   //!

  public:
    FairParSet(const char* name = "", const char* title = "", const char* context = "", Bool_t owner = kFALSE);
    virtual ~FairParSet() {}

    const char* GetName() const override { return static_cast<const char*>(fName.Data()); }
    const char* GetTitle() const override { return static_cast<const char*>(fTitle.Data()); }

    virtual Bool_t init();
    virtual Bool_t init(FairParIo*) { return kFALSE; }
    virtual Int_t write();
    virtual Int_t write(FairParIo*) { return kFALSE; }
    virtual void clear() {}
    virtual void print();

    const char* getDetectorName() { return detName.Data(); }
    void resetInputVersions();

    void setInputVersion(Int_t v = -1, Int_t i = 0)
    {
        if (i >= 0 && i < 3) {
            versions[i] = v;
        }
    }
    Int_t getInputVersion(Int_t i)
    {
        if (i >= 0 && i < 3) {
            return versions[i];
        } else {
            return 0;
        }
    }

    void setStatic(Bool_t flag = kTRUE) { status = flag; }
    Bool_t isStatic() { return status; }

    void setOwnership(Bool_t flag = kTRUE) { owned = flag; }
    Bool_t isOwned() { return owned; }

    void setChanged(Bool_t flag = kTRUE) { changed = flag; }
    Bool_t hasChanged() { return changed; }

    const char* getParamContext() const { return paramContext.Data(); }

    void setAuthor(const char* s) { author = s; }
    const char* getAuthor() const { return author.Data(); }

    void setDescription(const char* s) { description = s; }
    const char* getDescription() const { return description.Data(); }

    void copyComment(FairParSet& r)
    {
        author = r.getAuthor();
        description = r.getDescription();
    }

    // TODO These two methods are not used in FairRoot at all.
    // They probably should be marked deprecated (or final, or = delete)
    // and later removed.
    virtual void fill(UInt_t){};
    virtual void store(UInt_t){};

    FairParSet& operator=(const FairParSet&);
    FairParSet(const FairParSet&);

    ClassDefOverride(FairParSet, 2);   // Base class for all parameter containers
};

#endif /* !FAIRPARSET_H */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRTDBRUN_H
#define FAIRRTDBRUN_H

#include <Rtypes.h>    // for Int_t, Text_t, UInt_t, etc
#include <TNamed.h>    // for TNamed
#include <TString.h>   // for TString
#include <iosfwd>      // for fstream
#include <stdio.h>     // for sprintf, sscanf

class TList;
using std::fstream;

class FairParVersion : public TNamed
{
  protected:
    Int_t inputVersions[3];   //! version of the parameter container in the 2 possible inputs
    Int_t rootVersion;        // version of the parameter container in the ROOT output file

  public:
    FairParVersion()
        : TNamed()
        , rootVersion(0)
    {}
    FairParVersion(const char* name);
    ~FairParVersion() {}
    void setInputVersion(Int_t v = -1, Int_t i = 0)
    {
        if (i >= 0 && i < 3) {
            inputVersions[i] = v;
        }
    }
    Int_t getInputVersion(Int_t i) const
    {
        if (i >= 0 && i < 3) {
            return inputVersions[i];
        } else {
            return -1;
        }
    }
    void resetInputVersions()
    {
        for (Int_t i = 0; i < 3; i++) {
            inputVersions[i] = -1;
        }
    }
    void setRootVersion(Int_t v) { rootVersion = v; }
    Int_t getRootVersion() const { return rootVersion; }
    ClassDefOverride(FairParVersion, 1);   // Class for parameter versions
};

class FairRtdbRun : public TNamed
{
  protected:
    TList* parVersions;   // List of container names with the versions
    TString refRun;       //! name of the reference run for initialization

  public:
    FairRtdbRun();
    FairRtdbRun(const Text_t* name, const Text_t* refName = "");
    FairRtdbRun(Int_t r, Int_t rr = -1);
    FairRtdbRun(FairRtdbRun& run);
    ~FairRtdbRun();
    inline UInt_t getRunId(void);
    void addParVersion(FairParVersion* pv);
    FairParVersion* getParVersion(const Text_t* name);
    TList* getParVersions() { return parVersions; }
    const Text_t* getRefRun() { return refRun.Data(); }
    void setRefRun(Text_t* s) { refRun = s; }
    inline void setRefRun(Int_t r);
    void resetInputVersions();
    void resetOutputVersions();
    void print();
    void write(std::fstream&);

  private:
    FairRtdbRun& operator=(const FairRtdbRun&);

    ClassDefOverride(FairRtdbRun, 1);   // Class for parameter version management of a run
};

// -------------------- inlines ---------------------------

inline UInt_t FairRtdbRun::getRunId(void)
{
    UInt_t r;
    sscanf(GetName(), "%i", &r);
    return r;
}

inline void FairRtdbRun::setRefRun(Int_t r)
{
    if (r == -1) {
        refRun = "";
    } else {
        char name[255];
        sprintf(name, "%i", r);
        refRun = name;
    }
}

#endif /* !FAIRRTDBRUN_H */
/********************************************************************************
 * Copyright (C) 2014-2022 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH  *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *              GNU Lesser General Public Licence (LGPL) version 3,             *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/
#ifndef FAIRRUNTIMEDB_H
#define FAIRRUNTIMEDB_H

#include <Rtypes.h>    // for Bool_t, Int_t, Text_t, etc
#include <TList.h>     // for TList
#include <TObject.h>   // for TObject
#include <TString.h>   // for TString

class FairContFact;
class FairLogger;
class FairParIo;
class FairParSet;
class FairRtdbRun;

static TList contFactories;   //! list of container factories

/**
 * \ingroup parbase
 *
 * See Also: \ref parbase_runtimedb
 */
class FairRuntimeDb : public TObject
{
  private:
    static FairRuntimeDb* gRtdb;   //!

  protected:
    FairRuntimeDb(void);
    TList* containerList;      // list of parameter containers
    TList* runs;               // list of runs
    FairParIo* firstInput;     // first (prefered) input for parameters
    FairParIo* secondInput;    // second input (used if not found in first input)
    FairParIo* output;         // output for parameters
    FairRtdbRun* currentRun;   // Current run
    TString currentFileName;   // Name of current event file
    Bool_t versionsChanged;    // flag for write of list of runs (set kTRUE by each write)
    Bool_t isRootFileOutput;   // flag indicating that the output is a ROOT file
    /** Fair Logger */
    FairLogger* fLogger;   //!

    /**
     * Select which IO type to use.
     */
    typedef enum
    {
        UNKNOWN_Type = 0,
        AsciiFileOutput = 1,   // Ascii in-out-put
        RootFileOutput = 2,    // Root Files
        RootTSQLOutput = 3     // Use a TSQL db
    } ParamIOType;
    ParamIOType ioType;   // IO Type

  public:
    static FairRuntimeDb* instance(void);
    ~FairRuntimeDb() override;

    Bool_t addParamContext(const char*);
    void printParamContexts();
    void addContFactory(FairContFact*);
    void removeContFactory(FairContFact* fact);
    FairContFact* getContFactory(const Text_t*);

    Bool_t addContainer(FairParSet*);
    FairParSet* getContainer(const Text_t*);
    FairParSet* findContainer(const char*);
    void removeContainer(const char*);
    void removeAllContainers();
    Bool_t initContainers(UInt_t runId, Int_t refId = -1, const Text_t* fileName = "");
    void setContainersStatic(Bool_t f = kTRUE);
    Bool_t writeContainers(void);
    Bool_t writeContainer(FairParSet*, FairRtdbRun*, FairRtdbRun* refRun = 0);

    FairRtdbRun* addRun(Int_t runId, Int_t refId = -1);
    FairRtdbRun* getRun(Int_t);
    FairRtdbRun* getRun(const char*);
    FairRtdbRun* getCurrentRun(void) { return currentRun; }
    Text_t const* getCurrentFileName() { return currentFileName.Data(); }
    void clearRunList(void);

    void removeRun(Text_t*);

    Bool_t setInputVersion(Int_t run, Text_t* container, Int_t version, Int_t inputNumber);
    Bool_t setRootOutputVersion(Int_t run, Text_t* container, Int_t version);
    void setVersionsChanged(Bool_t f = kTRUE) { versionsChanged = f; }
    void resetInputVersions(void);
    void resetOutputVersions(void);
    void resetAllVersions(void);

    Bool_t readAll(void);
    void writeVersions(void);
    void saveOutput(void);

    Bool_t setFirstInput(FairParIo*);
    Bool_t setSecondInput(FairParIo*);
    Bool_t setOutput(FairParIo*);
    FairParIo* getFirstInput(void);
    FairParIo* getSecondInput(void);
    FairParIo* getOutput(void);
    void closeFirstInput(void);
    void closeSecondInput(void);
    void closeOutput(void);
    void activateParIo(FairParIo*);
    TList* getListOfContainers() { return containerList; }
    void print(void);

    Int_t findOutputVersion(FairParSet*);

  private:
    FairRuntimeDb(const FairRuntimeDb& M);
    FairRuntimeDb& operator=(const FairRuntimeDb&) { return *this; }
    Bool_t initContainers(void);

    ClassDefOverride(FairRuntimeDb, 0);   // Class for runtime database
};

#endif /* !FAIRRUNTIMEDB_H */

#undef  _BACKWARD_BACKWARD_WARNING_H

Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module libRCsg: '
#line 1 "libRCsg dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
namespace RootCsg{class __attribute__((annotate("$clingAutoload$CsgOps.h")))  TBaseMesh;}
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module libGed: '
#line 1 "libGed dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class __attribute__((annotate(R"ATTRDUMP(base editor's frame)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(base editor's frame)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(base editor's frame)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(base editor's frame)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TGedFrame.h")))  __attribute__((annotate("$clingAutoload$TArrowEditor.h")))  TGedFrame;
class __attribute__((annotate(R"ATTRDUMP(frame showing the selected object name)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TGedFrame.h")))  __attribute__((annotate("$clingAutoload$TArrowEditor.h")))  TGedNameFrame;
class __attribute__((annotate(R"ATTRDUMP(GUI for editing arrow attributes)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TArrowEditor.h")))  TArrowEditor;
class __attribute__((annotate(R"ATTRDUMP(GUI for editing fill attributes)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TAttFillEditor.h")))  TAttFillEditor;
class __attribute__((annotate(R"ATTRDUMP(GUI for editing line attributes)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TAttLineEditor.h")))  TAttLineEditor;
class __attribute__((annotate(R"ATTRDUMP(GUI for editing marker attributes)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TAttMarkerEditor.h")))  TAttMarkerEditor;
class __attribute__((annotate(R"ATTRDUMP(GUI for editing text attributes)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TAttTextEditor.h")))  TAttTextEditor;
class __attribute__((annotate(R"ATTRDUMP(axis editor)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TAxisEditor.h")))  TAxisEditor;
class __attribute__((annotate(R"ATTRDUMP(GUI for editing arrow attributes)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TCurlyArcEditor.h")))  TCurlyArcEditor;
class __attribute__((annotate(R"ATTRDUMP(GUI for editing arrow attributes)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TCurlyLineEditor.h")))  TCurlyLineEditor;
class __attribute__((annotate(R"ATTRDUMP(user interface for TF1 objects)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TF1Editor.h")))  TF1Editor;
class __attribute__((annotate(R"ATTRDUMP(editor of TFrame objects)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TFrameEditor.h")))  TFrameEditor;
class __attribute__((annotate(R"ATTRDUMP(Function parameters dialog)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TFunctionParametersDialog.h")))  TFunctionParametersDialog;
class __attribute__((annotate(R"ATTRDUMP(ROOT graphics editor)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TGedEditor.h")))  TGedEditor;
class __attribute__((annotate(R"ATTRDUMP(popup window)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TGedPatternSelect.h")))  __attribute__((annotate("$clingAutoload$TGedMarkerSelect.h")))  TGedPopup;
class __attribute__((annotate(R"ATTRDUMP(pattern frame)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TGedPatternSelect.h")))  __attribute__((annotate("$clingAutoload$TGedMarkerSelect.h")))  TGedPatternFrame;
class __attribute__((annotate(R"ATTRDUMP(select pattern frame)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TGedPatternSelect.h")))  __attribute__((annotate("$clingAutoload$TGedMarkerSelect.h")))  TGedPatternSelector;
class __attribute__((annotate(R"ATTRDUMP(Color selector popup)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TGedPatternSelect.h")))  __attribute__((annotate("$clingAutoload$TGedMarkerSelect.h")))  TGedPatternPopup;
class __attribute__((annotate(R"ATTRDUMP(selection check-button)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TGedPatternSelect.h")))  __attribute__((annotate("$clingAutoload$TGedMarkerSelect.h")))  TGedSelect;
class __attribute__((annotate(R"ATTRDUMP(pattern selection check-button)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TGedPatternSelect.h")))  __attribute__((annotate("$clingAutoload$TGedMarkerSelect.h")))  TGedPatternSelect;
class __attribute__((annotate(R"ATTRDUMP(marker select popup)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TGedMarkerSelect.h")))  TGedMarkerPopup;
class __attribute__((annotate(R"ATTRDUMP(Marker selection button)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TGedMarkerSelect.h")))  TGedMarkerSelect;
class __attribute__((annotate(R"ATTRDUMP(graph editor)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TGraphEditor.h")))  TGraphEditor;
class __attribute__((annotate(R"ATTRDUMP(TH1 editor)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TH1Editor.h")))  TH1Editor;
class __attribute__((annotate(R"ATTRDUMP(TH2 editor)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TH2Editor.h")))  TH2Editor;
class __attribute__((annotate(R"ATTRDUMP(GUI for editing Line attributes)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TLineEditor.h")))  TLineEditor;
class __attribute__((annotate(R"ATTRDUMP(editor of TPad objects)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TPadEditor.h")))  TPadEditor;
class __attribute__((annotate(R"ATTRDUMP(GUI for editing TPaveStats)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TPaveStatsEditor.h")))  TPaveStatsEditor;
class __attribute__((annotate(R"ATTRDUMP(piechart editor)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TPieEditor.h")))  TPieEditor;
class __attribute__((annotate(R"ATTRDUMP(piechart' slice editor)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TPieSliceEditor.h")))  TPieSliceEditor;
class __attribute__((annotate(R"ATTRDUMP(Dialog box used by the TStyleManager class)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TStyleDialog.h")))  TStyleDialog;
class __attribute__((annotate(R"ATTRDUMP(Graphical User Interface for managing styles)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TStyleManager.h")))  TStyleManager;
class __attribute__((annotate(R"ATTRDUMP(Preview window used by the TStyleManager class)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TStylePreview.h")))  TStylePreview;
class __attribute__((annotate(R"ATTRDUMP(text editor)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TTextEditor.h")))  TTextEditor;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module libEve: '
#line 1 "libEve dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class __attribute__((annotate(R"ATTRDUMP(Base class for TEveUtil visualization elements, providing hierarchy management, rendering control and list-tree item management.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base class for TEveUtil visualization elements, providing hierarchy management, rendering control and list-tree item management.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base class for TEveUtil visualization elements, providing hierarchy management, rendering control and list-tree item management.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base class for TEveUtil visualization elements, providing hierarchy management, rendering control and list-tree item management.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveElement.h")))  __attribute__((annotate("$clingAutoload$TEveBrowser.h")))  TEveElement;
namespace std{template <typename _Tp> struct __attribute__((annotate("$clingAutoload$bits/stl_list.h")))  __attribute__((annotate("$clingAutoload$TEveBrowser.h")))  _List_iterator;
}
namespace std{template <typename _Tp> struct __attribute__((annotate("$clingAutoload$bits/stl_list.h")))  __attribute__((annotate("$clingAutoload$TEveBrowser.h")))  _List_const_iterator;
}
namespace std{template <typename _Tp> struct __attribute__((annotate("$clingAutoload$bits/stl_tree.h")))  __attribute__((annotate("$clingAutoload$TEveBrowser.h")))  _Rb_tree_const_iterator;
}
class __attribute__((annotate(R"ATTRDUMP(Standard utility functions for Reve.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Standard utility functions for Reve.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Standard utility functions for Reve.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Standard utility functions for Reve.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveUtil.h")))  __attribute__((annotate("$clingAutoload$TEveBrowser.h")))  TEveUtil;
class __attribute__((annotate(R"ATTRDUMP(Exception-type thrown by Eve classes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Exception-type thrown by Eve classes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Exception-type thrown by Eve classes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Exception-type thrown by Eve classes.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveUtil.h")))  __attribute__((annotate("$clingAutoload$TEveBrowser.h")))  TEveException;
class __attribute__((annotate(R"ATTRDUMP(Exception-safe wrapper for temporary setting of gPad variable.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Exception-safe wrapper for temporary setting of gPad variable.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Exception-safe wrapper for temporary setting of gPad variable.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Exception-safe wrapper for temporary setting of gPad variable.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveUtil.h")))  __attribute__((annotate("$clingAutoload$TEveBrowser.h")))  TEvePadHolder;
class __attribute__((annotate(R"ATTRDUMP(Exception-safe wrapper for temporary setting of gGeoManager variable.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Exception-safe wrapper for temporary setting of gGeoManager variable.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Exception-safe wrapper for temporary setting of gGeoManager variable.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Exception-safe wrapper for temporary setting of gGeoManager variable.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveUtil.h")))  __attribute__((annotate("$clingAutoload$TEveBrowser.h")))  TEveGeoManagerHolder;
class __attribute__((annotate(R"ATTRDUMP(Base-class for reference-counted objects.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base-class for reference-counted objects.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base-class for reference-counted objects.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base-class for reference-counted objects.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveUtil.h")))  __attribute__((annotate("$clingAutoload$TEveBrowser.h")))  TEveRefCnt;
class __attribute__((annotate(R"ATTRDUMP(Base-class for reference-counted objects with reverse references to TEveElement objects.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base-class for reference-counted objects with reverse references to TEveElement objects.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base-class for reference-counted objects with reverse references to TEveElement objects.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base-class for reference-counted objects with reverse references to TEveElement objects.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveUtil.h")))  __attribute__((annotate("$clingAutoload$TEveBrowser.h")))  TEveRefBackPtr;
namespace std{template <typename _Tp> class __attribute__((annotate("$clingAutoload$bits/allocator.h")))  __attribute__((annotate("$clingAutoload$string")))  allocator;
}
namespace std{template <typename _Tp = void> struct __attribute__((annotate("$clingAutoload$bits/stl_function.h")))  __attribute__((annotate("$clingAutoload$string")))  less;
}
class __attribute__((annotate(R"ATTRDUMP(Abstract base class for classes that can be transformed with non-linear projections.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Abstract base class for classes that can be transformed with non-linear projections.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Abstract base class for classes that can be transformed with non-linear projections.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Abstract base class for classes that can be transformed with non-linear projections.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveProjectionBases.h")))  __attribute__((annotate("$clingAutoload$TEveBrowser.h")))  TEveProjectable;
class __attribute__((annotate(R"ATTRDUMP(Abstract base class for classes that hold results of a non-linear projection transformation.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Abstract base class for classes that hold results of a non-linear projection transformation.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Abstract base class for classes that hold results of a non-linear projection transformation.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Abstract base class for classes that hold results of a non-linear projection transformation.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveProjectionBases.h")))  __attribute__((annotate("$clingAutoload$TEveBrowser.h")))  TEveProjected;
class __attribute__((annotate(R"ATTRDUMP(List of TEveElement objects with a possibility to limit the class of accepted elements.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(List of TEveElement objects with a possibility to limit the class of accepted elements.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(List of TEveElement objects with a possibility to limit the class of accepted elements.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(List of TEveElement objects with a possibility to limit the class of accepted elements.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveElement.h")))  __attribute__((annotate("$clingAutoload$TEveBrowser.h")))  TEveElementList;
class __attribute__((annotate(R"ATTRDUMP(Projected TEveElementList.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected TEveElementList.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected TEveElementList.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected TEveElementList.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveElement.h")))  __attribute__((annotate("$clingAutoload$TEveBrowser.h")))  TEveElementListProjected;
class __attribute__((annotate(R"ATTRDUMP(Special llist-tree-item for Eve.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Special llist-tree-item for Eve.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Special llist-tree-item for Eve.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Special llist-tree-item for Eve.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveBrowser.h")))  TEveListTreeItem;
class __attribute__((annotate(R"ATTRDUMP(Composite GUI frame for parallel display of a TGListTree and TEveGedEditor.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Composite GUI frame for parallel display of a TGListTree and TEveGedEditor.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Composite GUI frame for parallel display of a TGListTree and TEveGedEditor.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Composite GUI frame for parallel display of a TGListTree and TEveGedEditor.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveBrowser.h")))  TEveGListTreeEditorFrame;
class __attribute__((annotate(R"ATTRDUMP(Specialization of TRootBrowser for Eve.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Specialization of TRootBrowser for Eve.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Specialization of TRootBrowser for Eve.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Specialization of TRootBrowser for Eve.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveBrowser.h")))  TEveBrowser;
class __attribute__((annotate(R"ATTRDUMP(Vector-like container with chunked memory allocation.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Vector-like container with chunked memory allocation.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Vector-like container with chunked memory allocation.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Vector-like container with chunked memory allocation.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveChunkManager.h")))  TEveChunkManager;
class __attribute__((annotate(R"ATTRDUMP(Container for managing compounds of TEveElements.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Container for managing compounds of TEveElements.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Container for managing compounds of TEveElements.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Container for managing compounds of TEveElements.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveCompound.h")))  TEveCompound;
class __attribute__((annotate(R"ATTRDUMP(Projected TEveCompund container.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected TEveCompund container.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected TEveCompund container.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected TEveCompund container.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveCompound.h")))  TEveCompoundProjected;
class __attribute__((annotate(R"ATTRDUMP(Editor for TEveElement class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveElement class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveElement class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveElement class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveElementEditor.h")))  TEveElementEditor;
class __attribute__((annotate(R"ATTRDUMP(Base class for event management and navigation.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base class for event management and navigation.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base class for event management and navigation.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base class for event management and navigation.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveEventManager.h")))  TEveEventManager;
class __attribute__((annotate(R"ATTRDUMP(Specialization of TGedEditor for proper update propagation to TEveManager.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Specialization of TGedEditor for proper update propagation to TEveManager.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Specialization of TGedEditor for proper update propagation to TEveManager.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Specialization of TGedEditor for proper update propagation to TEveManager.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveGedEditor.h")))  TEveGedEditor;
class __attribute__((annotate(R"ATTRDUMP(Top name-frame used in EVE.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Top name-frame used in EVE.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Top name-frame used in EVE.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Top name-frame used in EVE.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveGedEditor.h")))  TEveGedNameFrame;
class __attribute__((annotate(R"ATTRDUMP(Button for GED name-frame.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Button for GED name-frame.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Button for GED name-frame.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Button for GED name-frame.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveGedEditor.h")))  TEveGedNameTextButton;
class __attribute__((annotate(R"ATTRDUMP(Base class for composite GUI elements for setting of numeric values.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base class for composite GUI elements for setting of numeric values.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base class for composite GUI elements for setting of numeric values.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base class for composite GUI elements for setting of numeric values.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveGValuators.h")))  TEveGValuatorBase;
class __attribute__((annotate(R"ATTRDUMP(Composite GUI element for single value selection (supports label, number-entry and slider).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Composite GUI element for single value selection (supports label, number-entry and slider).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Composite GUI element for single value selection (supports label, number-entry and slider).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Composite GUI element for single value selection (supports label, number-entry and slider).)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveGValuators.h")))  TEveGValuator;
class __attribute__((annotate(R"ATTRDUMP(Composite GUI element for selection of range (label, two number-entries and double-slider).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Composite GUI element for selection of range (label, two number-entries and double-slider).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Composite GUI element for selection of range (label, two number-entries and double-slider).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Composite GUI element for selection of range (label, two number-entries and double-slider).)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveGValuators.h")))  TEveGDoubleValuator;
class __attribute__((annotate(R"ATTRDUMP(Composite GUI element for setting three numerical values (label, three number-entries).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Composite GUI element for setting three numerical values (label, three number-entries).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Composite GUI element for setting three numerical values (label, three number-entries).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Composite GUI element for setting three numerical values (label, three number-entries).)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveGValuators.h")))  TEveGTriVecValuator;
class __attribute__((annotate(R"ATTRDUMP(TMacro wrapper (attempting to fix issues with different macro loading and execution schemes).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(TMacro wrapper (attempting to fix issues with different macro loading and execution schemes).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(TMacro wrapper (attempting to fix issues with different macro loading and execution schemes).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(TMacro wrapper (attempting to fix issues with different macro loading and execution schemes).)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveMacro.h")))  TEveMacro;
class __attribute__((annotate(R"ATTRDUMP(Eve application manager.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve application manager.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve application manager.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve application manager.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveManager.h")))  TEveManager;
class __attribute__((annotate(R"ATTRDUMP(Internal TEveUtil pad class (sub-class of TPad) overriding handling of updates and 3D-viewers.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Internal TEveUtil pad class (sub-class of TPad) overriding handling of updates and 3D-viewers.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Internal TEveUtil pad class (sub-class of TPad) overriding handling of updates and 3D-viewers.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Internal TEveUtil pad class (sub-class of TPad) overriding handling of updates and 3D-viewers.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEvePad.h")))  TEvePad;
class __attribute__((annotate(R"ATTRDUMP(Eve element to store generic configuration information.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve element to store generic configuration information.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve element to store generic configuration information.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve element to store generic configuration information.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveParamList.h")))  TEveParamList;
class __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveParamList.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveParamList.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveParamList.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveParamList.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveParamList.h")))  TEveParamListEditor;
template <typename TT> class __attribute__((annotate("$clingAutoload$TEveVector.h")))  __attribute__((annotate("$clingAutoload$TEvePathMark.h")))  TEveVectorT;

template <typename TT> class __attribute__((annotate("$clingAutoload$TEveVector.h")))  __attribute__((annotate("$clingAutoload$TEvePathMark.h")))  TEveVector4T;

template <typename TT> class __attribute__((annotate("$clingAutoload$TEveVector.h")))  __attribute__((annotate("$clingAutoload$TEvePathMark.h")))  TEveVector2T;

template <typename TT> class __attribute__((annotate("$clingAutoload$TEvePathMark.h")))  TEvePathMarkT;

class __attribute__((annotate(R"ATTRDUMP(Class to draw scales in non-linear projections.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class to draw scales in non-linear projections.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class to draw scales in non-linear projections.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class to draw scales in non-linear projections.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveProjectionAxes.h")))  TEveProjectionAxes;
class __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveProjectionAxes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveProjectionAxes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveProjectionAxes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveProjectionAxes.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveProjectionAxesEditor.h")))  TEveProjectionAxesEditor;
class __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveProjectionAxes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveProjectionAxes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveProjectionAxes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveProjectionAxes.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveProjectionAxesGL.h")))  TEveProjectionAxesGL;
class __attribute__((annotate(R"ATTRDUMP(Base for specific classes that implement non-linear projections.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base for specific classes that implement non-linear projections.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base for specific classes that implement non-linear projections.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base for specific classes that implement non-linear projections.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveProjections.h")))  __attribute__((annotate("$clingAutoload$TEveProjectionManager.h")))  TEveProjection;
class __attribute__((annotate(R"ATTRDUMP(Rho/Z non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Rho/Z non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Rho/Z non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Rho/Z non-linear projection.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveProjections.h")))  __attribute__((annotate("$clingAutoload$TEveProjectionManager.h")))  TEveRhoZProjection;
class __attribute__((annotate(R"ATTRDUMP(XY non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XY non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XY non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XY non-linear projection.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveProjections.h")))  __attribute__((annotate("$clingAutoload$TEveProjectionManager.h")))  TEveRPhiProjection;
class __attribute__((annotate(R"ATTRDUMP(XZ non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XZ non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XZ non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XZ non-linear projection.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveProjections.h")))  __attribute__((annotate("$clingAutoload$TEveProjectionManager.h")))  TEveXZProjection;
class __attribute__((annotate(R"ATTRDUMP(XY non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XY non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XY non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XY non-linear projection.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveProjections.h")))  __attribute__((annotate("$clingAutoload$TEveProjectionManager.h")))  TEveYZProjection;
class __attribute__((annotate(R"ATTRDUMP(XZ non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XZ non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XZ non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XZ non-linear projection.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveProjections.h")))  __attribute__((annotate("$clingAutoload$TEveProjectionManager.h")))  TEveZXProjection;
class __attribute__((annotate(R"ATTRDUMP(XY non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XY non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XY non-linear projection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XY non-linear projection.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveProjections.h")))  __attribute__((annotate("$clingAutoload$TEveProjectionManager.h")))  TEveZYProjection;
class __attribute__((annotate(R"ATTRDUMP(3D scaling "projection")ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(3D scaling "projection")ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(3D scaling "projection")ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(3D scaling "projection")ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveProjections.h")))  __attribute__((annotate("$clingAutoload$TEveProjectionManager.h")))  TEve3DProjection;
class __attribute__((annotate(R"ATTRDUMP(Manager class for steering of projections and managing projected objects.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Manager class for steering of projections and managing projected objects.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Manager class for steering of projections and managing projected objects.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Manager class for steering of projections and managing projected objects.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveProjectionManager.h")))  TEveProjectionManager;
class __attribute__((annotate(R"ATTRDUMP(Editor for TEveProjectionManager class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveProjectionManager class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveProjectionManager class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveProjectionManager class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveProjectionManagerEditor.h")))  TEveProjectionManagerEditor;
class __attribute__((annotate(R"ATTRDUMP(Reve representation of TGLScene.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reve representation of TGLScene.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reve representation of TGLScene.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reve representation of TGLScene.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveScene.h")))  TEveScene;
class __attribute__((annotate(R"ATTRDUMP(List of Scenes providing common operations on TEveScene collections.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(List of Scenes providing common operations on TEveScene collections.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(List of Scenes providing common operations on TEveScene collections.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(List of Scenes providing common operations on TEveScene collections.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveScene.h")))  TEveSceneList;
class __attribute__((annotate(R"ATTRDUMP(TEveUtil representation of TGLSceneInfo.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(TEveUtil representation of TGLSceneInfo.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(TEveUtil representation of TGLSceneInfo.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(TEveUtil representation of TGLSceneInfo.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveSceneInfo.h")))  TEveSceneInfo;
class __attribute__((annotate(R"ATTRDUMP(Semi-abstract interface for classes supporting secondary-selection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Semi-abstract interface for classes supporting secondary-selection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Semi-abstract interface for classes supporting secondary-selection.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Semi-abstract interface for classes supporting secondary-selection.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveSecondarySelectable.h")))  TEveSecondarySelectable;
class __attribute__((annotate(R"ATTRDUMP(Container for selected and highlighted elements.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Container for selected and highlighted elements.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Container for selected and highlighted elements.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Container for selected and highlighted elements.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveSelection.h")))  TEveSelection;
class __attribute__((annotate(R"ATTRDUMP(Column-major 4x4 transforamtion matrix for homogeneous coordinates.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Column-major 4x4 transforamtion matrix for homogeneous coordinates.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Column-major 4x4 transforamtion matrix for homogeneous coordinates.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Column-major 4x4 transforamtion matrix for homogeneous coordinates.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTrans.h")))  TEveTrans;
class __attribute__((annotate(R"ATTRDUMP(Sub-editor for TEveTrans class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Sub-editor for TEveTrans class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Sub-editor for TEveTrans class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Sub-editor for TEveTrans class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTransEditor.h")))  TEveTransSubEditor;
class __attribute__((annotate(R"ATTRDUMP(Editor for TEveTrans class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveTrans class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveTrans class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveTrans class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTransEditor.h")))  TEveTransEditor;
class __attribute__((annotate(R"ATTRDUMP(TSelector that stores entry numbers of matching TTree entries into an event-list.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(TSelector that stores entry numbers of matching TTree entries into an event-list.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(TSelector that stores entry numbers of matching TTree entries into an event-list.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(TSelector that stores entry numbers of matching TTree entries into an event-list.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTreeTools.h")))  TEveSelectorToEventList;
class __attribute__((annotate(R"ATTRDUMP(Virtual base for classes that can be filled from TTree data via the TEvePointSelector class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Virtual base for classes that can be filled from TTree data via the TEvePointSelector class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Virtual base for classes that can be filled from TTree data via the TEvePointSelector class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Virtual base for classes that can be filled from TTree data via the TEvePointSelector class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTreeTools.h")))  TEvePointSelectorConsumer;
class __attribute__((annotate(R"ATTRDUMP(TSelector for direct extraction of point-like data from a Tree.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(TSelector for direct extraction of point-like data from a Tree.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(TSelector for direct extraction of point-like data from a Tree.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(TSelector for direct extraction of point-like data from a Tree.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTreeTools.h")))  TEvePointSelector;
class __attribute__((annotate(R"ATTRDUMP(Composite frame containing eve-window-controls and eve-windows.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Composite frame containing eve-window-controls and eve-windows.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Composite frame containing eve-window-controls and eve-windows.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Composite frame containing eve-window-controls and eve-windows.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveWindow.h")))  __attribute__((annotate("$clingAutoload$TEveViewer.h")))  TEveCompositeFrame;
class __attribute__((annotate(R"ATTRDUMP(Eve-composite-frame that is contained in one tab of a TGTab.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-composite-frame that is contained in one tab of a TGTab.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-composite-frame that is contained in one tab of a TGTab.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-composite-frame that is contained in one tab of a TGTab.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveWindow.h")))  __attribute__((annotate("$clingAutoload$TEveViewer.h")))  TEveCompositeFrameInMainFrame;
class __attribute__((annotate(R"ATTRDUMP(Eve-composite-frame that is contained in a TGPack.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-composite-frame that is contained in a TGPack.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-composite-frame that is contained in a TGPack.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-composite-frame that is contained in a TGPack.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveWindow.h")))  __attribute__((annotate("$clingAutoload$TEveViewer.h")))  TEveCompositeFrameInPack;
class __attribute__((annotate(R"ATTRDUMP(Eve-composite-frame that is contained in one tab of a TGTab.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-composite-frame that is contained in one tab of a TGTab.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-composite-frame that is contained in one tab of a TGTab.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-composite-frame that is contained in one tab of a TGTab.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveWindow.h")))  __attribute__((annotate("$clingAutoload$TEveViewer.h")))  TEveCompositeFrameInTab;
class __attribute__((annotate(R"ATTRDUMP(Abstract base-class for eve-windows.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Abstract base-class for eve-windows.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Abstract base-class for eve-windows.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Abstract base-class for eve-windows.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveWindow.h")))  __attribute__((annotate("$clingAutoload$TEveViewer.h")))  TEveWindow;
class __attribute__((annotate(R"ATTRDUMP(An unoccupied eve-window slot.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(An unoccupied eve-window slot.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(An unoccupied eve-window slot.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(An unoccupied eve-window slot.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveWindow.h")))  __attribute__((annotate("$clingAutoload$TEveViewer.h")))  TEveWindowSlot;
class __attribute__((annotate(R"ATTRDUMP(Eve-window containing any TGFrame.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-window containing any TGFrame.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-window containing any TGFrame.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-window containing any TGFrame.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveWindow.h")))  __attribute__((annotate("$clingAutoload$TEveViewer.h")))  TEveWindowFrame;
class __attribute__((annotate(R"ATTRDUMP(Eve-window containing a TGPack.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-window containing a TGPack.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-window containing a TGPack.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-window containing a TGPack.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveWindow.h")))  __attribute__((annotate("$clingAutoload$TEveViewer.h")))  TEveWindowPack;
class __attribute__((annotate(R"ATTRDUMP(Eve-window containing a TGTab.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-window containing a TGTab.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-window containing a TGTab.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Eve-window containing a TGTab.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveWindow.h")))  __attribute__((annotate("$clingAutoload$TEveViewer.h")))  TEveWindowTab;
class __attribute__((annotate(R"ATTRDUMP(Specialization of TContextMenu for Eve.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveWindow.h")))  __attribute__((annotate("$clingAutoload$TEveViewer.h")))  TEveContextMenu;
class __attribute__((annotate(R"ATTRDUMP(Reve representation of TGLViewer.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reve representation of TGLViewer.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reve representation of TGLViewer.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reve representation of TGLViewer.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveViewer.h")))  TEveViewer;
class __attribute__((annotate(R"ATTRDUMP(List of Viewers providing common operations on TEveViewer collections.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(List of Viewers providing common operations on TEveViewer collections.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(List of Viewers providing common operations on TEveViewer collections.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(List of Viewers providing common operations on TEveViewer collections.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveViewer.h")))  TEveViewerList;
class __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveViewerList.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveViewerList.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveViewerList.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveViewerList.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveViewerListEditor.h")))  TEveViewerListEditor;
class __attribute__((annotate(R"ATTRDUMP(Monte Carlo track (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Monte Carlo track (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Monte Carlo track (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Monte Carlo track (also used in VSD).)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveVSDStructs.h")))  __attribute__((annotate("$clingAutoload$TEveVSD.h")))  TEveMCTrack;
class __attribute__((annotate(R"ATTRDUMP(Monte Carlo hit (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Monte Carlo hit (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Monte Carlo hit (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Monte Carlo hit (also used in VSD).)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveVSDStructs.h")))  __attribute__((annotate("$clingAutoload$TEveVSD.h")))  TEveHit;
class __attribute__((annotate(R"ATTRDUMP(Reconstructed cluster (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reconstructed cluster (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reconstructed cluster (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reconstructed cluster (also used in VSD).)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveVSDStructs.h")))  __attribute__((annotate("$clingAutoload$TEveVSD.h")))  TEveCluster;
template <typename TT> class __attribute__((annotate("$clingAutoload$TEveVSDStructs.h")))  __attribute__((annotate("$clingAutoload$TEveVSD.h")))  TEveRecTrackT;

class __attribute__((annotate(R"ATTRDUMP(Reconstructed kink (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reconstructed kink (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reconstructed kink (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reconstructed kink (also used in VSD).)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveVSDStructs.h")))  __attribute__((annotate("$clingAutoload$TEveVSD.h")))  TEveRecKink;
class __attribute__((annotate(R"ATTRDUMP(Reconstructed V0 (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reconstructed V0 (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reconstructed V0 (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reconstructed V0 (also used in VSD).)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveVSDStructs.h")))  __attribute__((annotate("$clingAutoload$TEveVSD.h")))  TEveRecV0;
class __attribute__((annotate(R"ATTRDUMP(Reconstructed Cascade (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reconstructed Cascade (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reconstructed Cascade (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Reconstructed Cascade (also used in VSD).)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveVSDStructs.h")))  __attribute__((annotate("$clingAutoload$TEveVSD.h")))  TEveRecCascade;
class __attribute__((annotate(R"ATTRDUMP(Cross-reference of sim/rec data per particle (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Cross-reference of sim/rec data per particle (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Cross-reference of sim/rec data per particle (also used in VSD).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Cross-reference of sim/rec data per particle (also used in VSD).)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveVSDStructs.h")))  __attribute__((annotate("$clingAutoload$TEveVSD.h")))  TEveMCRecCrossRef;
class __attribute__((annotate(R"ATTRDUMP(Visualization Summary Data - a collection of trees holding standard event data in experiment independent format.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Visualization Summary Data - a collection of trees holding standard event data in experiment independent format.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Visualization Summary Data - a collection of trees holding standard event data in experiment independent format.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Visualization Summary Data - a collection of trees holding standard event data in experiment independent format.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveVSD.h")))  TEveVSD;
class __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveWindow.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveWindow.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveWindow.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveWindow.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveWindowEditor.h")))  TEveWindowEditor;
class __attribute__((annotate(R"ATTRDUMP(Manager for EVE windows.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Manager for EVE windows.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Manager for EVE windows.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Manager for EVE windows.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveWindowManager.h")))  TEveWindowManager;
class __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveArrow.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveArrow.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveArrow.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveArrow.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveArrowEditor.h")))  TEveArrowEditor;
class __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveArrow.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveArrow.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveArrow.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveArrow.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveArrowGL.h")))  TEveArrowGL;
class __attribute__((annotate(R"ATTRDUMP(Class for gl visualisation of arrow.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class for gl visualisation of arrow.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class for gl visualisation of arrow.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class for gl visualisation of arrow.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveArrow.h")))  TEveArrow;
class __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveBox.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveBox.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveBox.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveBox.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveBoxGL.h")))  TEveBoxGL;
class __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveBoxProjected.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveBoxProjected.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveBoxProjected.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveBoxProjected.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveBoxGL.h")))  TEveBoxProjectedGL;
class __attribute__((annotate(R"ATTRDUMP(Abstract base-class for 2D/3D shapes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Abstract base-class for 2D/3D shapes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Abstract base-class for 2D/3D shapes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Abstract base-class for 2D/3D shapes.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveShape.h")))  __attribute__((annotate("$clingAutoload$TEveBox.h")))  TEveShape;
class __attribute__((annotate(R"ATTRDUMP(3D box with arbitrary vertices.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(3D box with arbitrary vertices.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(3D box with arbitrary vertices.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(3D box with arbitrary vertices.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveBox.h")))  TEveBox;
class __attribute__((annotate(R"ATTRDUMP(Projection of TEveBox.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projection of TEveBox.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projection of TEveBox.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projection of TEveBox.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveBox.h")))  TEveBoxProjected;
class __attribute__((annotate(R"ATTRDUMP(Description of a 2D or 3D frame that can be used to visually group a set of objects.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Description of a 2D or 3D frame that can be used to visually group a set of objects.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Description of a 2D or 3D frame that can be used to visually group a set of objects.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Description of a 2D or 3D frame that can be used to visually group a set of objects.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveFrameBox.h")))  __attribute__((annotate("$clingAutoload$TEveBoxSetGL.h")))  TEveFrameBox;
class __attribute__((annotate(R"ATTRDUMP(A generic, speed-optimised mapping from value to RGBA color supporting different wrapping and range truncation modes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(A generic, speed-optimised mapping from value to RGBA color supporting different wrapping and range truncation modes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(A generic, speed-optimised mapping from value to RGBA color supporting different wrapping and range truncation modes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(A generic, speed-optimised mapping from value to RGBA color supporting different wrapping and range truncation modes.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveRGBAPalette.h")))  __attribute__((annotate("$clingAutoload$TEveBoxSetGL.h")))  TEveRGBAPalette;
class __attribute__((annotate(R"ATTRDUMP(Base-class for storage of digit collections; provides transformation matrix (TEveTrans), signal to color mapping (TEveRGBAPalette) and visual grouping (TEveFrameBox).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base-class for storage of digit collections; provides transformation matrix (TEveTrans), signal to color mapping (TEveRGBAPalette) and visual grouping (TEveFrameBox).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base-class for storage of digit collections; provides transformation matrix (TEveTrans), signal to color mapping (TEveRGBAPalette) and visual grouping (TEveFrameBox).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base-class for storage of digit collections; provides transformation matrix (TEveTrans), signal to color mapping (TEveRGBAPalette) and visual grouping (TEveFrameBox).)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveDigitSet.h")))  __attribute__((annotate("$clingAutoload$TEveBoxSetGL.h")))  TEveDigitSet;
class __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveDigitSet.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveDigitSet.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveDigitSet.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveDigitSet.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveDigitSetGL.h")))  __attribute__((annotate("$clingAutoload$TEveBoxSetGL.h")))  TEveDigitSetGL;
class __attribute__((annotate(R"ATTRDUMP(Collection of 3D primitives (fixed-size boxes, boxes of different sizes, or arbitrary sexto-epipeds); each primitive can be assigned a signal value and a TRef.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Collection of 3D primitives (fixed-size boxes, boxes of different sizes, or arbitrary sexto-epipeds); each primitive can be assigned a signal value and a TRef.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Collection of 3D primitives (fixed-size boxes, boxes of different sizes, or arbitrary sexto-epipeds); each primitive can be assigned a signal value and a TRef.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Collection of 3D primitives (fixed-size boxes, boxes of different sizes, or arbitrary sexto-epipeds); each primitive can be assigned a signal value and a TRef.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveBoxSet.h")))  __attribute__((annotate("$clingAutoload$TEveBoxSetGL.h")))  TEveBoxSet;
class __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveBoxSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveBoxSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveBoxSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveBoxSet class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveBoxSetGL.h")))  TEveBoxSetGL;
class __attribute__((annotate(R"ATTRDUMP(Manages calorimeter event data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Manages calorimeter event data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Manages calorimeter event data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Manages calorimeter event data.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveCaloData.h")))  __attribute__((annotate("$clingAutoload$TEveCalo2DGL.h")))  TEveCaloData;
class __attribute__((annotate(R"ATTRDUMP(Manages calorimeter event data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Manages calorimeter event data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Manages calorimeter event data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Manages calorimeter event data.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveCaloData.h")))  __attribute__((annotate("$clingAutoload$TEveCalo2DGL.h")))  TEveCaloDataVec;
class __attribute__((annotate(R"ATTRDUMP(Manages calorimeter TH2F event data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Manages calorimeter TH2F event data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Manages calorimeter TH2F event data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Manages calorimeter TH2F event data.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveCaloData.h")))  __attribute__((annotate("$clingAutoload$TEveCalo2DGL.h")))  TEveCaloDataHist;
class __attribute__((annotate(R"ATTRDUMP(Base-class for visualization of calorimeter eventdata.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base-class for visualization of calorimeter eventdata.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base-class for visualization of calorimeter eventdata.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Base-class for visualization of calorimeter eventdata.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveCalo.h")))  __attribute__((annotate("$clingAutoload$TEveCalo2DGL.h")))  TEveCaloViz;
class __attribute__((annotate(R"ATTRDUMP(Class for 3D visualization of calorimeter event data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class for 3D visualization of calorimeter event data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class for 3D visualization of calorimeter event data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class for 3D visualization of calorimeter event data.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveCalo.h")))  __attribute__((annotate("$clingAutoload$TEveCalo2DGL.h")))  TEveCalo3D;
class __attribute__((annotate(R"ATTRDUMP(Class for visualization of projected calorimeter event data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class for visualization of projected calorimeter event data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class for visualization of projected calorimeter event data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class for visualization of projected calorimeter event data.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveCalo.h")))  __attribute__((annotate("$clingAutoload$TEveCalo2DGL.h")))  TEveCalo2D;
class __attribute__((annotate(R"ATTRDUMP(Class for visualization of calorimeter histogram data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class for visualization of calorimeter histogram data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class for visualization of calorimeter histogram data.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class for visualization of calorimeter histogram data.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveCalo.h")))  __attribute__((annotate("$clingAutoload$TEveCalo2DGL.h")))  TEveCaloLego;
class __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveCalo2D.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveCalo2D.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveCalo2D.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveCalo2D.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveCalo2DGL.h")))  TEveCalo2DGL;
class __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveCalo.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveCalo.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveCalo.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveCalo.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveCalo3DGL.h")))  TEveCalo3DGL;
class __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveCaloLego.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveCaloLego.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveCaloLego.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveCaloLego.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveCaloLegoEditor.h")))  TEveCaloLegoEditor;
class __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveCaloLego.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveCaloLego.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveCaloLego.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveCaloLego.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveCaloLegoGL.h")))  TEveCaloLegoGL;
class __attribute__((annotate(R"ATTRDUMP(GL-overaly control GUI for TEveCaloLego.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-overaly control GUI for TEveCaloLego.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-overaly control GUI for TEveCaloLego.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-overaly control GUI for TEveCaloLego.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveCaloLegoOverlay.h")))  TEveCaloLegoOverlay;
class __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveCaloVizEditor.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveCaloVizEditor.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveCaloVizEditor.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveCaloVizEditor.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveCaloVizEditor.h")))  TEveCaloVizEditor;
class __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveCalo3DEditor.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveCalo3DEditor.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveCalo3DEditor.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveCalo3DEditor.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveCaloVizEditor.h")))  TEveCalo3DEditor;
class __attribute__((annotate(R"ATTRDUMP(Editor for TEveDigitSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveDigitSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveDigitSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveDigitSet class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveDigitSetEditor.h")))  TEveDigitSetEditor;
class __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveFrameBox class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveFrameBox class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveFrameBox class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveFrameBox class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveFrameBoxGL.h")))  TEveFrameBoxGL;
class __attribute__((annotate(R"ATTRDUMP(Editor for TEveGeoNode class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveGeoNode class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveGeoNode class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveGeoNode class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveGeoNodeEditor.h")))  TEveGeoNodeEditor;
class __attribute__((annotate(R"ATTRDUMP(Editor for TEveGeoTopNode class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveGeoTopNode class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveGeoTopNode class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveGeoTopNode class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveGeoNodeEditor.h")))  TEveGeoTopNodeEditor;
class __attribute__((annotate(R"ATTRDUMP(Wrapper for TGeoNode that allows it to be shown in GUI and controlled as a TEveElement.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Wrapper for TGeoNode that allows it to be shown in GUI and controlled as a TEveElement.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Wrapper for TGeoNode that allows it to be shown in GUI and controlled as a TEveElement.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Wrapper for TGeoNode that allows it to be shown in GUI and controlled as a TEveElement.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveGeoNode.h")))  TEveGeoNode;
class __attribute__((annotate(R"ATTRDUMP(Top-level TEveGeoNode with a pointer to TGeoManager and controls for steering of TGeoPainter.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Top-level TEveGeoNode with a pointer to TGeoManager and controls for steering of TGeoPainter.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Top-level TEveGeoNode with a pointer to TGeoManager and controls for steering of TGeoPainter.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Top-level TEveGeoNode with a pointer to TGeoManager and controls for steering of TGeoPainter.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveGeoNode.h")))  TEveGeoTopNode;
class __attribute__((annotate(R"ATTRDUMP(A shape with arbitrary tesselation for visualization of CSG shapes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(A shape with arbitrary tesselation for visualization of CSG shapes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(A shape with arbitrary tesselation for visualization of CSG shapes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(A shape with arbitrary tesselation for visualization of CSG shapes.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveGeoPolyShape.h")))  TEveGeoPolyShape;
class __attribute__((annotate(R"ATTRDUMP(Globally positioned TGeoShape with rendering attributes and an optional list of daughter shape-extracts.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Globally positioned TGeoShape with rendering attributes and an optional list of daughter shape-extracts.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Globally positioned TGeoShape with rendering attributes and an optional list of daughter shape-extracts.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Globally positioned TGeoShape with rendering attributes and an optional list of daughter shape-extracts.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveGeoShapeExtract.h")))  TEveGeoShapeExtract;
class __attribute__((annotate(R"ATTRDUMP(Wrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for NLT projections).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Wrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for NLT projections).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Wrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for NLT projections).)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Wrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for NLT projections).)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveGeoShape.h")))  TEveGeoShape;
class __attribute__((annotate("$clingAutoload$TEveGeoShape.h")))  TEveGeoShapeProjected;
class __attribute__((annotate(R"ATTRDUMP(Sub-editor for TEveGridStepper class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Sub-editor for TEveGridStepper class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Sub-editor for TEveGridStepper class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Sub-editor for TEveGridStepper class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveGridStepperEditor.h")))  TEveGridStepperSubEditor;
class __attribute__((annotate(R"ATTRDUMP(Editor for TEveGridStepper class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveGridStepper class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveGridStepper class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveGridStepper class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveGridStepperEditor.h")))  TEveGridStepperEditor;
class __attribute__((annotate(R"ATTRDUMP(Provide discrete position coordinates for placement of objects on regular grids.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Provide discrete position coordinates for placement of objects on regular grids.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Provide discrete position coordinates for placement of objects on regular grids.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Provide discrete position coordinates for placement of objects on regular grids.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveGridStepper.h")))  TEveGridStepper;
class __attribute__((annotate(R"ATTRDUMP(Short description.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Short description.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Short description.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Short description.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveJetCone.h")))  TEveJetCone;
class __attribute__((annotate(R"ATTRDUMP(Projection of TEveJetCone.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projection of TEveJetCone.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projection of TEveJetCone.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projection of TEveJetCone.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveJetCone.h")))  TEveJetConeProjected;
class __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveJetCone.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveJetCone.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveJetCone.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveJetCone.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveJetConeEditor.h")))  TEveJetConeEditor;
class __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveJetCone.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveJetCone.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveJetCone.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveJetCone.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveJetConeGL.h")))  TEveJetConeGL;
class __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveJetCone.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveJetCone.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveJetCone.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveJetCone.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveJetConeGL.h")))  TEveJetConeProjectedGL;
class __attribute__((annotate(R"ATTRDUMP(A GL event handler class. Swiches perspective or orthographic camera.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(A GL event handler class. Swiches perspective or orthographic camera.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(A GL event handler class. Swiches perspective or orthographic camera.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(A GL event handler class. Swiches perspective or orthographic camera.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveLegoEventHandler.h")))  TEveLegoEventHandler;
class __attribute__((annotate(R"ATTRDUMP(Editor for TEveLine class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveLine class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveLine class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveLine class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveLineEditor.h")))  TEveLineEditor;
class __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveLine class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveLine class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveLine class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveLine class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveLineGL.h")))  TEveLineGL;
class __attribute__((annotate(R"ATTRDUMP(Set of 3D points with same marker attributes; optionally each point can be assigned an external TRef or a number of integer indices.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Set of 3D points with same marker attributes; optionally each point can be assigned an external TRef or a number of integer indices.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Set of 3D points with same marker attributes; optionally each point can be assigned an external TRef or a number of integer indices.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Set of 3D points with same marker attributes; optionally each point can be assigned an external TRef or a number of integer indices.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEvePointSet.h")))  __attribute__((annotate("$clingAutoload$TEveLine.h")))  TEvePointSet;
class __attribute__((annotate(R"ATTRDUMP(Array of TEvePointSet's filled via a common point-source; range of displayed TEvePointSet's can be controlled, based on a separating quantity provided on fill-time by a user.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Array of TEvePointSet's filled via a common point-source; range of displayed TEvePointSet's can be controlled, based on a separating quantity provided on fill-time by a user.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Array of TEvePointSet's filled via a common point-source; range of displayed TEvePointSet's can be controlled, based on a separating quantity provided on fill-time by a user.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Array of TEvePointSet's filled via a common point-source; range of displayed TEvePointSet's can be controlled, based on a separating quantity provided on fill-time by a user.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEvePointSet.h")))  __attribute__((annotate("$clingAutoload$TEveLine.h")))  TEvePointSetArray;
class __attribute__((annotate(R"ATTRDUMP(Projected copy of a TEvePointSet.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected copy of a TEvePointSet.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected copy of a TEvePointSet.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected copy of a TEvePointSet.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEvePointSet.h")))  __attribute__((annotate("$clingAutoload$TEveLine.h")))  TEvePointSetProjected;
class __attribute__((annotate(R"ATTRDUMP(An arbitrary polyline with fixed line and marker attributes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(An arbitrary polyline with fixed line and marker attributes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(An arbitrary polyline with fixed line and marker attributes.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(An arbitrary polyline with fixed line and marker attributes.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveLine.h")))  TEveLine;
class __attribute__((annotate(R"ATTRDUMP(Projected replica of a TEveLine.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected replica of a TEveLine.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected replica of a TEveLine.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected replica of a TEveLine.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveLine.h")))  TEveLineProjected;
class __attribute__((annotate(R"ATTRDUMP(Short description.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Short description.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Short description.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Short description.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEvePlot3D.h")))  TEvePlot3D;
class __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEvePlot3D.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEvePlot3D.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEvePlot3D.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEvePlot3D.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEvePlot3DGL.h")))  TEvePlot3DGL;
class __attribute__((annotate(R"ATTRDUMP(Editor for TEvePointSetArray class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEvePointSetArray class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEvePointSetArray class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEvePointSetArray class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEvePointSetArrayEditor.h")))  TEvePointSetArrayEditor;
class __attribute__((annotate(R"ATTRDUMP(Set of projected polygons with outline; typically produced from a TBuffer3D.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Set of projected polygons with outline; typically produced from a TBuffer3D.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Set of projected polygons with outline; typically produced from a TBuffer3D.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Set of projected polygons with outline; typically produced from a TBuffer3D.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEvePolygonSetProjected.h")))  TEvePolygonSetProjected;
class __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEvePolygonSetProjected class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEvePolygonSetProjected class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEvePolygonSetProjected class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEvePolygonSetProjected class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEvePolygonSetProjectedGL.h")))  TEvePolygonSetProjectedGL;
class __attribute__((annotate(R"ATTRDUMP(Collection of 2D primitives (rectangles, hexagons, or lines); each primitive can be assigned a signal value and a TRef.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Collection of 2D primitives (rectangles, hexagons, or lines); each primitive can be assigned a signal value and a TRef.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Collection of 2D primitives (rectangles, hexagons, or lines); each primitive can be assigned a signal value and a TRef.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Collection of 2D primitives (rectangles, hexagons, or lines); each primitive can be assigned a signal value and a TRef.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveQuadSet.h")))  TEveQuadSet;
class __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveQuadSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveQuadSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveQuadSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveQuadSet class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveQuadSetGL.h")))  TEveQuadSetGL;
class __attribute__((annotate(R"ATTRDUMP(Sub-editor for TEveRGBAPalette class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Sub-editor for TEveRGBAPalette class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Sub-editor for TEveRGBAPalette class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Sub-editor for TEveRGBAPalette class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveRGBAPaletteEditor.h")))  TEveRGBAPaletteSubEditor;
class __attribute__((annotate(R"ATTRDUMP(Editor for TEveRGBAPalette class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveRGBAPalette class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveRGBAPalette class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveRGBAPalette class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveRGBAPaletteEditor.h")))  TEveRGBAPaletteEditor;
class __attribute__((annotate(R"ATTRDUMP(Draws TEveRGBAPalette as GL overlay.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Draws TEveRGBAPalette as GL overlay.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Draws TEveRGBAPalette as GL overlay.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Draws TEveRGBAPalette as GL overlay.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveRGBAPaletteOverlay.h")))  TEveRGBAPaletteOverlay;
class __attribute__((annotate(R"ATTRDUMP(Set of straight lines with optional markers along the lines.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Set of straight lines with optional markers along the lines.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Set of straight lines with optional markers along the lines.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Set of straight lines with optional markers along the lines.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveStraightLineSet.h")))  __attribute__((annotate("$clingAutoload$TEveScalableStraightLineSet.h")))  TEveStraightLineSet;
class __attribute__((annotate(R"ATTRDUMP(Projected copy of a TEveStraightLineSet.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected copy of a TEveStraightLineSet.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected copy of a TEveStraightLineSet.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected copy of a TEveStraightLineSet.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveStraightLineSet.h")))  __attribute__((annotate("$clingAutoload$TEveScalableStraightLineSet.h")))  TEveStraightLineSetProjected;
class __attribute__((annotate(R"ATTRDUMP(Straight-line-set with extra scaling.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Straight-line-set with extra scaling.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Straight-line-set with extra scaling.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Straight-line-set with extra scaling.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveScalableStraightLineSet.h")))  TEveScalableStraightLineSet;
class __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveShape.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveShape.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveShape.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveShape.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveShapeEditor.h")))  TEveShapeEditor;
class __attribute__((annotate(R"ATTRDUMP(Editor for TEveStraightLineSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveStraightLineSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveStraightLineSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveStraightLineSet class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveStraightLineSetEditor.h")))  TEveStraightLineSetEditor;
class __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveStraightLineSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveStraightLineSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveStraightLineSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveStraightLineSet class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveStraightLineSetGL.h")))  TEveStraightLineSetGL;
class __attribute__((annotate(R"ATTRDUMP(Class for visualisation of text with FTGL font.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class for visualisation of text with FTGL font.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class for visualisation of text with FTGL font.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Class for visualisation of text with FTGL font.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveText.h")))  TEveText;
class __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveText.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveText.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveText.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GUI editor for TEveText.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTextEditor.h")))  TEveTextEditor;
class __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveText.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveText.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveText.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL renderer class for TEveText.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTextGL.h")))  TEveTextGL;
class __attribute__((annotate(R"ATTRDUMP(Track with given vertex, momentum and optional referece-points (path-marks) along its path.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Track with given vertex, momentum and optional referece-points (path-marks) along its path.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Track with given vertex, momentum and optional referece-points (path-marks) along its path.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Track with given vertex, momentum and optional referece-points (path-marks) along its path.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTrack.h")))  TEveTrack;
class __attribute__((annotate(R"ATTRDUMP(A list of tracks supporting change of common attributes and selection based on track parameters.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(A list of tracks supporting change of common attributes and selection based on track parameters.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(A list of tracks supporting change of common attributes and selection based on track parameters.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(A list of tracks supporting change of common attributes and selection based on track parameters.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTrack.h")))  TEveTrackList;
class __attribute__((annotate(R"ATTRDUMP(Editor for TEveTrack class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveTrack class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveTrack class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveTrack class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTrackEditor.h")))  TEveTrackEditor;
class __attribute__((annotate(R"ATTRDUMP(Editor for TEveTrackList class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveTrackList class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveTrackList class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveTrackList class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTrackEditor.h")))  TEveTrackListEditor;
class __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveTrack class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveTrack class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveTrack class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveTrack class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTrackGL.h")))  TEveTrackGL;
class __attribute__((annotate(R"ATTRDUMP(Projected copy of a TEveTrack.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected copy of a TEveTrack.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected copy of a TEveTrack.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Projected copy of a TEveTrack.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTrackProjected.h")))  TEveTrackProjected;
class __attribute__((annotate(R"ATTRDUMP(Specialization of TEveTrackList for holding TEveTrackProjected objects.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Specialization of TEveTrackList for holding TEveTrackProjected objects.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Specialization of TEveTrackList for holding TEveTrackProjected objects.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Specialization of TEveTrackList for holding TEveTrackProjected objects.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTrackProjected.h")))  TEveTrackListProjected;
class __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveTrackProjected class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveTrackProjected class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveTrackProjected class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveTrackProjected class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTrackProjectedGL.h")))  TEveTrackProjectedGL;
class __attribute__((annotate(R"ATTRDUMP(Abstract interface to magnetic field)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Abstract interface to magnetic field)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Abstract interface to magnetic field)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Abstract interface to magnetic field)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTrackPropagator.h")))  TEveMagField;
class __attribute__((annotate(R"ATTRDUMP(Interface to constant magnetic field.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Interface to constant magnetic field.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Interface to constant magnetic field.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Interface to constant magnetic field.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTrackPropagator.h")))  TEveMagFieldConst;
class __attribute__((annotate(R"ATTRDUMP(Interface to magnetic field with two different values depending on radius.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Interface to magnetic field with two different values depending on radius.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Interface to magnetic field with two different values depending on radius.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Interface to magnetic field with two different values depending on radius.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTrackPropagator.h")))  TEveMagFieldDuo;
class __attribute__((annotate(R"ATTRDUMP(Calculates path of a particle taking into account special path-marks and imposed boundaries.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Calculates path of a particle taking into account special path-marks and imposed boundaries.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Calculates path of a particle taking into account special path-marks and imposed boundaries.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Calculates path of a particle taking into account special path-marks and imposed boundaries.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTrackPropagator.h")))  TEveTrackPropagator;
class __attribute__((annotate(R"ATTRDUMP(Sub-editor for TEveTrackPropagator class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Sub-editor for TEveTrackPropagator class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Sub-editor for TEveTrackPropagator class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Sub-editor for TEveTrackPropagator class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTrackPropagatorEditor.h")))  TEveTrackPropagatorSubEditor;
class __attribute__((annotate(R"ATTRDUMP(Editor for TEveTrackPropagator class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveTrackPropagator class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveTrackPropagator class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveTrackPropagator class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTrackPropagatorEditor.h")))  TEveTrackPropagatorEditor;
class __attribute__((annotate(R"ATTRDUMP(Generic mesh or soup of triangles with per-triangle normals and colors.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Generic mesh or soup of triangles with per-triangle normals and colors.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Generic mesh or soup of triangles with per-triangle normals and colors.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Generic mesh or soup of triangles with per-triangle normals and colors.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTriangleSet.h")))  TEveTriangleSet;
class __attribute__((annotate(R"ATTRDUMP(Editor for TEveTriangleSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveTriangleSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveTriangleSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(Editor for TEveTriangleSet class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTriangleSetEditor.h")))  TEveTriangleSetEditor;
class __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveTriangleSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveTriangleSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveTriangleSet class.)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(GL-renderer for TEveTriangleSet class.)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TEveTriangleSetGL.h")))  TEveTriangleSetGL;
typedef float Float_t __attribute__((annotate("$clingAutoload$RtypesCore.h"))) ;
typedef TEveVectorT<Float_t> TEveVector __attribute__((annotate("$clingAutoload$TEveVector.h")))  __attribute__((annotate("$clingAutoload$TEvePathMark.h"))) ;
typedef TEveVectorT<Float_t> TEveVectorF __attribute__((annotate("$clingAutoload$TEveVector.h")))  __attribute__((annotate("$clingAutoload$TEvePathMark.h"))) ;
typedef double Double_t __attribute__((annotate("$clingAutoload$RtypesCore.h"))) ;
typedef TEveVectorT<Double_t> TEveVectorD __attribute__((annotate("$clingAutoload$TEveVector.h")))  __attribute__((annotate("$clingAutoload$TEvePathMark.h"))) ;
typedef TEveVector4T<Float_t> TEveVector4 __attribute__((annotate("$clingAutoload$TEveVector.h")))  __attribute__((annotate("$clingAutoload$TEvePathMark.h"))) ;
typedef TEveVector4T<Float_t> TEveVector4F __attribute__((annotate("$clingAutoload$TEveVector.h")))  __attribute__((annotate("$clingAutoload$TEvePathMark.h"))) ;
typedef TEveVector4T<Double_t> TEveVector4D __attribute__((annotate("$clingAutoload$TEveVector.h")))  __attribute__((annotate("$clingAutoload$TEvePathMark.h"))) ;
typedef TEveVector2T<Float_t> TEveVector2 __attribute__((annotate("$clingAutoload$TEveVector.h")))  __attribute__((annotate("$clingAutoload$TEvePathMark.h"))) ;
typedef TEveVector2T<Float_t> TEveVector2F __attribute__((annotate("$clingAutoload$TEveVector.h")))  __attribute__((annotate("$clingAutoload$TEvePathMark.h"))) ;
typedef TEveVector2T<Double_t> TEveVector2D __attribute__((annotate("$clingAutoload$TEveVector.h")))  __attribute__((annotate("$clingAutoload$TEvePathMark.h"))) ;
typedef TEvePathMarkT<Float_t> TEvePathMark __attribute__((annotate("$clingAutoload$TEvePathMark.h"))) ;
typedef TEvePathMarkT<Float_t> TEvePathMarkF __attribute__((annotate("$clingAutoload$TEvePathMark.h"))) ;
typedef TEvePathMarkT<Double_t> TEvePathMarkD __attribute__((annotate("$clingAutoload$TEvePathMark.h"))) ;
typedef TEveRecTrackT<Float_t> TEveRecTrack __attribute__((annotate("$clingAutoload$TEveVSDStructs.h")))  __attribute__((annotate("$clingAutoload$TEveVSD.h"))) ;
typedef TEveRecTrackT<Float_t> TEveRecTrackF __attribute__((annotate("$clingAutoload$TEveVSDStructs.h")))  __attribute__((annotate("$clingAutoload$TEveVSD.h"))) ;
typedef TEveRecTrackT<Double_t> TEveRecTrackD __attribute__((annotate("$clingAutoload$TEveVSDStructs.h")))  __attribute__((annotate("$clingAutoload$TEveVSD.h"))) ;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module libXMLParser: '
#line 1 "libXMLParser dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class __attribute__((annotate(R"ATTRDUMP(XML SAX parser)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XML SAX parser)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XML SAX parser)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XML SAX parser)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TXMLParser.h")))  __attribute__((annotate("$clingAutoload$TDOMParser.h")))  TXMLParser;
class __attribute__((annotate(R"ATTRDUMP(XML document created by the DOM parser)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TXMLDocument.h")))  __attribute__((annotate("$clingAutoload$TDOMParser.h")))  TXMLDocument;
class __attribute__((annotate(R"ATTRDUMP(DOM Parser)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(DOM Parser)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(DOM Parser)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(DOM Parser)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TDOMParser.h")))  TDOMParser;
class __attribute__((annotate(R"ATTRDUMP(SAX Parser)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(SAX Parser)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(SAX Parser)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(SAX Parser)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TSAXParser.h")))  TSAXParser;
class __attribute__((annotate(R"ATTRDUMP(XML attribute pair)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TXMLAttr.h")))  TXMLAttr;
class __attribute__((annotate(R"ATTRDUMP(XML node under DOM tree)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XML node under DOM tree)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XML node under DOM tree)ATTRDUMP"))) __attribute__((annotate(R"ATTRDUMP(XML node under DOM tree)ATTRDUMP"))) __attribute__((annotate("$clingAutoload$TXMLNode.h")))  TXMLNode;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module G__AtParLinkDef: '
#line 1 "G__AtParLinkDef dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class __attribute__((annotate(R"ATTRDUMP(Factory for all SPiRIT parameter containers)ATTRDUMP"))) AtContFact;
class AtDigiPar;
class AtGas;
class AtTriggerPar;
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module G__AtDataLinkDef: '
#line 1 "G__AtDataLinkDef dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
class AtPadBase;
class AtPad;
class AtAuxPad;
class AtPadFFT;
class AtPadArray;
class AtPadValue;
class AtPulserInfo;
struct AtPadReference;
class AtElectronicReference;
class AtBaseEvent;
class __attribute__((annotate("$clingAutoload$AtGenericTrace.h")))  AtGenericTrace;
class AtRawEvent;
class AtHit;
class AtHitCluster;
class AtEvent;
class __attribute__((annotate("$clingAutoload$AtProtoQuadrant.h")))  AtProtoQuadrant;
class AtProtoEvent;
class AtProtoEventAna;
class __attribute__((annotate("$clingAutoload$AtFittedTrack.h")))  AtFittedTrack;
namespace AtPatterns{class __attribute__((annotate("$clingAutoload$AtPattern.h")))  __attribute__((annotate("$clingAutoload$AtTrack.h")))  AtPattern;}
class __attribute__((annotate("$clingAutoload$AtTrack.h")))  AtTrack;
class AtTrackingEvent;
class AtPatternEvent;
namespace MCFitter{class AtMCResult;}
class AtFissionEvent;
namespace AtPatterns{class AtPatternLine;}
namespace AtPatterns{class AtPatternCircle2D;}
namespace AtPatterns{class __attribute__((annotate("$clingAutoload$AtPatternRay.h")))  AtPatternRay;}
namespace AtPatterns{class AtPatternY;}
namespace AtPatterns{class AtPatternFission;}
'
Warning in <TInterpreter::TCling::RegisterModule>: Problems in compiling forward declarations for module G__AtToolsLinkDef: '
#line 1 "G__AtToolsLinkDef dictionary forward declarations' payload"
#pragma clang diagnostic ignored "-Wkeyword-compat"
#pragma clang diagnostic ignored "-Wignored-attributes"
#pragma clang diagnostic ignored "-Wreturn-type-c-linkage"
extern int __Cling_AutoLoading_Map;
namespace AtTools{class AtParsers;}
namespace AtTools{class AtELossManager;}
namespace AtTools{class AtTrackTransformer;}
namespace AtTools{class AtELossModel;}
namespace tk{class __attribute__((annotate("$clingAutoload$AtSpline.h")))  spline;}
namespace AtTools{class AtELossTable;}
class AtFindVertex;
template <typename T> class CSVRow;

template <typename T> class CSVIterator;

namespace std{template <class _CharT> struct __attribute__((annotate("$clingAutoload$bits/char_traits.h")))  __attribute__((annotate("$clingAutoload$string")))  char_traits;
}
namespace std{template <typename > class __attribute__((annotate("$clingAutoload$bits/memoryfwd.h")))  __attribute__((annotate("$clingAutoload$string")))  allocator;
}
template <typename T> class CSVRange;

class AtEulerTransformation;
class AtSpaceChargeModel;
class AtLineChargeModel;
class AtRadialChargeModel;
class AtEDistortionModel;
namespace AtTools{class AtVirtualTerminal;}
namespace AtTools{class AtKinematics;}
namespace RandomSample{class AtSample;}
namespace RandomSample{class __attribute__((annotate("$clingAutoload$AtIndependentSample.h")))  __attribute__((annotate("$clingAutoload$AtChargeWeighted.h")))  AtIndependentSample;}
namespace RandomSample{class __attribute__((annotate("$clingAutoload$AtChargeWeighted.h")))  AtChargeWeighted;}
namespace RandomSample{class __attribute__((annotate("$clingAutoload$AtGaussian.h")))  AtGaussian;}
namespace RandomSample{class __attribute__((annotate("$clingAutoload$AtUniform.h")))  AtUniform;}
namespace RandomSample{class __attribute__((annotate("$clingAutoload$AtWeightedGaussian.h")))  AtWeightedGaussian;}
namespace RandomSample{class __attribute__((annotate("$clingAutoload$AtWeightedGaussianTrunc.h")))  AtWeightedGaussianTrunc;}
namespace RandomSample{class __attribute__((annotate("$clingAutoload$AtWeightedY.h")))  AtWeightedY;}
namespace RandomSample{class __attribute__((annotate("$clingAutoload$AtY.h")))  AtY;}
namespace ElectronicResponse{class AtElectronicResponse;}
namespace ElectronicResponse{class AtNominalResponse;}
namespace ElectronicResponse{class AtReducedTimeResponse;}
namespace ElectronicResponse{class AtVectorResponse;}
namespace ElectronicResponse{class AtFileResponse;}
namespace AtTools{namespace DataCleaning{class AtDataCleaner;}}
namespace AtTools{namespace DataCleaning{class AtkNN;}}
'
root.exe: /home/physics/fair_install/FairSoft/build/Source/root/interpreter/llvm/src/tools/clang/lib/AST/DeclCXX.cpp:1397: clang::CXXMethodDecl* clang::CXXRecordDecl::getLambdaCallOperator() const: Assertion `!Calls.empty() && "Missing lambda call operator!"' failed.
